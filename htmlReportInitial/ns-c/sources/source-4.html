


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Keys</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.security</a>
</div>

<h1>Coverage Summary for Class: Keys (io.jsonwebtoken.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Keys</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Keys$builder$3</td>
  </tr>
  <tr>
    <td class="name">Keys$builder$4</td>
  </tr>
  <tr>
    <td class="name">Keys$hmacShaKeyFor$2</td>
  </tr>
  <tr>
    <td class="name">Keys$keyPairFor$1</td>
  </tr>
  <tr>
    <td class="name">Keys$password$0</td>
  </tr>
  <tr>
    <td class="name">Keys$secretKeyFor</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.security;
&nbsp;
&nbsp;import io.jsonwebtoken.Jwts;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Classes;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.crypto.spec.SecretKeySpec;
&nbsp;import java.security.KeyPair;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.Provider;
&nbsp;import java.security.PublicKey;
&nbsp;
&nbsp;/**
&nbsp; * Utility class for securely generating {@link SecretKey}s and {@link KeyPair}s.
&nbsp; *
&nbsp; * @since 0.10.0
&nbsp; */
&nbsp;public final class Keys {
&nbsp;
&nbsp;    private static final String BRIDGE_CLASSNAME = &quot;io.jsonwebtoken.impl.security.KeysBridge&quot;;
<b class="fc">&nbsp;    private static final Class&lt;?&gt; BRIDGE_CLASS = Classes.forName(BRIDGE_CLASSNAME);</b>
<b class="fc">&nbsp;    private static final Class&lt;?&gt;[] FOR_PASSWORD_ARG_TYPES = new Class[]{char[].class};</b>
<b class="fc">&nbsp;    private static final Class&lt;?&gt;[] SECRET_BUILDER_ARG_TYPES = new Class[]{SecretKey.class};</b>
<b class="fc">&nbsp;    private static final Class&lt;?&gt;[] PRIVATE_BUILDER_ARG_TYPES = new Class[]{PrivateKey.class};</b>
&nbsp;
&nbsp;    private static &lt;T&gt; T invokeStatic(String method, Class&lt;?&gt;[] argTypes, Object... args) {
<b class="fc">&nbsp;        return Classes.invokeStatic(BRIDGE_CLASS, method, argTypes, args);</b>
&nbsp;    }
&nbsp;
&nbsp;    //prevent instantiation
&nbsp;    private Keys() {
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new SecretKey instance for use with HMAC-SHA algorithms based on the specified key byte array.
&nbsp;     *
&nbsp;     * @param bytes the key byte array
&nbsp;     * @return a new SecretKey instance for use with HMAC-SHA algorithms based on the specified key byte array.
&nbsp;     * @throws WeakKeyException if the key byte array length is less than 256 bits (32 bytes) as mandated by the
&nbsp;     *                          &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.2&quot;&gt;JWT JWA Specification
&nbsp;     *                          (RFC 7518, Section 3.2)&lt;/a&gt;
&nbsp;     */
&nbsp;    public static SecretKey hmacShaKeyFor(byte[] bytes) throws WeakKeyException {
&nbsp;
<b class="fc">&nbsp;        if (bytes == null) {</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(&quot;SecretKey byte array cannot be null.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int bitLength = bytes.length * 8;</b>
&nbsp;
&nbsp;        //Purposefully ordered higher to lower to ensure the strongest key possible can be generated.
<b class="fc">&nbsp;        if (bitLength &gt;= 512) {</b>
<b class="fc">&nbsp;            return new SecretKeySpec(bytes, &quot;HmacSHA512&quot;);</b>
<b class="fc">&nbsp;        } else if (bitLength &gt;= 384) {</b>
<b class="fc">&nbsp;            return new SecretKeySpec(bytes, &quot;HmacSHA384&quot;);</b>
<b class="fc">&nbsp;        } else if (bitLength &gt;= 256) {</b>
<b class="fc">&nbsp;            return new SecretKeySpec(bytes, &quot;HmacSHA256&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        String msg = &quot;The specified key byte array is &quot; + bitLength + &quot; bits which &quot; +</b>
&nbsp;                &quot;is not secure enough for any JWT HMAC-SHA algorithm.  The JWT &quot; +
&nbsp;                &quot;JWA Specification (RFC 7518, Section 3.2) states that keys used with HMAC-SHA algorithms MUST have a &quot; +
&nbsp;                &quot;size &gt;= 256 bits (the key size must be greater than or equal to the hash &quot; +
&nbsp;                &quot;output size).  Consider using the Jwts.SIG.HS256.key() builder (or HS384.key() &quot; +
&nbsp;                &quot;or HS512.key()) to create a key guaranteed to be secure enough for your preferred HMAC-SHA &quot; +
&nbsp;                &quot;algorithm.  See https://tools.ietf.org/html/rfc7518#section-3.2 for more information.&quot;;
<b class="fc">&nbsp;        throw new WeakKeyException(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;&lt;b&gt;Deprecation Notice&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;As of JJWT 0.12.0, symmetric (secret) key algorithm instances can generate a key of suitable
&nbsp;     * length for that specific algorithm by calling their {@code key()} builder method directly. For example:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;pre&gt;&lt;code&gt;
&nbsp;     * {@link Jwts.SIG#HS256}.key().build();
&nbsp;     * {@link Jwts.SIG#HS384}.key().build();
&nbsp;     * {@link Jwts.SIG#HS512}.key().build();
&nbsp;     * &lt;/code&gt;&lt;/pre&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Call those methods as needed instead of this static {@code secretKeyFor} helper method - the returned
&nbsp;     * {@link KeyBuilder} allows callers to specify a preferred Provider or SecureRandom on the builder if
&nbsp;     * desired, whereas this {@code secretKeyFor} method does not. Consequently this helper method will be removed
&nbsp;     * before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Previous Documentation&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Returns a new {@link SecretKey} with a key length suitable for use with the specified {@link SignatureAlgorithm}.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.2&quot;&gt;JWA Specification (RFC 7518), Section 3.2&lt;/a&gt;
&nbsp;     * requires minimum key lengths to be used for each respective Signature Algorithm.  This method returns a
&nbsp;     * secure-random generated SecretKey that adheres to the required minimum key length.  The lengths are:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;table&gt;
&nbsp;     *     &lt;caption&gt;JWA HMAC-SHA Key Length Requirements&lt;/caption&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;th&gt;Algorithm&lt;/th&gt;
&nbsp;     * &lt;th&gt;Key Length&lt;/th&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;256 bits (32 bytes)&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;384 bits (48 bytes)&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;512 bits (64 bytes)&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/table&gt;
&nbsp;     *
&nbsp;     * @param alg the {@code SignatureAlgorithm} to inspect to determine which key length to use.
&nbsp;     * @return a new {@link SecretKey} instance suitable for use with the specified {@link SignatureAlgorithm}.
&nbsp;     * @throws IllegalArgumentException for any input value other than {@link io.jsonwebtoken.SignatureAlgorithm#HS256},
&nbsp;     *                                  {@link io.jsonwebtoken.SignatureAlgorithm#HS384}, or {@link io.jsonwebtoken.SignatureAlgorithm#HS512}
&nbsp;     * @deprecated since 0.12.0.  Use your preferred {@link MacAlgorithm} instance&#39;s
&nbsp;     * {@link MacAlgorithm#key() key()} builder method directly.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    public static SecretKey secretKeyFor(io.jsonwebtoken.SignatureAlgorithm alg) throws IllegalArgumentException {
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;SignatureAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        SecureDigestAlgorithm&lt;?, ?&gt; salg = Jwts.SIG.get().get(alg.name());</b>
<b class="fc">&nbsp;        if (!(salg instanceof MacAlgorithm)) {</b>
<b class="fc">&nbsp;            String msg = &quot;The &quot; + alg.name() + &quot; algorithm does not support shared secret keys.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        return ((MacAlgorithm) salg).key().build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;&lt;b&gt;Deprecation Notice&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;As of JJWT 0.12.0, asymmetric key algorithm instances can generate KeyPairs of suitable strength
&nbsp;     * for that specific algorithm by calling their {@code keyPair()} builder method directly. For example:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwts.SIG.{@link Jwts.SIG#RS256 RS256}.keyPair().build();
&nbsp;     * Jwts.SIG.{@link Jwts.SIG#RS384 RS384}.keyPair().build();
&nbsp;     * Jwts.SIG.{@link Jwts.SIG#RS512 RS512}.keyPair().build();
&nbsp;     * ... etc ...
&nbsp;     * Jwts.SIG.{@link Jwts.SIG#ES512 ES512}.keyPair().build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Call those methods as needed instead of this static {@code keyPairFor} helper method - the returned
&nbsp;     * {@link KeyPairBuilder} allows callers to specify a preferred Provider or SecureRandom on the builder if
&nbsp;     * desired, whereas this {@code keyPairFor} method does not. Consequently this helper method will be removed
&nbsp;     * before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Previous Documentation&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Returns a new {@link KeyPair} suitable for use with the specified asymmetric algorithm.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the {@code alg} argument is an RSA algorithm, a KeyPair is generated based on the following:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;table&gt;
&nbsp;     *     &lt;caption&gt;Generated RSA Key Sizes&lt;/caption&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;th&gt;JWA Algorithm&lt;/th&gt;
&nbsp;     * &lt;th&gt;Key Size&lt;/th&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;2048 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;2048 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;3072 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;3072 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;4096 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;4096 bits&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/table&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;If the {@code alg} argument is an Elliptic Curve algorithm, a KeyPair is generated based on the following:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;table&gt;
&nbsp;     *     &lt;caption&gt;Generated Elliptic Curve Key Parameters&lt;/caption&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;th&gt;JWA Algorithm&lt;/th&gt;
&nbsp;     * &lt;th&gt;Key Size&lt;/th&gt;
&nbsp;     * &lt;th&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-7.6.2&quot;&gt;JWA Curve Name&lt;/a&gt;&lt;/th&gt;
&nbsp;     * &lt;th&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5480#section-2.1.1.1&quot;&gt;ASN1 OID Curve Name&lt;/a&gt;&lt;/th&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES256&lt;/td&gt;
&nbsp;     * &lt;td&gt;256 bits&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code P-256}&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code secp256r1}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES384&lt;/td&gt;
&nbsp;     * &lt;td&gt;384 bits&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code P-384}&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code secp384r1}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES512&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;b&gt;521&lt;/b&gt; bits&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code P-521}&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@code secp521r1}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/table&gt;
&nbsp;     *
&nbsp;     * @param alg the {@code SignatureAlgorithm} to inspect to determine which asymmetric algorithm to use.
&nbsp;     * @return a new {@link KeyPair} suitable for use with the specified asymmetric algorithm.
&nbsp;     * @throws IllegalArgumentException if {@code alg} is not an asymmetric algorithm
&nbsp;     * @deprecated since 0.12.0 in favor of your preferred
&nbsp;     * {@link io.jsonwebtoken.security.SignatureAlgorithm} instance&#39;s
&nbsp;     * {@link SignatureAlgorithm#keyPair() keyPair()} builder method directly.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    public static KeyPair keyPairFor(io.jsonwebtoken.SignatureAlgorithm alg) throws IllegalArgumentException {
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;SignatureAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        SecureDigestAlgorithm&lt;?, ?&gt; salg = Jwts.SIG.get().get(alg.name());</b>
<b class="fc">&nbsp;        if (!(salg instanceof SignatureAlgorithm)) {</b>
<b class="fc">&nbsp;            String msg = &quot;The &quot; + alg.name() + &quot; algorithm does not support Key Pairs.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        SignatureAlgorithm asalg = ((SignatureAlgorithm) salg);</b>
<b class="fc">&nbsp;        return asalg.keyPair().build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new {@link Password} instance suitable for use with password-based key derivation algorithms.
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Usage Note&lt;/b&gt;: Using {@code Password}s outside of key derivation contexts will likely
&nbsp;     * fail. See the {@link Password} JavaDoc for more, and also note the &lt;b&gt;Password Safety&lt;/b&gt; section below.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Password Safety&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Instances returned by this method use a &lt;em&gt;clone&lt;/em&gt; of the specified {@code password} character array
&nbsp;     * argument - changes to the argument array will NOT be reflected in the returned key, and vice versa.  If you wish
&nbsp;     * to clear a {@code Password} instance to ensure it is no longer usable, call its {@link Password#destroy()}
&nbsp;     * method will clear/overwrite its internal cloned char array. Also note that each subsequent call to
&nbsp;     * {@link Password#toCharArray()} will also return a new clone of the underlying password character array per
&nbsp;     * standard JCE key behavior.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param password the raw password character array to clone for use with password-based key derivation algorithms.
&nbsp;     * @return a new {@link Password} instance that wraps a new clone of the specified {@code password} character array.
&nbsp;     * @see Password#toCharArray()
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static Password password(char[] password) {
<b class="fc">&nbsp;        return invokeStatic(&quot;password&quot;, FOR_PASSWORD_ARG_TYPES, new Object[]{password});</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a {@code SecretKeyBuilder} that produces the specified key, allowing association with a
&nbsp;     * {@link SecretKeyBuilder#provider(Provider) provider} that must be used with the key during cryptographic
&nbsp;     * operations.  For example:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * SecretKey key = Keys.builder(key).provider(mandatoryProvider).build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Cryptographic algorithm implementations can inspect the resulting {@code key} instance and obtain its
&nbsp;     * mandatory {@code Provider} if necessary.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This method is primarily only useful for keys that cannot expose key material, such as PKCS11 or HSM
&nbsp;     * (Hardware Security Module) keys, and require a specific {@code Provider} to be used during cryptographic
&nbsp;     * operations.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param key the secret key to use for cryptographic operations, potentially associated with a configured
&nbsp;     *            {@link Provider}
&nbsp;     * @return a new {@code SecretKeyBuilder} that produces the specified key, potentially associated with any
&nbsp;     * specified provider.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static SecretKeyBuilder builder(SecretKey key) {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;SecretKey cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return invokeStatic(&quot;builder&quot;, SECRET_BUILDER_ARG_TYPES, key);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a {@code PrivateKeyBuilder} that produces the specified key, allowing association with a
&nbsp;     * {@link PrivateKeyBuilder#publicKey(PublicKey) publicKey} to obtain public key data if necessary, or a
&nbsp;     * {@link SecretKeyBuilder#provider(Provider) provider} that must be used with the key during cryptographic
&nbsp;     * operations.  For example:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * PrivateKey key = Keys.builder(privateKey).publicKey(publicKey).provider(mandatoryProvider).build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Cryptographic algorithm implementations can inspect the resulting {@code key} instance and obtain its
&nbsp;     * mandatory {@code Provider} or {@code PublicKey} if necessary.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This method is primarily only useful for keys that cannot expose key material, such as PKCS11 or HSM
&nbsp;     * (Hardware Security Module) keys, and require a specific {@code Provider} or public key data to be used
&nbsp;     * during cryptographic operations.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param key the private key to use for cryptographic operations, potentially associated with a configured
&nbsp;     *            {@link Provider} or {@link PublicKey}.
&nbsp;     * @return a new {@code PrivateKeyBuilder} that produces the specified private key, potentially associated with any
&nbsp;     * specified provider or {@code PublicKey}
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static PrivateKeyBuilder builder(PrivateKey key) {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;PrivateKey cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return invokeStatic(&quot;builder&quot;, PRIVATE_BUILDER_ARG_TYPES, key);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
