


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > HmacAesAeadAlgorithm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.security</a>
</div>

<h1>Coverage Summary for Class: HmacAesAeadAlgorithm (io.jsonwebtoken.impl.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HmacAesAeadAlgorithm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (72/72)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HmacAesAeadAlgorithm$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HmacAesAeadAlgorithm$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (80/80)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2021 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.security;
&nbsp;
&nbsp;import io.jsonwebtoken.impl.io.Streams;
&nbsp;import io.jsonwebtoken.impl.io.TeeOutputStream;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.impl.lang.CheckedFunction;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.security.AeadAlgorithm;
&nbsp;import io.jsonwebtoken.security.AeadRequest;
&nbsp;import io.jsonwebtoken.security.AeadResult;
&nbsp;import io.jsonwebtoken.security.DecryptAeadRequest;
&nbsp;import io.jsonwebtoken.security.SecretKeyBuilder;
&nbsp;import io.jsonwebtoken.security.SecureRequest;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;
&nbsp;import javax.crypto.Cipher;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.crypto.spec.SecretKeySpec;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.SequenceInputStream;
&nbsp;import java.security.MessageDigest;
&nbsp;import java.security.spec.AlgorithmParameterSpec;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;
&nbsp;/**
&nbsp; * @since 0.12.0
&nbsp; */
&nbsp;public class HmacAesAeadAlgorithm extends AesAlgorithm implements AeadAlgorithm {
&nbsp;
&nbsp;    private static final String TRANSFORMATION_STRING = &quot;AES/CBC/PKCS5Padding&quot;;
&nbsp;
&nbsp;    private final DefaultMacAlgorithm SIGALG;
&nbsp;
&nbsp;    private static int digestLength(int keyLength) {
<b class="fc">&nbsp;        return keyLength * 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static String id(int keyLength) {
<b class="fc">&nbsp;        return &quot;A&quot; + keyLength + &quot;CBC-HS&quot; + digestLength(keyLength);</b>
&nbsp;    }
&nbsp;
&nbsp;    public HmacAesAeadAlgorithm(String id, DefaultMacAlgorithm sigAlg) {
<b class="fc">&nbsp;        super(id, TRANSFORMATION_STRING, sigAlg.getKeyBitLength());</b>
<b class="fc">&nbsp;        this.SIGALG = sigAlg;</b>
&nbsp;    }
&nbsp;
&nbsp;    public HmacAesAeadAlgorithm(int keyBitLength) {
<b class="fc">&nbsp;        this(id(keyBitLength), new DefaultMacAlgorithm(id(keyBitLength), &quot;HmacSHA&quot; + digestLength(keyBitLength), keyBitLength));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getKeyBitLength() {
<b class="fc">&nbsp;        return super.getKeyBitLength() * 2;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SecretKeyBuilder key() {
&nbsp;        // The Sun JCE KeyGenerator throws an exception if bitLengths are not standard AES 128, 192 or 256 values.
&nbsp;        // Since the JWA HmacAes algorithms require double that, we use secure-random keys instead:
<b class="fc">&nbsp;        return new RandomSecretKeyBuilder(KEY_ALG_NAME, getKeyBitLength());</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] assertKeyBytes(SecureRequest&lt;?, SecretKey&gt; request) {
<b class="fc">&nbsp;        SecretKey key = Assert.notNull(request.getKey(), &quot;Request key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return validateLength(key, this.keyBitLength * 2, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void encrypt(final AeadRequest req, final AeadResult res) {
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(req, &quot;Request cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.notNull(res, &quot;Result cannot be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        byte[] compositeKeyBytes = assertKeyBytes(req);</b>
<b class="fc">&nbsp;        int halfCount = compositeKeyBytes.length / 2; // https://tools.ietf.org/html/rfc7518#section-5.2</b>
<b class="fc">&nbsp;        byte[] macKeyBytes = Arrays.copyOfRange(compositeKeyBytes, 0, halfCount);</b>
<b class="fc">&nbsp;        byte[] encKeyBytes = Arrays.copyOfRange(compositeKeyBytes, halfCount, compositeKeyBytes.length);</b>
&nbsp;        final SecretKey encryptionKey;
&nbsp;        try {
<b class="fc">&nbsp;            encryptionKey = new SecretKeySpec(encKeyBytes, KEY_ALG_NAME);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Bytes.clear(encKeyBytes);</b>
<b class="fc">&nbsp;            Bytes.clear(compositeKeyBytes);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        final InputStream plaintext = Assert.notNull(req.getPayload(),</b>
&nbsp;                &quot;Request content (plaintext) InputStream cannot be null.&quot;);
<b class="fc">&nbsp;        final OutputStream out = Assert.notNull(res.getOutputStream(), &quot;Result ciphertext OutputStream cannot be null.&quot;);</b>
<b class="fc">&nbsp;        final InputStream aad = req.getAssociatedData(); //can be null if there&#39;s no associated data</b>
<b class="fc">&nbsp;        final byte[] iv = ensureInitializationVector(req);</b>
<b class="fc">&nbsp;        final AlgorithmParameterSpec ivSpec = getIvSpec(iv);</b>
&nbsp;
&nbsp;        // we need the ciphertext bytes for message digest calculation, so we&#39;ll use a TeeOutputStream to
&nbsp;        // aggregate those results while they&#39;re being written to the result output stream
<b class="fc">&nbsp;        final ByteArrayOutputStream copy = new ByteArrayOutputStream(8192);</b>
<b class="fc">&nbsp;        final OutputStream tee = new TeeOutputStream(out, copy);</b>
&nbsp;
<b class="fc">&nbsp;        jca(req).withCipher(new CheckedFunction&lt;Cipher, Object&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Object apply(Cipher cipher) throws Exception {
<b class="fc">&nbsp;                cipher.init(Cipher.ENCRYPT_MODE, encryptionKey, ivSpec);</b>
<b class="fc">&nbsp;                withCipher(cipher, plaintext, tee);</b>
<b class="fc">&nbsp;                return null; // don&#39;t need to return anything</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="fc">&nbsp;        byte[] aadBytes = aad == null ? Bytes.EMPTY : Streams.bytes(aad, &quot;Unable to read AAD bytes.&quot;);</b>
&nbsp;
&nbsp;        byte[] tag;
&nbsp;        try {
<b class="fc">&nbsp;            tag = sign(aadBytes, iv, Streams.of(copy.toByteArray()), macKeyBytes);</b>
<b class="fc">&nbsp;            res.setTag(tag).setIv(iv);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Bytes.clear(macKeyBytes);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private byte[] sign(byte[] aad, byte[] iv, InputStream ciphertext, byte[] macKeyBytes) {
&nbsp;
<b class="fc">&nbsp;        long aadLength = io.jsonwebtoken.lang.Arrays.length(aad);</b>
<b class="fc">&nbsp;        long aadLengthInBits = aadLength * Byte.SIZE;</b>
<b class="fc">&nbsp;        long aadLengthInBitsAsUnsignedInt = aadLengthInBits &amp; 0xffffffffL;</b>
<b class="fc">&nbsp;        byte[] AL = Bytes.toBytes(aadLengthInBitsAsUnsignedInt);</b>
&nbsp;
<b class="fc">&nbsp;        Collection&lt;InputStream&gt; streams = new ArrayList&lt;&gt;(4);</b>
<b class="fc">&nbsp;        if (!Bytes.isEmpty(aad)) { // must come first if it exists</b>
<b class="fc">&nbsp;            streams.add(Streams.of(aad));</b>
&nbsp;        }
<b class="fc">&nbsp;        streams.add(Streams.of(iv));</b>
<b class="fc">&nbsp;        streams.add(ciphertext);</b>
<b class="fc">&nbsp;        streams.add(Streams.of(AL));</b>
<b class="fc">&nbsp;        InputStream in = new SequenceInputStream(Collections.enumeration(streams));</b>
&nbsp;
<b class="fc">&nbsp;        SecretKey key = new SecretKeySpec(macKeyBytes, SIGALG.getJcaName());</b>
<b class="fc">&nbsp;        SecureRequest&lt;InputStream, SecretKey&gt; request =</b>
&nbsp;                new DefaultSecureRequest&lt;&gt;(in, null, null, key);
<b class="fc">&nbsp;        byte[] digest = SIGALG.digest(request);</b>
&nbsp;
&nbsp;        // https://tools.ietf.org/html/rfc7518#section-5.2.2.1 #5 requires truncating the signature
&nbsp;        // to be the same length as the macKey/encKey:
<b class="fc">&nbsp;        return assertTag(Arrays.copyOfRange(digest, 0, macKeyBytes.length));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void decrypt(final DecryptAeadRequest req, final OutputStream plaintext) {
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(req, &quot;Request cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.notNull(plaintext, &quot;Plaintext OutputStream cannot be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        byte[] compositeKeyBytes = assertKeyBytes(req);</b>
<b class="fc">&nbsp;        int halfCount = compositeKeyBytes.length / 2; // https://tools.ietf.org/html/rfc7518#section-5.2</b>
<b class="fc">&nbsp;        byte[] macKeyBytes = Arrays.copyOfRange(compositeKeyBytes, 0, halfCount);</b>
<b class="fc">&nbsp;        byte[] encKeyBytes = Arrays.copyOfRange(compositeKeyBytes, halfCount, compositeKeyBytes.length);</b>
&nbsp;        final SecretKey decryptionKey;
&nbsp;        try {
<b class="fc">&nbsp;            decryptionKey = new SecretKeySpec(encKeyBytes, KEY_ALG_NAME);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Bytes.clear(encKeyBytes);</b>
<b class="fc">&nbsp;            Bytes.clear(compositeKeyBytes);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        InputStream in = Assert.notNull(req.getPayload(),</b>
&nbsp;                &quot;Decryption request content (ciphertext) InputStream cannot be null.&quot;);
<b class="fc">&nbsp;        final InputStream aad = req.getAssociatedData(); // can be null if there&#39;s no associated data</b>
<b class="fc">&nbsp;        final byte[] tag = assertTag(req.getDigest());</b>
<b class="fc">&nbsp;        final byte[] iv = assertDecryptionIv(req);</b>
<b class="fc">&nbsp;        final AlgorithmParameterSpec ivSpec = getIvSpec(iv);</b>
&nbsp;
&nbsp;        // Assert that the aad + iv + ciphertext provided, when signed, equals the tag provided,
&nbsp;        // thereby verifying none of it has been tampered with:
<b class="fc">&nbsp;        byte[] aadBytes = aad == null ? Bytes.EMPTY : Streams.bytes(aad, &quot;Unable to read AAD bytes.&quot;);</b>
&nbsp;        byte[] digest;
&nbsp;        try {
<b class="fc">&nbsp;            digest = sign(aadBytes, iv, in, macKeyBytes);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Bytes.clear(macKeyBytes);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (!MessageDigest.isEqual(digest, tag)) { //constant time comparison to avoid side-channel attacks</b>
<b class="fc">&nbsp;            String msg = &quot;Ciphertext decryption failed: Authentication tag verification failed.&quot;;</b>
<b class="fc">&nbsp;            throw new SignatureException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        Streams.reset(in); // rewind for decryption</b>
&nbsp;
<b class="fc">&nbsp;        final InputStream ciphertext = in;</b>
<b class="fc">&nbsp;        jca(req).withCipher(new CheckedFunction&lt;Cipher, byte[]&gt;() {</b>
&nbsp;            @Override
&nbsp;            public byte[] apply(Cipher cipher) throws Exception {
<b class="fc">&nbsp;                cipher.init(Cipher.DECRYPT_MODE, decryptionKey, ivSpec);</b>
<b class="fc">&nbsp;                withCipher(cipher, ciphertext, plaintext);</b>
<b class="fc">&nbsp;                return Bytes.EMPTY;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
