


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > RsaPrivateJwkFactory</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.security</a>
</div>

<h1>Coverage Summary for Class: RsaPrivateJwkFactory (io.jsonwebtoken.impl.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RsaPrivateJwkFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (79/79)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RsaPrivateJwkFactory$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RsaPrivateJwkFactory$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (86/86)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2021 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.security;
&nbsp;
&nbsp;import io.jsonwebtoken.impl.lang.CheckedFunction;
&nbsp;import io.jsonwebtoken.impl.lang.Parameter;
&nbsp;import io.jsonwebtoken.impl.lang.ParameterReadable;
&nbsp;import io.jsonwebtoken.impl.lang.RequiredParameterReader;
&nbsp;import io.jsonwebtoken.lang.Arrays;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.RsaPrivateJwk;
&nbsp;import io.jsonwebtoken.security.RsaPublicJwk;
&nbsp;import io.jsonwebtoken.security.UnsupportedKeyException;
&nbsp;
&nbsp;import java.math.BigInteger;
&nbsp;import java.security.KeyFactory;
&nbsp;import java.security.PublicKey;
&nbsp;import java.security.interfaces.RSAMultiPrimePrivateCrtKey;
&nbsp;import java.security.interfaces.RSAPrivateCrtKey;
&nbsp;import java.security.interfaces.RSAPrivateKey;
&nbsp;import java.security.interfaces.RSAPublicKey;
&nbsp;import java.security.spec.KeySpec;
&nbsp;import java.security.spec.RSAMultiPrimePrivateCrtKeySpec;
&nbsp;import java.security.spec.RSAOtherPrimeInfo;
&nbsp;import java.security.spec.RSAPrivateCrtKeySpec;
&nbsp;import java.security.spec.RSAPrivateKeySpec;
&nbsp;import java.security.spec.RSAPublicKeySpec;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;class RsaPrivateJwkFactory extends AbstractFamilyJwkFactory&lt;RSAPrivateKey, RsaPrivateJwk&gt; {
&nbsp;
&nbsp;    //All RSA Private params _except_ for PRIVATE_EXPONENT.  That is always required:
<b class="fc">&nbsp;    private static final Set&lt;Parameter&lt;BigInteger&gt;&gt; OPTIONAL_PRIVATE_PARAMS = Collections.setOf(</b>
&nbsp;            DefaultRsaPrivateJwk.FIRST_PRIME, DefaultRsaPrivateJwk.SECOND_PRIME,
&nbsp;            DefaultRsaPrivateJwk.FIRST_CRT_EXPONENT, DefaultRsaPrivateJwk.SECOND_CRT_EXPONENT,
&nbsp;            DefaultRsaPrivateJwk.FIRST_CRT_COEFFICIENT
&nbsp;    );
&nbsp;
<b class="fc">&nbsp;    private static final String PUBKEY_ERR_MSG = &quot;JwkContext publicKey must be an &quot; + RSAPublicKey.class.getName() + &quot; instance.&quot;;</b>
<b class="fc">&nbsp;    private static final String PUB_EXPONENT_EX_MSG =</b>
&nbsp;            &quot;Unable to derive RSAPublicKey from RSAPrivateKey [%s]. Supported keys implement the &quot; +
<b class="fc">&nbsp;                    RSAPrivateCrtKey.class.getName() + &quot; or &quot; + RSAMultiPrimePrivateCrtKey.class.getName() +</b>
&nbsp;                    &quot; interfaces.  If the specified RSAPrivateKey cannot be one of these two, you must explicitly &quot; +
&nbsp;                    &quot;provide an RSAPublicKey in addition to the RSAPrivateKey, as the &quot; +
&nbsp;                    &quot;[JWA RFC, Section 6.3.2](https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2) &quot; +
&nbsp;                    &quot;requires public values to be present in private RSA JWKs.&quot;;
&nbsp;
&nbsp;    RsaPrivateJwkFactory() {
<b class="fc">&nbsp;        super(DefaultRsaPublicJwk.TYPE_VALUE, RSAPrivateKey.class, DefaultRsaPrivateJwk.PARAMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected boolean supportsKeyValues(JwkContext&lt;?&gt; ctx) {
<b class="fc">&nbsp;        return super.supportsKeyValues(ctx) &amp;&amp; ctx.containsKey(DefaultRsaPrivateJwk.PRIVATE_EXPONENT.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static BigInteger getPublicExponent(RSAPrivateKey key) {
<b class="fc">&nbsp;        if (key instanceof RSAPrivateCrtKey) {</b>
<b class="fc">&nbsp;            return ((RSAPrivateCrtKey) key).getPublicExponent();</b>
<b class="fc">&nbsp;        } else if (key instanceof RSAMultiPrimePrivateCrtKey) {</b>
<b class="fc">&nbsp;            return ((RSAMultiPrimePrivateCrtKey) key).getPublicExponent();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        String msg = String.format(PUB_EXPONENT_EX_MSG, KeysBridge.toString(key));</b>
<b class="fc">&nbsp;        throw new UnsupportedKeyException(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private RSAPublicKey derivePublic(final JwkContext&lt;RSAPrivateKey&gt; ctx) {
<b class="fc">&nbsp;        RSAPrivateKey key = ctx.getKey();</b>
<b class="fc">&nbsp;        BigInteger modulus = key.getModulus();</b>
<b class="fc">&nbsp;        BigInteger publicExponent = getPublicExponent(key);</b>
<b class="fc">&nbsp;        final RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, publicExponent);</b>
<b class="fc">&nbsp;        return generateKey(ctx, RSAPublicKey.class, new CheckedFunction&lt;KeyFactory, RSAPublicKey&gt;() {</b>
&nbsp;            @Override
&nbsp;            public RSAPublicKey apply(KeyFactory kf) {
&nbsp;                try {
<b class="fc">&nbsp;                    return (RSAPublicKey) kf.generatePublic(spec);</b>
<b class="fc">&nbsp;                } catch (Exception e) {</b>
<b class="fc">&nbsp;                    String msg = &quot;Unable to derive RSAPublicKey from RSAPrivateKey &quot; + ctx + &quot;. Cause: &quot; + e.getMessage();</b>
<b class="fc">&nbsp;                    throw new InvalidKeyException(msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected RsaPrivateJwk createJwkFromKey(JwkContext&lt;RSAPrivateKey&gt; ctx) {
&nbsp;
<b class="fc">&nbsp;        RSAPrivateKey key = ctx.getKey();</b>
&nbsp;        RSAPublicKey rsaPublicKey;
&nbsp;
<b class="fc">&nbsp;        PublicKey publicKey = ctx.getPublicKey();</b>
<b class="fc">&nbsp;        if (publicKey != null) {</b>
<b class="fc">&nbsp;            rsaPublicKey = Assert.isInstanceOf(RSAPublicKey.class, publicKey, PUBKEY_ERR_MSG);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            rsaPublicKey = derivePublic(ctx);</b>
&nbsp;        }
&nbsp;
&nbsp;        // The [JWA Spec](https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.1)
&nbsp;        // requires public values to be present in private JWKs, so add them:
&nbsp;
&nbsp;        // If a JWK fingerprint has been requested to be the JWK id, ensure we copy over the one computed for the
&nbsp;        // public key per https://www.rfc-editor.org/rfc/rfc7638#section-3.2.1
<b class="fc">&nbsp;        boolean copyId = !Strings.hasText(ctx.getId()) &amp;&amp; ctx.getIdThumbprintAlgorithm() != null;</b>
&nbsp;
<b class="fc">&nbsp;        JwkContext&lt;RSAPublicKey&gt; pubCtx = RsaPublicJwkFactory.INSTANCE.newContext(ctx, rsaPublicKey);</b>
<b class="fc">&nbsp;        RsaPublicJwk pubJwk = RsaPublicJwkFactory.INSTANCE.createJwk(pubCtx);</b>
<b class="fc">&nbsp;        ctx.putAll(pubJwk); // add public values to private key context</b>
<b class="fc">&nbsp;        if (copyId) {</b>
<b class="fc">&nbsp;            ctx.setId(pubJwk.getId());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        put(ctx, DefaultRsaPrivateJwk.PRIVATE_EXPONENT, key.getPrivateExponent());</b>
&nbsp;
<b class="fc">&nbsp;        if (key instanceof RSAPrivateCrtKey) {</b>
<b class="fc">&nbsp;            RSAPrivateCrtKey ckey = (RSAPrivateCrtKey) key;</b>
&nbsp;            //noinspection DuplicatedCode
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_PRIME, ckey.getPrimeP());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.SECOND_PRIME, ckey.getPrimeQ());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_CRT_EXPONENT, ckey.getPrimeExponentP());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.SECOND_CRT_EXPONENT, ckey.getPrimeExponentQ());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_CRT_COEFFICIENT, ckey.getCrtCoefficient());</b>
<b class="fc">&nbsp;        } else if (key instanceof RSAMultiPrimePrivateCrtKey) {</b>
<b class="fc">&nbsp;            RSAMultiPrimePrivateCrtKey ckey = (RSAMultiPrimePrivateCrtKey) key;</b>
&nbsp;            //noinspection DuplicatedCode
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_PRIME, ckey.getPrimeP());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.SECOND_PRIME, ckey.getPrimeQ());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_CRT_EXPONENT, ckey.getPrimeExponentP());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.SECOND_CRT_EXPONENT, ckey.getPrimeExponentQ());</b>
<b class="fc">&nbsp;            put(ctx, DefaultRsaPrivateJwk.FIRST_CRT_COEFFICIENT, ckey.getCrtCoefficient());</b>
<b class="fc">&nbsp;            List&lt;RSAOtherPrimeInfo&gt; infos = Arrays.asList(ckey.getOtherPrimeInfo());</b>
<b class="fc">&nbsp;            if (!Collections.isEmpty(infos)) {</b>
<b class="fc">&nbsp;                put(ctx, DefaultRsaPrivateJwk.OTHER_PRIMES_INFO, infos);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return new DefaultRsaPrivateJwk(ctx, pubJwk);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected RsaPrivateJwk createJwkFromValues(JwkContext&lt;RSAPrivateKey&gt; ctx) {
&nbsp;
<b class="fc">&nbsp;        final ParameterReadable reader = new RequiredParameterReader(ctx);</b>
&nbsp;
<b class="fc">&nbsp;        final BigInteger privateExponent = reader.get(DefaultRsaPrivateJwk.PRIVATE_EXPONENT);</b>
&nbsp;
&nbsp;        //The [JWA Spec, Section 6.3.2](https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2) requires
&nbsp;        //RSA Private Keys to also encode the public key values, so we assert that we can acquire it successfully:
<b class="fc">&nbsp;        JwkContext&lt;RSAPublicKey&gt; pubCtx = new DefaultJwkContext&lt;&gt;(DefaultRsaPublicJwk.PARAMS, ctx);</b>
<b class="fc">&nbsp;        RsaPublicJwk pubJwk = RsaPublicJwkFactory.INSTANCE.createJwkFromValues(pubCtx);</b>
<b class="fc">&nbsp;        RSAPublicKey pubKey = pubJwk.toKey();</b>
<b class="fc">&nbsp;        final BigInteger modulus = pubKey.getModulus();</b>
<b class="fc">&nbsp;        final BigInteger publicExponent = pubKey.getPublicExponent();</b>
&nbsp;
&nbsp;        // JWA Section 6.3.2 also indicates that if any of the optional private names are present, then *all* of those
&nbsp;        // optional values must be present (except &#39;oth&#39;, which is handled separately next).  Quote:
&nbsp;        //
&nbsp;        //     If the producer includes any of the other private key parameters, then all of the others MUST
&nbsp;        //     be present, with the exception of &quot;oth&quot;, which MUST only be present when more than two prime
&nbsp;        //     factors were used
&nbsp;        //
<b class="fc">&nbsp;        boolean containsOptional = false;</b>
<b class="fc">&nbsp;        for (Parameter&lt;?&gt; param : OPTIONAL_PRIVATE_PARAMS) {</b>
<b class="fc">&nbsp;            if (ctx.containsKey(param.getId())) {</b>
<b class="fc">&nbsp;                containsOptional = true;</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        KeySpec spec;
&nbsp;
<b class="fc">&nbsp;        if (containsOptional) { //if any one optional parameter exists, they are all required per JWA Section 6.3.2:</b>
<b class="fc">&nbsp;            BigInteger firstPrime = reader.get(DefaultRsaPrivateJwk.FIRST_PRIME);</b>
<b class="fc">&nbsp;            BigInteger secondPrime = reader.get(DefaultRsaPrivateJwk.SECOND_PRIME);</b>
<b class="fc">&nbsp;            BigInteger firstCrtExponent = reader.get(DefaultRsaPrivateJwk.FIRST_CRT_EXPONENT);</b>
<b class="fc">&nbsp;            BigInteger secondCrtExponent = reader.get(DefaultRsaPrivateJwk.SECOND_CRT_EXPONENT);</b>
<b class="fc">&nbsp;            BigInteger firstCrtCoefficient = reader.get(DefaultRsaPrivateJwk.FIRST_CRT_COEFFICIENT);</b>
&nbsp;
&nbsp;            // Other Primes Info is actually optional even if the above ones are required:
<b class="fc">&nbsp;            if (ctx.containsKey(DefaultRsaPrivateJwk.OTHER_PRIMES_INFO.getId())) {</b>
<b class="fc">&nbsp;                List&lt;RSAOtherPrimeInfo&gt; otherPrimes = reader.get(DefaultRsaPrivateJwk.OTHER_PRIMES_INFO);</b>
<b class="fc">&nbsp;                RSAOtherPrimeInfo[] arr = new RSAOtherPrimeInfo[Collections.size(otherPrimes)];</b>
<b class="fc">&nbsp;                arr = otherPrimes.toArray(arr);</b>
<b class="fc">&nbsp;                spec = new RSAMultiPrimePrivateCrtKeySpec(modulus, publicExponent, privateExponent, firstPrime,</b>
&nbsp;                        secondPrime, firstCrtExponent, secondCrtExponent, firstCrtCoefficient, arr);
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, firstPrime, secondPrime,</b>
&nbsp;                        firstCrtExponent, secondCrtExponent, firstCrtCoefficient);
&nbsp;            }
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            spec = new RSAPrivateKeySpec(modulus, privateExponent);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        RSAPrivateKey key = generateFromSpec(ctx, spec);</b>
<b class="fc">&nbsp;        ctx.setKey(key);</b>
&nbsp;
<b class="fc">&nbsp;        return new DefaultRsaPrivateJwk(ctx, pubJwk);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected RSAPrivateKey generateFromSpec(JwkContext&lt;RSAPrivateKey&gt; ctx, final KeySpec keySpec) {
<b class="fc">&nbsp;        return generateKey(ctx, new CheckedFunction&lt;KeyFactory, RSAPrivateKey&gt;() {</b>
&nbsp;            @Override
&nbsp;            public RSAPrivateKey apply(KeyFactory kf) throws Exception {
<b class="fc">&nbsp;                return (RSAPrivateKey) kf.generatePrivate(keySpec);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
