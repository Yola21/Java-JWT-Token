


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AesAlgorithm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.security</a>
</div>

<h1>Coverage Summary for Class: AesAlgorithm (io.jsonwebtoken.impl.security)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AesAlgorithm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.2%
  </span>
  <span class="absValue">
    (35/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (68/69)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2021 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.security;
&nbsp;
&nbsp;import io.jsonwebtoken.impl.io.Streams;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.lang.Arrays;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.security.IvSupplier;
&nbsp;import io.jsonwebtoken.security.KeyBuilderSupplier;
&nbsp;import io.jsonwebtoken.security.KeyLengthSupplier;
&nbsp;import io.jsonwebtoken.security.Request;
&nbsp;import io.jsonwebtoken.security.SecretKeyBuilder;
&nbsp;import io.jsonwebtoken.security.WeakKeyException;
&nbsp;
&nbsp;import javax.crypto.Cipher;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.crypto.spec.GCMParameterSpec;
&nbsp;import javax.crypto.spec.IvParameterSpec;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.security.spec.AlgorithmParameterSpec;
&nbsp;
&nbsp;/**
&nbsp; * @since 0.12.0
&nbsp; */
&nbsp;abstract class AesAlgorithm extends CryptoAlgorithm implements KeyBuilderSupplier&lt;SecretKey, SecretKeyBuilder&gt;, KeyLengthSupplier {
&nbsp;
&nbsp;    protected static final String KEY_ALG_NAME = &quot;AES&quot;;
&nbsp;    protected static final int BLOCK_SIZE = 128;
&nbsp;    protected static final int BLOCK_BYTE_SIZE = BLOCK_SIZE / Byte.SIZE;
&nbsp;    protected static final int GCM_IV_SIZE = 96; // https://tools.ietf.org/html/rfc7518#section-5.3
&nbsp;    //protected static final int GCM_IV_BYTE_SIZE = GCM_IV_SIZE / Byte.SIZE;
&nbsp;    protected static final String DECRYPT_NO_IV = &quot;This algorithm implementation rejects decryption &quot; +
&nbsp;            &quot;requests that do not include initialization vectors. AES ciphertext without an IV is weak and &quot; +
&nbsp;            &quot;susceptible to attack.&quot;;
&nbsp;
&nbsp;    protected final int keyBitLength;
&nbsp;    protected final int ivBitLength;
&nbsp;    protected final int tagBitLength;
&nbsp;    protected final boolean gcm;
&nbsp;
&nbsp;    AesAlgorithm(String id, final String jcaTransformation, int keyBitLength) {
<b class="fc">&nbsp;        super(id, jcaTransformation);</b>
<b class="fc">&nbsp;        Assert.isTrue(keyBitLength == 128 || keyBitLength == 192 || keyBitLength == 256, &quot;Invalid AES key length: it must equal 128, 192, or 256.&quot;);</b>
<b class="fc">&nbsp;        this.keyBitLength = keyBitLength;</b>
<b class="fc">&nbsp;        this.gcm = jcaTransformation.startsWith(&quot;AES/GCM&quot;);</b>
<b class="fc">&nbsp;        this.ivBitLength = jcaTransformation.equals(&quot;AESWrap&quot;) ? 0 : (this.gcm ? GCM_IV_SIZE : BLOCK_SIZE);</b>
&nbsp;        // https://tools.ietf.org/html/rfc7518#section-5.2.3 through https://tools.ietf.org/html/rfc7518#section-5.3 :
<b class="fc">&nbsp;        this.tagBitLength = this.gcm ? BLOCK_SIZE : this.keyBitLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getKeyBitLength() {
<b class="fc">&nbsp;        return this.keyBitLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SecretKeyBuilder key() {
<b class="fc">&nbsp;        return new DefaultSecretKeyBuilder(KEY_ALG_NAME, getKeyBitLength());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected SecretKey assertKey(SecretKey key) {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Request key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        validateLengthIfPossible(key);</b>
<b class="fc">&nbsp;        return key;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void validateLengthIfPossible(SecretKey key) {
<b class="fc">&nbsp;        validateLength(key, this.keyBitLength, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected static String lengthMsg(String id, String type, int requiredLengthInBits, long actualLengthInBits) {
<b class="fc">&nbsp;        return &quot;The &#39;&quot; + id + &quot;&#39; algorithm requires &quot; + type + &quot; with a length of &quot; +</b>
<b class="fc">&nbsp;                Bytes.bitsMsg(requiredLengthInBits) + &quot;.  The provided key has a length of &quot; +</b>
<b class="fc">&nbsp;                Bytes.bitsMsg(actualLengthInBits) + &quot;.&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] validateLength(SecretKey key, int requiredBitLength, boolean propagate) {
&nbsp;        byte[] keyBytes;
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            keyBytes = key.getEncoded();</b>
<b class="fc">&nbsp;        } catch (RuntimeException re) {</b>
<b class="fc">&nbsp;            if (propagate) {</b>
<b class="fc">&nbsp;                throw re;</b>
&nbsp;            }
&nbsp;            //can&#39;t get the bytes to validate, e.g. hardware security module or later Android, so just return:
<b class="fc">&nbsp;            return null;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        long keyBitLength = Bytes.bitLength(keyBytes);</b>
<b class="fc">&nbsp;        if (keyBitLength &lt; requiredBitLength) {</b>
<b class="fc">&nbsp;            throw new WeakKeyException(lengthMsg(getId(), &quot;keys&quot;, requiredBitLength, keyBitLength));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return keyBytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] assertBytes(byte[] bytes, String type, int requiredBitLen) {
<b class="fc">&nbsp;        long bitLen = Bytes.bitLength(bytes);</b>
<b class="fc">&nbsp;        if (requiredBitLen != bitLen) {</b>
<b class="fc">&nbsp;            String msg = lengthMsg(getId(), type, requiredBitLen, bitLen);</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] assertIvLength(final byte[] iv) {
<b class="fc">&nbsp;        return assertBytes(iv, &quot;initialization vectors&quot;, this.ivBitLength);</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] assertTag(byte[] tag) {
<b class="fc">&nbsp;        return assertBytes(tag, &quot;authentication tags&quot;, this.tagBitLength);</b>
&nbsp;    }
&nbsp;
&nbsp;    byte[] assertDecryptionIv(IvSupplier src) throws IllegalArgumentException {
<b class="fc">&nbsp;        byte[] iv = src.getIv();</b>
<b class="fc">&nbsp;        Assert.notEmpty(iv, DECRYPT_NO_IV);</b>
<b class="fc">&nbsp;        return assertIvLength(iv);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] ensureInitializationVector(Request&lt;?&gt; request) {
<b class="fc">&nbsp;        byte[] iv = null;</b>
<b class="fc">&nbsp;        if (request instanceof IvSupplier) {</b>
<b class="fc">&nbsp;            iv = Arrays.clean(((IvSupplier) request).getIv());</b>
&nbsp;        }
<b class="fc">&nbsp;        int ivByteLength = this.ivBitLength / Byte.SIZE;</b>
<b class="pc">&nbsp;        if (iv == null || iv.length == 0) {</b>
<b class="fc">&nbsp;            iv = new byte[ivByteLength];</b>
<b class="fc">&nbsp;            SecureRandom random = ensureSecureRandom(request);</b>
<b class="fc">&nbsp;            random.nextBytes(iv);</b>
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            assertIvLength(iv);</b>
&nbsp;        }
<b class="fc">&nbsp;        return iv;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected AlgorithmParameterSpec getIvSpec(byte[] iv) {
<b class="fc">&nbsp;        Assert.notEmpty(iv, &quot;Initialization Vector byte array cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        return this.gcm ? new GCMParameterSpec(BLOCK_SIZE, iv) : new IvParameterSpec(iv);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void withCipher(Cipher cipher, InputStream in, OutputStream out) throws Exception {
<b class="fc">&nbsp;        byte[] last = withCipher(cipher, in, null, out);</b>
<b class="fc">&nbsp;        out.write(last); // no AAD, so no tag, so we can just append</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateAAD(Cipher cipher, InputStream aad) throws Exception {
<b class="fc">&nbsp;        if (aad == null) return;</b>
<b class="fc">&nbsp;        byte[] buf = new byte[2048];</b>
<b class="fc">&nbsp;        int len = 0;</b>
<b class="fc">&nbsp;        while (len != -1) {</b>
<b class="fc">&nbsp;            len = aad.read(buf);</b>
<b class="fc">&nbsp;            if (len &gt; 0) {</b>
<b class="fc">&nbsp;                cipher.updateAAD(buf, 0, len);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] withCipher(Cipher cipher, InputStream in, InputStream aad, OutputStream out) throws Exception {
<b class="fc">&nbsp;        updateAAD(cipher, aad); // no-op if aad is null</b>
<b class="fc">&nbsp;        byte[] buf = new byte[2048];</b>
&nbsp;        try {
<b class="fc">&nbsp;            int len = 0;</b>
<b class="fc">&nbsp;            while (len != -1) {</b>
<b class="fc">&nbsp;                len = in.read(buf);</b>
<b class="fc">&nbsp;                if (len &gt; 0) {</b>
<b class="fc">&nbsp;                    byte[] enc = cipher.update(buf, 0, len);</b>
<b class="fc">&nbsp;                    Streams.write(out, enc, &quot;Unable to write Cipher output to OutputStream&quot;);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return cipher.doFinal();</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Bytes.clear(buf);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
