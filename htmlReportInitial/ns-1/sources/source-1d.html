


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > JwtParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken</a>
</div>

<h1>Coverage Summary for Class: JwtParser (io.jsonwebtoken)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
</tr>
  <tr>
    <td class="name">JwtParser$isSigned$3</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parse$1</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parse$13</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseClaimsJws$12</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseClaimsJwt$10</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseContentJws$11</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseContentJwt$9</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseEncryptedClaims$5</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseEncryptedContent$8</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseSignedClaims</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseSignedClaims$0</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseSignedClaims$6</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseSignedContent$4</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseSignedContent$7</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseUnsecuredClaims</td>
  </tr>
  <tr>
    <td class="name">JwtParser$parseUnsecuredContent$2</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken;
&nbsp;
&nbsp;import io.jsonwebtoken.io.Parser;
&nbsp;import io.jsonwebtoken.security.SecurityException;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;
&nbsp;import java.io.InputStream;
&nbsp;
&nbsp;/**
&nbsp; * A parser for reading JWT strings, used to convert them into a {@link Jwt} object representing the expanded JWT.
&nbsp; * A parser for reading JWT strings, used to convert them into a {@link Jwt} object representing the expanded JWT.
&nbsp; *
&nbsp; * @since 0.1
&nbsp; */
&nbsp;public interface JwtParser extends Parser&lt;Jwt&lt;?, ?&gt;&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the specified JWT compact string represents a signed JWT (aka a &#39;JWS&#39;), {@code false}
&nbsp;     * otherwise.
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that if you are reasonably sure that the token is signed, it is more efficient to attempt to
&nbsp;     * parse the token (and catching exceptions if necessary) instead of calling this method first before parsing.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param compact the compact serialized JWT to check
&nbsp;     * @return {@code true} if the specified JWT compact string represents a signed JWT (aka a &#39;JWS&#39;), {@code false}
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    boolean isSigned(CharSequence compact);
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the specified compact serialized JWT string based on the builder&#39;s current configuration state and
&nbsp;     * returns the resulting JWT, JWS, or JWE instance.
&nbsp;     *
&nbsp;     * &lt;p&gt;Because it is often cumbersome to determine if the result is a JWT, JWS or JWE, or if the payload is a Claims
&nbsp;     * or {@code byte[]} array with {@code instanceof} checks, it may be useful to call the result&#39;s
&nbsp;     * {@link Jwt#accept(JwtVisitor) accept(JwtVisitor)} method for a type-safe callback approach instead of using if-then-else
&nbsp;     * {@code instanceof} conditionals. For example, instead of:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * // NOT RECOMMENDED:
&nbsp;     * Jwt&amp;lt;?,?&amp;gt; jwt = parser.parse(input);
&nbsp;     * if (jwt instanceof Jwe&amp;lt;?&amp;gt;) {
&nbsp;     *     Jwe&amp;lt;?&amp;gt; jwe = (Jwe&amp;lt;?&amp;gt;)jwt;
&nbsp;     *     if (jwe.getPayload() instanceof Claims) {
&nbsp;     *         Jwe&amp;lt;Claims&amp;gt; claimsJwe = (Jwe&amp;lt;Claims&amp;gt;)jwe;
&nbsp;     *         // do something with claimsJwe
&nbsp;     *     }
&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;the following alternative is usually preferred:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwe&amp;lt;Claims&amp;gt; jwe = parser.parse(input).accept({@link Jwe#CLAIMS});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jwt the compact serialized JWT to parse
&nbsp;     * @return the parsed JWT instance
&nbsp;     * @throws MalformedJwtException    if the specified JWT was incorrectly constructed (and therefore invalid).
&nbsp;     *                                  Invalid JWTs should not be trusted and should be discarded.
&nbsp;     * @throws SignatureException       if a JWS signature was discovered, but could not be verified.  JWTs that fail
&nbsp;     *                                  signature validation should not be trusted and should be discarded.
&nbsp;     * @throws SecurityException        if the specified JWT string is a JWE and decryption fails
&nbsp;     * @throws ExpiredJwtException      if the specified JWT is a Claims JWT and the Claims has an expiration time
&nbsp;     *                                  before the time this method is invoked.
&nbsp;     * @throws IllegalArgumentException if the specified string is {@code null} or empty or only whitespace.
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     */
&nbsp;    Jwt&lt;?, ?&gt; parse(CharSequence jwt) throws ExpiredJwtException, MalformedJwtException, SignatureException,
&nbsp;            SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deprecated since 0.12.0 in favor of calling any {@code parse*} method immediately
&nbsp;     * followed by invoking the parsed JWT&#39;s {@link Jwt#accept(JwtVisitor) accept} method with your preferred visitor. For
&nbsp;     * example:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jwt).{@link Jwt#accept(JwtVisitor) accept}({@link JwtVisitor visitor});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This method will be removed before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jwt     the compact serialized JWT to parse
&nbsp;     * @param handler the handler to invoke when encountering a specific type of JWT
&nbsp;     * @param &lt;T&gt;     the type of object returned from the {@code handler}
&nbsp;     * @return the result returned by the {@code JwtHandler}
&nbsp;     * @throws MalformedJwtException    if the specified JWT was incorrectly constructed (and therefore invalid).
&nbsp;     *                                  Invalid JWTs should not be trusted and should be discarded.
&nbsp;     * @throws SignatureException       if a JWS signature was discovered, but could not be verified.  JWTs that fail
&nbsp;     *                                  signature validation should not be trusted and should be discarded.
&nbsp;     * @throws SecurityException        if the specified JWT string is a JWE and decryption fails
&nbsp;     * @throws ExpiredJwtException      if the specified JWT is a Claims JWT and the Claims has an expiration time
&nbsp;     *                                  before the time this method is invoked.
&nbsp;     * @throws IllegalArgumentException if the specified string is {@code null} or empty or only whitespace, or if the
&nbsp;     *                                  {@code handler} is {@code null}.
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.2
&nbsp;     * @deprecated since 0.12.0 in favor of
&nbsp;     * &lt;code&gt;{@link #parse(CharSequence)}.{@link Jwt#accept(JwtVisitor) accept}({@link JwtVisitor visitor});&lt;/code&gt;
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    &lt;T&gt; T parse(CharSequence jwt, JwtHandler&lt;T&gt; handler) throws ExpiredJwtException, UnsupportedJwtException,
&nbsp;            MalformedJwtException, SignatureException, SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deprecated since 0.12.0 in favor of {@link #parseUnsecuredContent(CharSequence)}.
&nbsp;     *
&nbsp;     * &lt;p&gt;This method will be removed before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jwt a compact serialized unsecured content JWT string.
&nbsp;     * @return the {@link Jwt Jwt} instance that reflects the specified compact JWT string.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwt} argument does not represent an unsecured content JWT
&nbsp;     * @throws MalformedJwtException    if the {@code jwt} string is not a valid JWT
&nbsp;     * @throws SignatureException       if the {@code jwt} string is actually a JWS and signature validation fails
&nbsp;     * @throws SecurityException        if the {@code jwt} string is actually a JWE and decryption fails
&nbsp;     * @throws IllegalArgumentException if the {@code jwt} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parseUnsecuredContent(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.2
&nbsp;     * @deprecated since 0.12.0 in favor of {@link #parseUnsecuredContent(CharSequence)}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    Jwt&lt;Header, byte[]&gt; parseContentJwt(CharSequence jwt) throws UnsupportedJwtException, MalformedJwtException,
&nbsp;            SignatureException, SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deprecated since 0.12.0 in favor of {@link #parseUnsecuredClaims(CharSequence)}.
&nbsp;     *
&nbsp;     * &lt;p&gt;This method will be removed before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jwt a compact serialized unsecured Claims JWT string.
&nbsp;     * @return the {@link Jwt Jwt} instance that reflects the specified compact JWT string.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwt} argument does not represent an unsecured Claims JWT
&nbsp;     * @throws MalformedJwtException    if the {@code jwt} string is not a valid JWT
&nbsp;     * @throws SignatureException       if the {@code jwt} string is actually a JWS and signature validation fails
&nbsp;     * @throws SecurityException        if the {@code jwt} string is actually a JWE and decryption fails
&nbsp;     * @throws IllegalArgumentException if the {@code jwt} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parseUnsecuredClaims(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.2
&nbsp;     * @deprecated since 0.12.0 in favor of {@link #parseUnsecuredClaims(CharSequence)}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    Jwt&lt;Header, Claims&gt; parseClaimsJwt(CharSequence jwt) throws ExpiredJwtException, UnsupportedJwtException,
&nbsp;            MalformedJwtException, SignatureException, SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deprecated since 0.12.0 in favor of {@link #parseSignedContent(CharSequence)}.
&nbsp;     *
&nbsp;     * &lt;p&gt;This method will be removed before the 1.0 release.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jws a compact content JWS string
&nbsp;     * @return the parsed and validated content JWS
&nbsp;     * @throws UnsupportedJwtException  if the {@code jws} argument does not represent a content JWS
&nbsp;     * @throws MalformedJwtException    if the {@code jws} string is not a valid JWS
&nbsp;     * @throws SignatureException       if the {@code jws} JWS signature validation fails
&nbsp;     * @throws SecurityException        if the {@code jws} string is actually a JWE and decryption fails
&nbsp;     * @throws IllegalArgumentException if the {@code jws} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parseSignedContent(CharSequence)
&nbsp;     * @see #parseEncryptedContent(CharSequence)
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @since 0.2
&nbsp;     * @deprecated since 0.12.0 in favor of {@link #parseSignedContent(CharSequence)}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    Jws&lt;byte[]&gt; parseContentJws(CharSequence jws) throws UnsupportedJwtException, MalformedJwtException, SignatureException,
&nbsp;            SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deprecated since 0.12.0 in favor of {@link #parseSignedClaims(CharSequence)}.
&nbsp;     *
&nbsp;     * @param jws a compact Claims JWS string.
&nbsp;     * @return the parsed and validated Claims JWS
&nbsp;     * @throws UnsupportedJwtException  if the {@code claimsJws} argument does not represent an Claims JWS
&nbsp;     * @throws MalformedJwtException    if the {@code claimsJws} string is not a valid JWS
&nbsp;     * @throws SignatureException       if the {@code claimsJws} JWS signature validation fails
&nbsp;     * @throws SecurityException        if the {@code jws} string is actually a JWE and decryption fails
&nbsp;     * @throws ExpiredJwtException      if the specified JWT is a Claims JWT and the Claims has an expiration time
&nbsp;     *                                  before the time this method is invoked.
&nbsp;     * @throws IllegalArgumentException if the {@code claimsJws} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parseSignedClaims(CharSequence)
&nbsp;     * @see #parseEncryptedClaims(CharSequence)
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @since 0.2
&nbsp;     * @deprecated since 0.12.0 in favor of {@link #parseSignedClaims(CharSequence)}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    Jws&lt;Claims&gt; parseClaimsJws(CharSequence jws) throws ExpiredJwtException, UnsupportedJwtException, MalformedJwtException,
&nbsp;            SignatureException, SecurityException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jwt} argument, expected to be an unsecured content JWT. If the JWT creator set
&nbsp;     * the (optional) {@link Header#getContentType() contentType} header value, the application may inspect that
&nbsp;     * value to determine how to convert the byte array to the final content type as desired.
&nbsp;     *
&nbsp;     * &lt;p&gt;This is a convenience method logically equivalent to the following:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jwt).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jwt#UNSECURED_CONTENT});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jwt a compact unsecured content JWT.
&nbsp;     * @return the parsed unsecured content JWT.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwt} argument does not represent an unsecured content JWT
&nbsp;     * @throws JwtException             if the {@code jwt} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jwt} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jwt&lt;Header, byte[]&gt; parseUnsecuredContent(CharSequence jwt) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jwt} argument, expected to be an unsecured {@code Claims} JWT. This is a
&nbsp;     * convenience method logically equivalent to the following:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jwt).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jwt#UNSECURED_CLAIMS});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jwt a compact unsecured Claims JWT.
&nbsp;     * @return the parsed unsecured Claims JWT.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwt} argument does not represent an unsecured Claims JWT
&nbsp;     * @throws JwtException             if the {@code jwt} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jwt} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jwt&lt;Header, Claims&gt; parseUnsecuredClaims(CharSequence jwt) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jws} argument, expected to be a cryptographically-signed content JWS. If the JWS
&nbsp;     * creator set the (optional) {@link Header#getContentType() contentType} header value, the application may
&nbsp;     * inspect that value to determine how to convert the byte array to the final content type as desired.
&nbsp;     *
&nbsp;     * &lt;p&gt;This is a convenience method logically equivalent to the following:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jws).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jws#CONTENT});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jws a compact cryptographically-signed content JWS.
&nbsp;     * @return the parsed cryptographically-verified content JWS.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jws} argument does not represent a signed content JWS
&nbsp;     * @throws JwtException             if the {@code jws} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jws} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a JWS known to use the
&nbsp;     * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797&quot;&gt;RFC 7797: JSON Web Signature (JWS) Unencoded Payload
&nbsp;     * Option&lt;/a&gt;, using the specified {@code unencodedPayload} for signature verification.
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Unencoded Non-Detached Payload&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that if the JWS contains a valid unencoded Payload string (what RFC 7797 calls an
&nbsp;     * &amp;quot;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797#section-5.2&quot;&gt;unencoded non-detached
&nbsp;     * payload&lt;/a&gt;&amp;quot;, the {@code unencodedPayload} method argument will be ignored, as the JWS already includes
&nbsp;     * the payload content necessary for signature verification.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jws              the Unencoded Payload JWS to parse.
&nbsp;     * @param unencodedPayload the JWS&#39;s associated required unencoded payload used for signature verification.
&nbsp;     * @return the parsed Unencoded Payload.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws, byte[] unencodedPayload);
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a JWS known to use the
&nbsp;     * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797&quot;&gt;RFC 7797: JSON Web Signature (JWS) Unencoded Payload
&nbsp;     * Option&lt;/a&gt;, using the bytes from the specified {@code unencodedPayload} stream for signature verification.
&nbsp;     *
&nbsp;     * &lt;p&gt;Because it is not possible to know how large the {@code unencodedPayload} stream will be, the stream bytes
&nbsp;     * will not be buffered in memory, ensuring the resulting {@link Jws} return value&#39;s {@link Jws#getPayload()}
&nbsp;     * is always empty.  This is generally not a concern since the caller already has access to the stream bytes and
&nbsp;     * may obtain them independently before or after calling this method if they are needed otherwise.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Unencoded Non-Detached Payload&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that if the JWS contains a valid unencoded payload String (what RFC 7797 calls an
&nbsp;     * &amp;quot;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797#section-5.2&quot;&gt;unencoded non-detached
&nbsp;     * payload&lt;/a&gt;&amp;quot;, the {@code unencodedPayload} method argument will be ignored, as the JWS already includes
&nbsp;     * the payload content necessary for signature verification. In this case the resulting {@link Jws} return
&nbsp;     * value&#39;s {@link Jws#getPayload()} will contain the embedded payload String&#39;s UTF-8 bytes.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jws              the Unencoded Payload JWS to parse.
&nbsp;     * @param unencodedPayload the JWS&#39;s associated required unencoded payload used for signature verification.
&nbsp;     * @return the parsed Unencoded Payload.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws, InputStream unencodedPayload);
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jws} argument, expected to be a cryptographically-signed {@code Claims} JWS. This is a
&nbsp;     * convenience method logically equivalent to the following:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jws).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jws#CLAIMS});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jws a compact cryptographically-signed Claims JWS.
&nbsp;     * @return the parsed cryptographically-verified Claims JWS.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwt} argument does not represent a signed Claims JWT
&nbsp;     * @throws JwtException             if the {@code jwt} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jwt} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a JWS known to use the
&nbsp;     * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797&quot;&gt;RFC 7797: JSON Web Signature (JWS) Unencoded Payload
&nbsp;     * Option&lt;/a&gt;, using the specified {@code unencodedPayload} for signature verification.
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Unencoded Non-Detached Payload&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that if the JWS contains a valid unencoded payload String (what RFC 7797 calls an
&nbsp;     * &amp;quot;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797#section-5.2&quot;&gt;unencoded non-detached
&nbsp;     * payload&lt;/a&gt;&amp;quot;, the {@code unencodedPayload} method argument will be ignored, as the JWS already includes
&nbsp;     * the payload content necessary for signature verification and claims creation.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jws              the Unencoded Payload JWS to parse.
&nbsp;     * @param unencodedPayload the JWS&#39;s associated required unencoded payload used for signature verification.
&nbsp;     * @return the parsed and validated Claims JWS.
&nbsp;     * @throws JwtException             if parsing, signature verification, or JWT validation fails.
&nbsp;     * @throws IllegalArgumentException if either the {@code jws} or {@code unencodedPayload} are null or empty.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws, byte[] unencodedPayload) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a JWS known to use the
&nbsp;     * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797&quot;&gt;RFC 7797: JSON Web Signature (JWS) Unencoded Payload
&nbsp;     * Option&lt;/a&gt;, using the bytes from the specified {@code unencodedPayload} stream for signature verification and
&nbsp;     * {@link Claims} creation.
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; however, because calling this method indicates a completed
&nbsp;     * {@link Claims} instance is desired, the specified {@code unencodedPayload} JSON stream will be fully
&nbsp;     * read into a Claims instance.  If this will be problematic for your application (perhaps if you expect extremely
&nbsp;     * large Claims), it is recommended to use the {@link #parseSignedContent(CharSequence, InputStream)} method
&nbsp;     * instead.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;b&gt;Unencoded Non-Detached Payload&lt;/b&gt;&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that if the JWS contains a valid unencoded Payload string (what RFC 7797 calls an
&nbsp;     * &amp;quot;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7797#section-5.2&quot;&gt;unencoded non-detached
&nbsp;     * payload&lt;/a&gt;&amp;quot;, the {@code unencodedPayload} method argument will be ignored, as the JWS already includes
&nbsp;     * the payload content necessary for signature verification and Claims creation.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param jws              the Unencoded Payload JWS to parse.
&nbsp;     * @param unencodedPayload the JWS&#39;s associated required unencoded payload used for signature verification.
&nbsp;     * @return the parsed and validated Claims JWS.
&nbsp;     * @throws JwtException             if parsing, signature verification, or JWT validation fails.
&nbsp;     * @throws IllegalArgumentException if either the {@code jws} or {@code unencodedPayload} are null or empty.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws, InputStream unencodedPayload) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jwe} argument, expected to be an encrypted content JWE. If the JWE
&nbsp;     * creator set the (optional) {@link Header#getContentType() contentType} header value, the application may
&nbsp;     * inspect that value to determine how to convert the byte array to the final content type as desired.
&nbsp;     *
&nbsp;     * &lt;p&gt;This is a convenience method logically equivalent to the following:&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jwe).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jwe#CONTENT});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jwe a compact encrypted content JWE.
&nbsp;     * @return the parsed decrypted content JWE.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwe} argument does not represent an encrypted content JWE
&nbsp;     * @throws JwtException             if the {@code jwe} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jwe} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jwe&lt;byte[]&gt; parseEncryptedContent(CharSequence jwe) throws JwtException, IllegalArgumentException;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the {@code jwe} argument, expected to be an encrypted {@code Claims} JWE. This is a
&nbsp;     * convenience method logically equivalent to the following:
&nbsp;     *
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * {@link #parse(CharSequence) parse}(jwe).{@link Jwt#accept(JwtVisitor) accept}({@link
&nbsp;     * Jwe#CLAIMS});&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     *
&nbsp;     * @param jwe a compact encrypted Claims JWE.
&nbsp;     * @return the parsed decrypted Claims JWE.
&nbsp;     * @throws UnsupportedJwtException  if the {@code jwe} argument does not represent an encrypted Claims JWE.
&nbsp;     * @throws JwtException             if the {@code jwe} string cannot be parsed or validated as required.
&nbsp;     * @throws IllegalArgumentException if the {@code jwe} string is {@code null} or empty or only whitespace
&nbsp;     * @see #parse(CharSequence)
&nbsp;     * @see Jwt#accept(JwtVisitor)
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    Jwe&lt;Claims&gt; parseEncryptedClaims(CharSequence jwe) throws JwtException, IllegalArgumentException;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
