


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SignatureAlgorithm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken</a>
</div>

<h1>Coverage Summary for Class: SignatureAlgorithm (io.jsonwebtoken)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SignatureAlgorithm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (73/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (145/145)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SignatureAlgorithm$assertValidSigningKey$1</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$assertValidVerificationKey$7</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$forName$9</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$forSigningKey$4</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$getDescription$8</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$getFamilyName$6</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$getMinKeyLength$5</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$isEllipticCurve$2</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$isHmac$3</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$isJdkStandard$10</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$isRsa$0</td>
  </tr>
  <tr>
    <td class="name">SignatureAlgorithm$values</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (73/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (145/145)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken;
&nbsp;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.Keys;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;import io.jsonwebtoken.security.WeakKeyException;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.interfaces.ECKey;
&nbsp;import java.security.interfaces.RSAKey;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Type-safe representation of standard JWT signature algorithm names as defined in the
&nbsp; * &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-31&quot;&gt;JSON Web Algorithms&lt;/a&gt; specification.
&nbsp; *
&nbsp; * @since 0.1
&nbsp; * @deprecated since 0.12.0; use {@link Jwts.SIG} instead.
&nbsp; */
<b class="fc">&nbsp;@Deprecated</b>
&nbsp;public enum SignatureAlgorithm {
&nbsp;
&nbsp;    /**
&nbsp;     * JWA name for {@code No digital signature or MAC performed}
&nbsp;     */
<b class="fc">&nbsp;    NONE(&quot;none&quot;, &quot;No digital signature or MAC performed&quot;, &quot;None&quot;, null, false, 0, 0),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code HMAC using SHA-256}
&nbsp;     */
<b class="fc">&nbsp;    HS256(&quot;HS256&quot;, &quot;HMAC using SHA-256&quot;, &quot;HMAC&quot;, &quot;HmacSHA256&quot;, true, 256, 256, &quot;1.2.840.113549.2.9&quot;),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code HMAC using SHA-384}
&nbsp;     */
<b class="fc">&nbsp;    HS384(&quot;HS384&quot;, &quot;HMAC using SHA-384&quot;, &quot;HMAC&quot;, &quot;HmacSHA384&quot;, true, 384, 384, &quot;1.2.840.113549.2.10&quot;),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code HMAC using SHA-512}
&nbsp;     */
<b class="fc">&nbsp;    HS512(&quot;HS512&quot;, &quot;HMAC using SHA-512&quot;, &quot;HMAC&quot;, &quot;HmacSHA512&quot;, true, 512, 512, &quot;1.2.840.113549.2.11&quot;),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PKCS-v1_5 using SHA-256}
&nbsp;     */
<b class="fc">&nbsp;    RS256(&quot;RS256&quot;, &quot;RSASSA-PKCS-v1_5 using SHA-256&quot;, &quot;RSA&quot;, &quot;SHA256withRSA&quot;, true, 256, 2048),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PKCS-v1_5 using SHA-384}
&nbsp;     */
<b class="fc">&nbsp;    RS384(&quot;RS384&quot;, &quot;RSASSA-PKCS-v1_5 using SHA-384&quot;, &quot;RSA&quot;, &quot;SHA384withRSA&quot;, true, 384, 2048),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PKCS-v1_5 using SHA-512}
&nbsp;     */
<b class="fc">&nbsp;    RS512(&quot;RS512&quot;, &quot;RSASSA-PKCS-v1_5 using SHA-512&quot;, &quot;RSA&quot;, &quot;SHA512withRSA&quot;, true, 512, 2048),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code ECDSA using P-256 and SHA-256}
&nbsp;     */
<b class="fc">&nbsp;    ES256(&quot;ES256&quot;, &quot;ECDSA using P-256 and SHA-256&quot;, &quot;ECDSA&quot;, &quot;SHA256withECDSA&quot;, true, 256, 256),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code ECDSA using P-384 and SHA-384}
&nbsp;     */
<b class="fc">&nbsp;    ES384(&quot;ES384&quot;, &quot;ECDSA using P-384 and SHA-384&quot;, &quot;ECDSA&quot;, &quot;SHA384withECDSA&quot;, true, 384, 384),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code ECDSA using P-521 and SHA-512}
&nbsp;     */
<b class="fc">&nbsp;    ES512(&quot;ES512&quot;, &quot;ECDSA using P-521 and SHA-512&quot;, &quot;ECDSA&quot;, &quot;SHA512withECDSA&quot;, true, 512, 521),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PSS using SHA-256 and MGF1 with SHA-256}.  &lt;b&gt;This algorithm requires
&nbsp;     * Java 11 or later or a JCA provider like BouncyCastle to be in the runtime classpath.&lt;/b&gt;  If on Java 10 or
&nbsp;     * earlier, BouncyCastle will be used automatically if found in the runtime classpath.
&nbsp;     */
<b class="fc">&nbsp;    PS256(&quot;PS256&quot;, &quot;RSASSA-PSS using SHA-256 and MGF1 with SHA-256&quot;, &quot;RSA&quot;, &quot;RSASSA-PSS&quot;, false, 256, 2048),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PSS using SHA-384 and MGF1 with SHA-384}.  &lt;b&gt;This algorithm requires
&nbsp;     * Java 11 or later or a JCA provider like BouncyCastle to be in the runtime classpath.&lt;/b&gt;  If on Java 10 or
&nbsp;     * earlier, BouncyCastle will be used automatically if found in the runtime classpath.
&nbsp;     */
<b class="fc">&nbsp;    PS384(&quot;PS384&quot;, &quot;RSASSA-PSS using SHA-384 and MGF1 with SHA-384&quot;, &quot;RSA&quot;, &quot;RSASSA-PSS&quot;, false, 384, 2048),</b>
&nbsp;
&nbsp;    /**
&nbsp;     * JWA algorithm name for {@code RSASSA-PSS using SHA-512 and MGF1 with SHA-512}. &lt;b&gt;This algorithm requires
&nbsp;     * Java 11 or later or a JCA provider like BouncyCastle to be in the runtime classpath.&lt;/b&gt;  If on Java 10 or
&nbsp;     * earlier, BouncyCastle will be used automatically if found in the runtime classpath.
&nbsp;     */
<b class="fc">&nbsp;    PS512(&quot;PS512&quot;, &quot;RSASSA-PSS using SHA-512 and MGF1 with SHA-512&quot;, &quot;RSA&quot;, &quot;RSASSA-PSS&quot;, false, 512, 2048);</b>
&nbsp;
&nbsp;    //purposefully ordered higher to lower:
<b class="fc">&nbsp;    private static final List&lt;SignatureAlgorithm&gt; PREFERRED_HMAC_ALGS = Collections.unmodifiableList(Arrays.asList(</b>
&nbsp;            SignatureAlgorithm.HS512, SignatureAlgorithm.HS384, SignatureAlgorithm.HS256));
&nbsp;    //purposefully ordered higher to lower:
<b class="fc">&nbsp;    private static final List&lt;SignatureAlgorithm&gt; PREFERRED_EC_ALGS = Collections.unmodifiableList(Arrays.asList(</b>
&nbsp;            SignatureAlgorithm.ES512, SignatureAlgorithm.ES384, SignatureAlgorithm.ES256));
&nbsp;
&nbsp;    private final String value;
&nbsp;    private final String description;
&nbsp;    private final String familyName;
&nbsp;    private final String jcaName;
&nbsp;    private final boolean jdkStandard;
&nbsp;    private final int digestLength;
&nbsp;    private final int minKeyLength;
&nbsp;    /**
&nbsp;     * Algorithm name as given by {@link Key#getAlgorithm()} if the key was loaded from a pkcs12 Keystore.
&nbsp;     *
&nbsp;     * @deprecated This is just a workaround for https://bugs.openjdk.java.net/browse/JDK-8243551
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    private final String pkcs12Name;
&nbsp;
&nbsp;    SignatureAlgorithm(String value, String description, String familyName, String jcaName, boolean jdkStandard,
&nbsp;                       int digestLength, int minKeyLength) {
<b class="fc">&nbsp;        this(value, description, familyName, jcaName, jdkStandard, digestLength, minKeyLength, jcaName);</b>
&nbsp;    }
&nbsp;
&nbsp;    SignatureAlgorithm(String value, String description, String familyName, String jcaName, boolean jdkStandard,
<b class="fc">&nbsp;                       int digestLength, int minKeyLength, String pkcs12Name) {</b>
<b class="fc">&nbsp;        this.value = value;</b>
<b class="fc">&nbsp;        this.description = description;</b>
<b class="fc">&nbsp;        this.familyName = familyName;</b>
<b class="fc">&nbsp;        this.jcaName = jcaName;</b>
<b class="fc">&nbsp;        this.jdkStandard = jdkStandard;</b>
<b class="fc">&nbsp;        this.digestLength = digestLength;</b>
<b class="fc">&nbsp;        this.minKeyLength = minKeyLength;</b>
<b class="fc">&nbsp;        this.pkcs12Name = pkcs12Name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the JWA algorithm name constant.
&nbsp;     *
&nbsp;     * @return the JWA algorithm name constant.
&nbsp;     */
&nbsp;    public String getValue() {
<b class="fc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the JWA algorithm description.
&nbsp;     *
&nbsp;     * @return the JWA algorithm description.
&nbsp;     */
&nbsp;    public String getDescription() {
<b class="fc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the cryptographic family name of the signature algorithm.  The value returned is according to the
&nbsp;     * following table:
&nbsp;     *
&nbsp;     * &lt;table&gt;
&nbsp;     * &lt;caption&gt;Crypto Family&lt;/caption&gt;
&nbsp;     * &lt;thead&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;th&gt;SignatureAlgorithm&lt;/th&gt;
&nbsp;     * &lt;th&gt;Family Name&lt;/th&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/thead&gt;
&nbsp;     * &lt;tbody&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;HMAC&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;HMAC&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;HS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;HMAC&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;RS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS256&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS384&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;PS512&lt;/td&gt;
&nbsp;     * &lt;td&gt;RSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES256&lt;/td&gt;
&nbsp;     * &lt;td&gt;ECDSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES384&lt;/td&gt;
&nbsp;     * &lt;td&gt;ECDSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;ES512&lt;/td&gt;
&nbsp;     * &lt;td&gt;ECDSA&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/tbody&gt;
&nbsp;     * &lt;/table&gt;
&nbsp;     *
&nbsp;     * @return Returns the cryptographic family name of the signature algorithm.
&nbsp;     * @since 0.5
&nbsp;     */
&nbsp;    public String getFamilyName() {
<b class="fc">&nbsp;        return familyName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the JCA algorithm used to compute the signature.
&nbsp;     *
&nbsp;     * @return the name of the JCA algorithm used to compute the signature.
&nbsp;     */
&nbsp;    public String getJcaName() {
<b class="fc">&nbsp;        return jcaName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the algorithm is supported by standard JDK distributions or {@code false} if the
&nbsp;     * algorithm implementation is not in the JDK and must be provided by a separate runtime JCA Provider (like
&nbsp;     * BouncyCastle for example).
&nbsp;     *
&nbsp;     * @return {@code true} if the algorithm is supported by standard JDK distributions or {@code false} if the
&nbsp;     * algorithm implementation is not in the JDK and must be provided by a separate runtime JCA Provider (like
&nbsp;     * BouncyCastle for example).
&nbsp;     */
&nbsp;    public boolean isJdkStandard() {
<b class="fc">&nbsp;        return jdkStandard;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the enum instance represents an HMAC signature algorithm, {@code false} otherwise.
&nbsp;     *
&nbsp;     * @return {@code true} if the enum instance represents an HMAC signature algorithm, {@code false} otherwise.
&nbsp;     */
&nbsp;    public boolean isHmac() {
<b class="fc">&nbsp;        return familyName.equals(&quot;HMAC&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the enum instance represents an RSA public/private key pair signature algorithm,
&nbsp;     * {@code false} otherwise.
&nbsp;     *
&nbsp;     * @return {@code true} if the enum instance represents an RSA public/private key pair signature algorithm,
&nbsp;     * {@code false} otherwise.
&nbsp;     */
&nbsp;    public boolean isRsa() {
<b class="fc">&nbsp;        return familyName.equals(&quot;RSA&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if the enum instance represents an Elliptic Curve ECDSA signature algorithm, {@code false}
&nbsp;     * otherwise.
&nbsp;     *
&nbsp;     * @return {@code true} if the enum instance represents an Elliptic Curve ECDSA signature algorithm, {@code false}
&nbsp;     * otherwise.
&nbsp;     */
&nbsp;    public boolean isEllipticCurve() {
<b class="fc">&nbsp;        return familyName.equals(&quot;ECDSA&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the minimum key length in bits (not bytes) that may be used with this algorithm according to the
&nbsp;     * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518&quot;&gt;JWT JWA Specification (RFC 7518)&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @return the minimum key length in bits (not bytes) that may be used with this algorithm according to the
&nbsp;     * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518&quot;&gt;JWT JWA Specification (RFC 7518)&lt;/a&gt;.
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    public int getMinKeyLength() {
<b class="fc">&nbsp;        return this.minKeyLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns quietly if the specified key is allowed to create signatures using this algorithm
&nbsp;     * according to the &lt;a href=&quot;https://tools.ietf.org/html/rfc7518&quot;&gt;JWT JWA Specification (RFC 7518)&lt;/a&gt; or throws an
&nbsp;     * {@link InvalidKeyException} if the key is not allowed or not secure enough for this algorithm.
&nbsp;     *
&nbsp;     * @param key the key to check for validity.
&nbsp;     * @throws InvalidKeyException if the key is not allowed or not secure enough for this algorithm.
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    public void assertValidSigningKey(Key key) throws InvalidKeyException {
<b class="fc">&nbsp;        assertValid(key, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns quietly if the specified key is allowed to verify signatures using this algorithm
&nbsp;     * according to the &lt;a href=&quot;https://tools.ietf.org/html/rfc7518&quot;&gt;JWT JWA Specification (RFC 7518)&lt;/a&gt; or throws an
&nbsp;     * {@link InvalidKeyException} if the key is not allowed or not secure enough for this algorithm.
&nbsp;     *
&nbsp;     * @param key the key to check for validity.
&nbsp;     * @throws InvalidKeyException if the key is not allowed or not secure enough for this algorithm.
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    public void assertValidVerificationKey(Key key) throws InvalidKeyException {
<b class="fc">&nbsp;        assertValid(key, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 0.10.0 to support assertValid(Key, boolean)
&nbsp;     */
&nbsp;    private static String keyType(boolean signing) {
<b class="fc">&nbsp;        return signing ? &quot;signing&quot; : &quot;verification&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    private void assertValid(Key key, boolean signing) throws InvalidKeyException {
&nbsp;
<b class="fc">&nbsp;        if (this == NONE) {</b>
&nbsp;
<b class="fc">&nbsp;            String msg = &quot;The &#39;NONE&#39; signature algorithm does not support cryptographic keys.&quot;;</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(msg);</b>
&nbsp;
<b class="fc">&nbsp;        } else if (isHmac()) {</b>
&nbsp;
<b class="fc">&nbsp;            if (!(key instanceof SecretKey)) {</b>
<b class="fc">&nbsp;                String msg = this.familyName + &quot; &quot; + keyType(signing) + &quot; keys must be SecretKey instances.&quot;;</b>
<b class="fc">&nbsp;                throw new InvalidKeyException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;            SecretKey secretKey = (SecretKey) key;</b>
&nbsp;
<b class="fc">&nbsp;            byte[] encoded = secretKey.getEncoded();</b>
<b class="fc">&nbsp;            if (encoded == null) {</b>
<b class="fc">&nbsp;                throw new InvalidKeyException(&quot;The &quot; + keyType(signing) + &quot; key&#39;s encoded bytes cannot be null.&quot;);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            String alg = secretKey.getAlgorithm();</b>
<b class="fc">&nbsp;            if (alg == null) {</b>
<b class="fc">&nbsp;                throw new InvalidKeyException(&quot;The &quot; + keyType(signing) + &quot; key&#39;s algorithm cannot be null.&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // These next checks use equalsIgnoreCase per https://github.com/jwtk/jjwt/issues/381#issuecomment-412912272
<b class="fc">&nbsp;            if (!HS256.jcaName.equalsIgnoreCase(alg) &amp;&amp;</b>
<b class="fc">&nbsp;                    !HS384.jcaName.equalsIgnoreCase(alg) &amp;&amp;</b>
<b class="fc">&nbsp;                    !HS512.jcaName.equalsIgnoreCase(alg) &amp;&amp;</b>
<b class="fc">&nbsp;                    !HS256.pkcs12Name.equals(alg) &amp;&amp;</b>
<b class="fc">&nbsp;                    !HS384.pkcs12Name.equals(alg) &amp;&amp;</b>
<b class="fc">&nbsp;                    !HS512.pkcs12Name.equals(alg)) {</b>
<b class="fc">&nbsp;                throw new InvalidKeyException(&quot;The &quot; + keyType(signing) + &quot; key&#39;s algorithm &#39;&quot; + alg +</b>
<b class="fc">&nbsp;                        &quot;&#39; does not equal a valid HmacSHA* algorithm name and cannot be used with &quot; + name() + &quot;.&quot;);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            int size = encoded.length * 8; //size in bits</b>
<b class="fc">&nbsp;            if (size &lt; this.minKeyLength) {</b>
<b class="fc">&nbsp;                String msg = &quot;The &quot; + keyType(signing) + &quot; key&#39;s size is &quot; + size + &quot; bits which &quot; +</b>
<b class="fc">&nbsp;                        &quot;is not secure enough for the &quot; + name() + &quot; algorithm.  The JWT &quot; +</b>
<b class="fc">&nbsp;                        &quot;JWA Specification (RFC 7518, Section 3.2) states that keys used with &quot; + name() + &quot; MUST have a &quot; +</b>
&nbsp;                        &quot;size &gt;= &quot; + minKeyLength + &quot; bits (the key size must be greater than or equal to the hash &quot; +
<b class="fc">&nbsp;                        &quot;output size).  Consider using the &quot; + Keys.class.getName() + &quot; class&#39;s &quot; +</b>
<b class="fc">&nbsp;                        &quot;&#39;secretKeyFor(SignatureAlgorithm.&quot; + name() + &quot;)&#39; method to create a key guaranteed to be &quot; +</b>
<b class="fc">&nbsp;                        &quot;secure enough for &quot; + name() + &quot;.  See &quot; +</b>
&nbsp;                        &quot;https://tools.ietf.org/html/rfc7518#section-3.2 for more information.&quot;;
<b class="fc">&nbsp;                throw new WeakKeyException(msg);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        } else { //EC or RSA</b>
&nbsp;
<b class="fc">&nbsp;            if (signing) {</b>
<b class="fc">&nbsp;                if (!(key instanceof PrivateKey)) {</b>
<b class="fc">&nbsp;                    String msg = familyName + &quot; signing keys must be PrivateKey instances.&quot;;</b>
<b class="fc">&nbsp;                    throw new InvalidKeyException(msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (isEllipticCurve()) {</b>
&nbsp;
<b class="fc">&nbsp;                if (!(key instanceof ECKey)) {</b>
<b class="fc">&nbsp;                    String msg = familyName + &quot; &quot; + keyType(signing) + &quot; keys must be ECKey instances.&quot;;</b>
<b class="fc">&nbsp;                    throw new InvalidKeyException(msg);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                ECKey ecKey = (ECKey) key;</b>
<b class="fc">&nbsp;                int size = ecKey.getParams().getOrder().bitLength();</b>
<b class="fc">&nbsp;                if (size &lt; this.minKeyLength) {</b>
<b class="fc">&nbsp;                    String msg = &quot;The &quot; + keyType(signing) + &quot; key&#39;s size (ECParameterSpec order) is &quot; + size +</b>
<b class="fc">&nbsp;                            &quot; bits which is not secure enough for the &quot; + name() + &quot; algorithm.  The JWT &quot; +</b>
&nbsp;                            &quot;JWA Specification (RFC 7518, Section 3.4) states that keys used with &quot; +
<b class="fc">&nbsp;                            name() + &quot; MUST have a size &gt;= &quot; + this.minKeyLength +</b>
<b class="fc">&nbsp;                            &quot; bits.  Consider using the &quot; + Keys.class.getName() + &quot; class&#39;s &quot; +</b>
<b class="fc">&nbsp;                            &quot;&#39;keyPairFor(SignatureAlgorithm.&quot; + name() + &quot;)&#39; method to create a key pair guaranteed &quot; +</b>
<b class="fc">&nbsp;                            &quot;to be secure enough for &quot; + name() + &quot;.  See &quot; +</b>
&nbsp;                            &quot;https://tools.ietf.org/html/rfc7518#section-3.4 for more information.&quot;;
<b class="fc">&nbsp;                    throw new WeakKeyException(msg);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;            } else { //RSA</b>
&nbsp;
<b class="fc">&nbsp;                if (!(key instanceof RSAKey)) {</b>
<b class="fc">&nbsp;                    String msg = familyName + &quot; &quot; + keyType(signing) + &quot; keys must be RSAKey instances.&quot;;</b>
<b class="fc">&nbsp;                    throw new InvalidKeyException(msg);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                RSAKey rsaKey = (RSAKey) key;</b>
<b class="fc">&nbsp;                int size = rsaKey.getModulus().bitLength();</b>
<b class="fc">&nbsp;                if (size &lt; this.minKeyLength) {</b>
&nbsp;
<b class="fc">&nbsp;                    String section = name().startsWith(&quot;P&quot;) ? &quot;3.5&quot; : &quot;3.3&quot;;</b>
&nbsp;
<b class="fc">&nbsp;                    String msg = &quot;The &quot; + keyType(signing) + &quot; key&#39;s size is &quot; + size + &quot; bits which is not secure &quot; +</b>
<b class="fc">&nbsp;                            &quot;enough for the &quot; + name() + &quot; algorithm.  The JWT JWA Specification (RFC 7518, Section &quot; +</b>
<b class="fc">&nbsp;                            section + &quot;) states that keys used with &quot; + name() + &quot; MUST have a size &gt;= &quot; +</b>
<b class="fc">&nbsp;                            this.minKeyLength + &quot; bits.  Consider using the &quot; + Keys.class.getName() + &quot; class&#39;s &quot; +</b>
<b class="fc">&nbsp;                            &quot;&#39;keyPairFor(SignatureAlgorithm.&quot; + name() + &quot;)&#39; method to create a key pair guaranteed &quot; +</b>
<b class="fc">&nbsp;                            &quot;to be secure enough for &quot; + name() + &quot;.  See &quot; +</b>
&nbsp;                            &quot;https://tools.ietf.org/html/rfc7518#section-&quot; + section + &quot; for more information.&quot;;
<b class="fc">&nbsp;                    throw new WeakKeyException(msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the recommended signature algorithm to be used with the specified key according to the following
&nbsp;     * heuristics:
&nbsp;     *
&nbsp;     * &lt;table&gt;
&nbsp;     * &lt;caption&gt;Key Signature Algorithm&lt;/caption&gt;
&nbsp;     * &lt;thead&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;th&gt;If the Key is a:&lt;/th&gt;
&nbsp;     * &lt;th&gt;And:&lt;/th&gt;
&nbsp;     * &lt;th&gt;With a key size of:&lt;/th&gt;
&nbsp;     * &lt;th&gt;The returned SignatureAlgorithm will be:&lt;/th&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/thead&gt;
&nbsp;     * &lt;tbody&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link SecretKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;{@link Key#getAlgorithm() getAlgorithm()}.equals(&quot;HmacSHA256&quot;)&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;256 &amp;lt;= size &amp;lt;= 383 &lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#HS256 HS256}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link SecretKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;{@link Key#getAlgorithm() getAlgorithm()}.equals(&quot;HmacSHA384&quot;)&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;384 &amp;lt;= size &amp;lt;= 511&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#HS384 HS384}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link SecretKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;{@link Key#getAlgorithm() getAlgorithm()}.equals(&quot;HmacSHA512&quot;)&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;512 &amp;lt;= size&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#HS512 HS512}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link ECKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;256 &amp;lt;= size &amp;lt;= 383 &lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#ES256 ES256}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link ECKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;384 &amp;lt;= size &amp;lt;= 511&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#ES384 ES384}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link ECKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;4096 &amp;lt;= size&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#ES512 ES512}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link RSAKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;2048 &amp;lt;= size &amp;lt;= 3071 &lt;sup&gt;4,5&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#RS256 RS256}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link RSAKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;3072 &amp;lt;= size &amp;lt;= 4095 &lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#RS384 RS384}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;tr&gt;
&nbsp;     * &lt;td&gt;{@link RSAKey}&lt;/td&gt;
&nbsp;     * &lt;td&gt;&lt;code&gt;instanceof {@link PrivateKey}&lt;/code&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;4096 &amp;lt;= size &lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt;
&nbsp;     * &lt;td&gt;{@link SignatureAlgorithm#RS512 RS512}&lt;/td&gt;
&nbsp;     * &lt;/tr&gt;
&nbsp;     * &lt;/tbody&gt;
&nbsp;     * &lt;/table&gt;
&nbsp;     * &lt;p&gt;Notes:&lt;/p&gt;
&nbsp;     * &lt;ol&gt;
&nbsp;     * &lt;li&gt;{@code SecretKey} instances must have an {@link Key#getAlgorithm() algorithm} name equal
&nbsp;     * to {@code HmacSHA256}, {@code HmacSHA384} or {@code HmacSHA512}.  If not, the key bytes might not be
&nbsp;     * suitable for HMAC signatures will be rejected with a {@link InvalidKeyException}. &lt;/li&gt;
&nbsp;     * &lt;li&gt;The JWT &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.2&quot;&gt;JWA Specification (RFC 7518,
&nbsp;     * Section 3.2)&lt;/a&gt; mandates that HMAC-SHA-* signing keys &lt;em&gt;MUST&lt;/em&gt; be 256 bits or greater.
&nbsp;     * {@code SecretKey}s with key lengths less than 256 bits will be rejected with an
&nbsp;     * {@link WeakKeyException}.&lt;/li&gt;
&nbsp;     * &lt;li&gt;The JWT &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.4&quot;&gt;JWA Specification (RFC 7518,
&nbsp;     * Section 3.4)&lt;/a&gt; mandates that ECDSA signing key lengths &lt;em&gt;MUST&lt;/em&gt; be 256 bits or greater.
&nbsp;     * {@code ECKey}s with key lengths less than 256 bits will be rejected with a
&nbsp;     * {@link WeakKeyException}.&lt;/li&gt;
&nbsp;     * &lt;li&gt;The JWT &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.3&quot;&gt;JWA Specification (RFC 7518,
&nbsp;     * Section 3.3)&lt;/a&gt; mandates that RSA signing key lengths &lt;em&gt;MUST&lt;/em&gt; be 2048 bits or greater.
&nbsp;     * {@code RSAKey}s with key lengths less than 2048 bits will be rejected with a
&nbsp;     * {@link WeakKeyException}.&lt;/li&gt;
&nbsp;     * &lt;li&gt;Technically any RSA key of length &amp;gt;= 2048 bits may be used with the {@link #RS256}, {@link #RS384}, and
&nbsp;     * {@link #RS512} algorithms, so we assume an RSA signature algorithm based on the key length to
&nbsp;     * parallel similar decisions in the JWT specification for HMAC and ECDSA signature algorithms.
&nbsp;     * This is not required - just a convenience.&lt;/li&gt;
&nbsp;     * &lt;/ol&gt;
&nbsp;     * &lt;p&gt;This implementation does not return the {@link #PS256}, {@link #PS256}, {@link #PS256} RSA variant for any
&nbsp;     * specified {@link RSAKey} because:
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;The JWT &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-3.1&quot;&gt;JWA Specification (RFC 7518,
&nbsp;     * Section 3.1)&lt;/a&gt; indicates that {@link #RS256}, {@link #RS384}, and {@link #RS512} are
&nbsp;     * recommended algorithms while the {@code PS}* variants are simply marked as optional.&lt;/li&gt;
&nbsp;     * &lt;li&gt;The {@link #RS256}, {@link #RS384}, and {@link #RS512} algorithms are available in the JDK by default
&nbsp;     * while the {@code PS}* variants require an additional JCA Provider (like BouncyCastle).&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Finally, this method will throw an {@link InvalidKeyException} for any key that does not match the
&nbsp;     * heuristics and requirements documented above, since that inevitably means the Key is either insufficient or
&nbsp;     * explicitly disallowed by the JWT specification.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param key the key to inspect
&nbsp;     * @return the recommended signature algorithm to be used with the specified key
&nbsp;     * @throws InvalidKeyException for any key that does not match the heuristics and requirements documented above,
&nbsp;     *                             since that inevitably means the Key is either insufficient or explicitly disallowed by the JWT specification.
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    public static SignatureAlgorithm forSigningKey(Key key) throws InvalidKeyException {
&nbsp;
<b class="fc">&nbsp;        if (key == null) {</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(&quot;Key argument cannot be null.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (!(key instanceof SecretKey ||</b>
&nbsp;                (key instanceof PrivateKey &amp;&amp; (key instanceof ECKey || key instanceof RSAKey)))) {
<b class="fc">&nbsp;            String msg = &quot;JWT standard signing algorithms require either 1) a SecretKey for HMAC-SHA algorithms or &quot; +</b>
&nbsp;                    &quot;2) a private RSAKey for RSA algorithms or 3) a private ECKey for Elliptic Curve algorithms.  &quot; +
<b class="fc">&nbsp;                    &quot;The specified key is of type &quot; + key.getClass().getName();</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(msg);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (key instanceof SecretKey) {</b>
&nbsp;
<b class="fc">&nbsp;            SecretKey secretKey = (SecretKey) key;</b>
<b class="fc">&nbsp;            int bitLength = io.jsonwebtoken.lang.Arrays.length(secretKey.getEncoded()) * Byte.SIZE;</b>
&nbsp;
<b class="fc">&nbsp;            for (SignatureAlgorithm alg : PREFERRED_HMAC_ALGS) {</b>
&nbsp;                // ensure compatibility check is based on key length. See https://github.com/jwtk/jjwt/issues/381
<b class="fc">&nbsp;                if (bitLength &gt;= alg.minKeyLength) {</b>
<b class="fc">&nbsp;                    return alg;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            String msg = &quot;The specified SecretKey is not strong enough to be used with JWT HMAC signature &quot; +</b>
&nbsp;                    &quot;algorithms.  The JWT specification requires HMAC keys to be &gt;= 256 bits long.  The specified &quot; +
&nbsp;                    &quot;key is &quot; + bitLength + &quot; bits.  See https://tools.ietf.org/html/rfc7518#section-3.2 for more &quot; +
&nbsp;                    &quot;information.&quot;;
<b class="fc">&nbsp;            throw new WeakKeyException(msg);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (key instanceof RSAKey) {</b>
&nbsp;
<b class="fc">&nbsp;            RSAKey rsaKey = (RSAKey) key;</b>
<b class="fc">&nbsp;            int bitLength = rsaKey.getModulus().bitLength();</b>
&nbsp;
<b class="fc">&nbsp;            if (bitLength &gt;= 4096) {</b>
<b class="fc">&nbsp;                RS512.assertValidSigningKey(key);</b>
<b class="fc">&nbsp;                return RS512;</b>
<b class="fc">&nbsp;            } else if (bitLength &gt;= 3072) {</b>
<b class="fc">&nbsp;                RS384.assertValidSigningKey(key);</b>
<b class="fc">&nbsp;                return RS384;</b>
<b class="fc">&nbsp;            } else if (bitLength &gt;= RS256.minKeyLength) {</b>
<b class="fc">&nbsp;                RS256.assertValidSigningKey(key);</b>
<b class="fc">&nbsp;                return RS256;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            String msg = &quot;The specified RSA signing key is not strong enough to be used with JWT RSA signature &quot; +</b>
&nbsp;                    &quot;algorithms.  The JWT specification requires RSA keys to be &gt;= 2048 bits long.  The specified RSA &quot; +
&nbsp;                    &quot;key is &quot; + bitLength + &quot; bits.  See https://tools.ietf.org/html/rfc7518#section-3.3 for more &quot; +
&nbsp;                    &quot;information.&quot;;
<b class="fc">&nbsp;            throw new WeakKeyException(msg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // if we&#39;ve made it this far in the method, the key is an ECKey due to the instanceof assertions at the
&nbsp;        // top of the method
&nbsp;
<b class="fc">&nbsp;        ECKey ecKey = (ECKey) key;</b>
<b class="fc">&nbsp;        int bitLength = ecKey.getParams().getOrder().bitLength();</b>
&nbsp;
<b class="fc">&nbsp;        for (SignatureAlgorithm alg : PREFERRED_EC_ALGS) {</b>
<b class="fc">&nbsp;            if (bitLength &gt;= alg.minKeyLength) {</b>
<b class="fc">&nbsp;                alg.assertValidSigningKey(key);</b>
<b class="fc">&nbsp;                return alg;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        String msg = &quot;The specified Elliptic Curve signing key is not strong enough to be used with JWT ECDSA &quot; +</b>
&nbsp;                &quot;signature algorithms.  The JWT specification requires ECDSA keys to be &gt;= 256 bits long.  &quot; +
&nbsp;                &quot;The specified ECDSA key is &quot; + bitLength + &quot; bits.  See &quot; +
&nbsp;                &quot;https://tools.ietf.org/html/rfc7518#section-3.4 for more information.&quot;;
<b class="fc">&nbsp;        throw new WeakKeyException(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Looks up and returns the corresponding {@code SignatureAlgorithm} enum instance based on a
&nbsp;     * case-&lt;em&gt;insensitive&lt;/em&gt; name comparison.
&nbsp;     *
&nbsp;     * @param value The case-insensitive name of the {@code SignatureAlgorithm} instance to return
&nbsp;     * @return the corresponding {@code SignatureAlgorithm} enum instance based on a
&nbsp;     * case-&lt;em&gt;insensitive&lt;/em&gt; name comparison.
&nbsp;     * @throws SignatureException if the specified value does not match any {@code SignatureAlgorithm}
&nbsp;     *                            name.
&nbsp;     */
&nbsp;    public static SignatureAlgorithm forName(String value) throws SignatureException {
<b class="fc">&nbsp;        for (SignatureAlgorithm alg : values()) {</b>
<b class="fc">&nbsp;            if (alg.getValue().equalsIgnoreCase(value)) {</b>
<b class="fc">&nbsp;                return alg;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        throw new SignatureException(&quot;Unsupported signature algorithm &#39;&quot; + value + &quot;&#39;&quot;);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
