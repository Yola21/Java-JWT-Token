


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DefaultJwtParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl</a>
</div>

<h1>Coverage Summary for Class: DefaultJwtParser (io.jsonwebtoken.impl)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultJwtParser</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.5%
  </span>
  <span class="absValue">
    (156/160)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (365/365)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl;
&nbsp;
&nbsp;import io.jsonwebtoken.Claims;
&nbsp;import io.jsonwebtoken.ClaimsBuilder;
&nbsp;import io.jsonwebtoken.Clock;
&nbsp;import io.jsonwebtoken.CompressionCodecResolver;
&nbsp;import io.jsonwebtoken.ExpiredJwtException;
&nbsp;import io.jsonwebtoken.Header;
&nbsp;import io.jsonwebtoken.IncorrectClaimException;
&nbsp;import io.jsonwebtoken.Jwe;
&nbsp;import io.jsonwebtoken.JweHeader;
&nbsp;import io.jsonwebtoken.Jws;
&nbsp;import io.jsonwebtoken.JwsHeader;
&nbsp;import io.jsonwebtoken.Jwt;
&nbsp;import io.jsonwebtoken.JwtException;
&nbsp;import io.jsonwebtoken.JwtHandler;
&nbsp;import io.jsonwebtoken.JwtParser;
&nbsp;import io.jsonwebtoken.Jwts;
&nbsp;import io.jsonwebtoken.Locator;
&nbsp;import io.jsonwebtoken.MalformedJwtException;
&nbsp;import io.jsonwebtoken.MissingClaimException;
&nbsp;import io.jsonwebtoken.PrematureJwtException;
&nbsp;import io.jsonwebtoken.ProtectedHeader;
&nbsp;import io.jsonwebtoken.SigningKeyResolver;
&nbsp;import io.jsonwebtoken.UnsupportedJwtException;
&nbsp;import io.jsonwebtoken.impl.io.AbstractParser;
&nbsp;import io.jsonwebtoken.impl.io.BytesInputStream;
&nbsp;import io.jsonwebtoken.impl.io.CharSequenceReader;
&nbsp;import io.jsonwebtoken.impl.io.JsonObjectDeserializer;
&nbsp;import io.jsonwebtoken.impl.io.Streams;
&nbsp;import io.jsonwebtoken.impl.io.UncloseableInputStream;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.impl.lang.Function;
&nbsp;import io.jsonwebtoken.impl.lang.RedactedSupplier;
&nbsp;import io.jsonwebtoken.impl.security.DefaultDecryptAeadRequest;
&nbsp;import io.jsonwebtoken.impl.security.DefaultDecryptionKeyRequest;
&nbsp;import io.jsonwebtoken.impl.security.DefaultVerifySecureDigestRequest;
&nbsp;import io.jsonwebtoken.impl.security.LocatingKeyResolver;
&nbsp;import io.jsonwebtoken.impl.security.ProviderKey;
&nbsp;import io.jsonwebtoken.io.CompressionAlgorithm;
&nbsp;import io.jsonwebtoken.io.Decoder;
&nbsp;import io.jsonwebtoken.io.DeserializationException;
&nbsp;import io.jsonwebtoken.io.Deserializer;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.DateFormats;
&nbsp;import io.jsonwebtoken.lang.Objects;
&nbsp;import io.jsonwebtoken.lang.Registry;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;import io.jsonwebtoken.security.AeadAlgorithm;
&nbsp;import io.jsonwebtoken.security.DecryptAeadRequest;
&nbsp;import io.jsonwebtoken.security.DecryptionKeyRequest;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.KeyAlgorithm;
&nbsp;import io.jsonwebtoken.security.SecureDigestAlgorithm;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;import io.jsonwebtoken.security.VerifySecureDigestRequest;
&nbsp;import io.jsonwebtoken.security.WeakKeyException;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import java.io.BufferedInputStream;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.Reader;
&nbsp;import java.io.SequenceInputStream;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.CharBuffer;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.Provider;
&nbsp;import java.security.PublicKey;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Date;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;@SuppressWarnings(&quot;unchecked&quot;)
&nbsp;public class DefaultJwtParser extends AbstractParser&lt;Jwt&lt;?, ?&gt;&gt; implements JwtParser {
&nbsp;
&nbsp;    static final char SEPARATOR_CHAR = &#39;.&#39;;
&nbsp;
<b class="fc">&nbsp;    private static final JwtTokenizer jwtTokenizer = new JwtTokenizer();</b>
&nbsp;
&nbsp;    static final String PRIV_KEY_VERIFY_MSG = &quot;PrivateKeys may not be used to verify digital signatures. &quot; +
&nbsp;            &quot;PrivateKeys are used to sign, and PublicKeys are used to verify.&quot;;
&nbsp;
&nbsp;    static final String PUB_KEY_DECRYPT_MSG = &quot;PublicKeys may not be used to decrypt data. PublicKeys are &quot; +
&nbsp;            &quot;used to encrypt, and PrivateKeys are used to decrypt.&quot;;
&nbsp;
&nbsp;    public static final String INCORRECT_EXPECTED_CLAIM_MESSAGE_TEMPLATE = &quot;Expected %s claim to be: %s, but was: %s.&quot;;
&nbsp;
&nbsp;    public static final String MISSING_EXPECTED_CLAIM_VALUE_MESSAGE_TEMPLATE =
&nbsp;            &quot;Missing expected &#39;%s&#39; value in &#39;%s&#39; claim %s.&quot;;
&nbsp;
&nbsp;    public static final String MISSING_JWS_ALG_MSG = &quot;JWS header does not contain a required &#39;alg&#39; (Algorithm) &quot; +
&nbsp;            &quot;header parameter.  This header parameter is mandatory per the JWS Specification, Section 4.1.1. See &quot; +
&nbsp;            &quot;https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.1 for more information.&quot;;
&nbsp;
&nbsp;    public static final String MISSING_JWE_ALG_MSG = &quot;JWE header does not contain a required &#39;alg&#39; (Algorithm) &quot; +
&nbsp;            &quot;header parameter.  This header parameter is mandatory per the JWE Specification, Section 4.1.1. See &quot; +
&nbsp;            &quot;https://www.rfc-editor.org/rfc/rfc7516.html#section-4.1.1 for more information.&quot;;
&nbsp;
&nbsp;    public static final String MISSING_JWS_DIGEST_MSG_FMT = &quot;The JWS header references signature algorithm &#39;%s&#39; but &quot; +
&nbsp;            &quot;the compact JWE string is missing the required signature.&quot;;
&nbsp;
&nbsp;    public static final String MISSING_JWE_DIGEST_MSG_FMT = &quot;The JWE header references key management algorithm &#39;%s&#39; &quot; +
&nbsp;            &quot;but the compact JWE string is missing the required AAD authentication tag.&quot;;
&nbsp;
&nbsp;    private static final String MISSING_ENC_MSG = &quot;JWE header does not contain a required &#39;enc&#39; (Encryption &quot; +
&nbsp;            &quot;Algorithm) header parameter.  This header parameter is mandatory per the JWE Specification, &quot; +
&nbsp;            &quot;Section 4.1.2. See https://www.rfc-editor.org/rfc/rfc7516.html#section-4.1.2 for more information.&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String UNSECURED_DISABLED_MSG_PREFIX = &quot;Unsecured JWSs (those with an &quot; +</b>
<b class="fc">&nbsp;            DefaultHeader.ALGORITHM + &quot; header value of &#39;&quot; + Jwts.SIG.NONE.getId() + &quot;&#39;) are disallowed by &quot; +</b>
&nbsp;            &quot;default as mandated by https://www.rfc-editor.org/rfc/rfc7518.html#section-3.6. If you wish to &quot; +
&nbsp;            &quot;allow them to be parsed, call the JwtParserBuilder.unsecured() method, but please read the &quot; +
&nbsp;            &quot;security considerations covered in that method&#39;s JavaDoc before doing so. Header: &quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String CRIT_UNSECURED_MSG = &quot;Unsecured JWSs (those with an &quot; + DefaultHeader.ALGORITHM +</b>
<b class="fc">&nbsp;            &quot; header value of &#39;&quot; + Jwts.SIG.NONE.getId() + &quot;&#39;) may not use the &quot; + DefaultProtectedHeader.CRIT +</b>
&nbsp;            &quot; header parameter per https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.11 (\&quot;the [crit] Header &quot; +
&nbsp;            &quot;Parameter MUST be integrity protected; therefore, it MUST occur only within [a] JWS Protected Header)\&quot;.&quot; +
&nbsp;            &quot; Header: %s&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String CRIT_MISSING_MSG = &quot;Protected Header &quot; +</b>
&nbsp;            DefaultProtectedHeader.CRIT + &quot; set references header name &#39;%s&#39;, but the header does not contain an &quot; +
&nbsp;            &quot;associated &#39;%s&#39; header parameter as required by &quot; +
&nbsp;            &quot;https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.11. Header: %s&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String CRIT_UNSUPPORTED_MSG = &quot;Protected Header &quot; + DefaultProtectedHeader.CRIT +</b>
&nbsp;            &quot; set references unsupported header name &#39;%s&#39;. Application developers expecting to support a JWT &quot; +
&nbsp;            &quot;extension using header &#39;%s&#39; in their application code must indicate it &quot; +
&nbsp;            &quot;is supported by using the JwtParserBuilder.critical method. Header: %s&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String JWE_NONE_MSG = &quot;JWEs do not support key management &quot; + DefaultHeader.ALGORITHM +</b>
<b class="fc">&nbsp;            &quot; header value &#39;&quot; + Jwts.SIG.NONE.getId() + &quot;&#39; per &quot; +</b>
&nbsp;            &quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.1&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String JWS_NONE_SIG_MISMATCH_MSG = &quot;The JWS header references signature algorithm &#39;&quot; +</b>
<b class="fc">&nbsp;            Jwts.SIG.NONE.getId() + &quot;&#39; yet the compact JWS string contains a signature. This is not permitted &quot; +</b>
&nbsp;            &quot;per https://tools.ietf.org/html/rfc7518#section-3.6.&quot;;
&nbsp;
&nbsp;    private static final String B64_MISSING_PAYLOAD = &quot;Unable to verify JWS signature: the parser has encountered an &quot; +
&nbsp;            &quot;Unencoded Payload JWS with detached payload, but the detached payload value required for signature &quot; +
&nbsp;            &quot;verification has not been provided. If you expect to receive and parse Unencoded Payload JWSs in your &quot; +
&nbsp;            &quot;application, the overloaded JwtParser.parseSignedContent or JwtParser.parseSignedClaims methods that &quot; +
&nbsp;            &quot;accept a byte[] or InputStream must be used for these kinds of JWSs. Header: %s&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String B64_DECOMPRESSION_MSG = &quot;The JWT header references compression algorithm &quot; +</b>
&nbsp;            &quot;&#39;%s&#39;, but payload decompression for Unencoded JWSs (those with an &quot; + DefaultJwsHeader.B64 +
&nbsp;            &quot; header value of false) that rely on a SigningKeyResolver are disallowed &quot; +
&nbsp;            &quot;by default to protect against [Denial of Service attacks](&quot; +
&nbsp;            &quot;https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-pellegrino.pdf).  If you &quot; +
&nbsp;            &quot;wish to enable Unencoded JWS payload decompression, configure the JwtParserBuilder.&quot; +
&nbsp;            &quot;keyLocator(Locator) and do not configure a SigningKeyResolver.&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final String UNPROTECTED_DECOMPRESSION_MSG = &quot;The JWT header references compression algorithm &quot; +</b>
&nbsp;            &quot;&#39;%s&#39;, but payload decompression for Unprotected JWTs (those with an &quot; + DefaultHeader.ALGORITHM +
<b class="fc">&nbsp;            &quot; header value of &#39;&quot; + Jwts.SIG.NONE.getId() + &quot;&#39;) or Unencoded JWSs (those with a &quot; +</b>
&nbsp;            DefaultJwsHeader.B64 + &quot; header value of false) that also rely on a SigningKeyResolver are disallowed &quot; +
&nbsp;            &quot;by default to protect against [Denial of Service attacks](&quot; +
&nbsp;            &quot;https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-pellegrino.pdf).  If you &quot; +
&nbsp;            &quot;wish to enable Unsecure JWS or Unencoded JWS payload decompression, call the JwtParserBuilder.&quot; +
&nbsp;            &quot;unsecuredDecompression() method, but please read the security considerations covered in that &quot; +
&nbsp;            &quot;method&#39;s JavaDoc before doing so.&quot;;
&nbsp;
&nbsp;    private final Provider provider;
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    private final SigningKeyResolver signingKeyResolver;
&nbsp;
&nbsp;    private final boolean unsecured;
&nbsp;
&nbsp;    private final boolean unsecuredDecompression;
&nbsp;
&nbsp;    private final Function&lt;JwsHeader, SecureDigestAlgorithm&lt;?, ?&gt;&gt; sigAlgs;
&nbsp;
&nbsp;    private final Function&lt;JweHeader, AeadAlgorithm&gt; encAlgs;
&nbsp;
&nbsp;    private final Function&lt;JweHeader, KeyAlgorithm&lt;?, ?&gt;&gt; keyAlgs;
&nbsp;
&nbsp;    private final Function&lt;Header, CompressionAlgorithm&gt; zipAlgs;
&nbsp;
&nbsp;    private final Locator&lt;? extends Key&gt; keyLocator;
&nbsp;
&nbsp;    private final Decoder&lt;InputStream, InputStream&gt; decoder;
&nbsp;
&nbsp;    private final Deserializer&lt;Map&lt;String, ?&gt;&gt; deserializer;
&nbsp;
&nbsp;    private final ClaimsBuilder expectedClaims;
&nbsp;
&nbsp;    private final Clock clock;
&nbsp;
&nbsp;    private final Set&lt;String&gt; critical;
&nbsp;
&nbsp;    private final long allowedClockSkewMillis;
&nbsp;
&nbsp;    //SigningKeyResolver will be removed for 1.0:
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    DefaultJwtParser(Provider provider,
&nbsp;                     SigningKeyResolver signingKeyResolver,
&nbsp;                     boolean unsecured,
&nbsp;                     boolean unsecuredDecompression,
&nbsp;                     Locator&lt;? extends Key&gt; keyLocator,
&nbsp;                     Clock clock,
&nbsp;                     Set&lt;String&gt; critical,
&nbsp;                     long allowedClockSkewMillis,
&nbsp;                     DefaultClaims expectedClaims,
&nbsp;                     Decoder&lt;InputStream, InputStream&gt; base64UrlDecoder,
&nbsp;                     Deserializer&lt;Map&lt;String, ?&gt;&gt; deserializer,
&nbsp;                     CompressionCodecResolver compressionCodecResolver,
&nbsp;                     Registry&lt;String, CompressionAlgorithm&gt; zipAlgs,
&nbsp;                     Registry&lt;String, SecureDigestAlgorithm&lt;?, ?&gt;&gt; sigAlgs,
&nbsp;                     Registry&lt;String, KeyAlgorithm&lt;?, ?&gt;&gt; keyAlgs,
<b class="fc">&nbsp;                     Registry&lt;String, AeadAlgorithm&gt; encAlgs) {</b>
<b class="fc">&nbsp;        this.provider = provider;</b>
<b class="fc">&nbsp;        this.unsecured = unsecured;</b>
<b class="fc">&nbsp;        this.unsecuredDecompression = unsecuredDecompression;</b>
<b class="fc">&nbsp;        this.signingKeyResolver = signingKeyResolver;</b>
<b class="fc">&nbsp;        this.keyLocator = Assert.notNull(keyLocator, &quot;Key Locator cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.clock = Assert.notNull(clock, &quot;Clock cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.critical = Collections.nullSafe(critical);</b>
<b class="fc">&nbsp;        this.allowedClockSkewMillis = allowedClockSkewMillis;</b>
<b class="fc">&nbsp;        this.expectedClaims = Jwts.claims().add(expectedClaims);</b>
<b class="fc">&nbsp;        this.decoder = Assert.notNull(base64UrlDecoder, &quot;base64UrlDecoder cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.deserializer = Assert.notNull(deserializer, &quot;JSON Deserializer cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.sigAlgs = new IdLocator&lt;&gt;(DefaultHeader.ALGORITHM, sigAlgs, MISSING_JWS_ALG_MSG);</b>
<b class="fc">&nbsp;        this.keyAlgs = new IdLocator&lt;&gt;(DefaultHeader.ALGORITHM, keyAlgs, MISSING_JWE_ALG_MSG);</b>
<b class="fc">&nbsp;        this.encAlgs = new IdLocator&lt;&gt;(DefaultJweHeader.ENCRYPTION_ALGORITHM, encAlgs, MISSING_ENC_MSG);</b>
<b class="fc">&nbsp;        this.zipAlgs = compressionCodecResolver != null ? new CompressionCodecLocator(compressionCodecResolver) :</b>
<b class="fc">&nbsp;                new IdLocator&lt;&gt;(DefaultHeader.COMPRESSION_ALGORITHM, zipAlgs, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isSigned(CharSequence compact) {
<b class="fc">&nbsp;        if (!Strings.hasText(compact)) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        try {
<b class="fc">&nbsp;            final TokenizedJwt tokenized = jwtTokenizer.tokenize(new CharSequenceReader(compact));</b>
<b class="pc">&nbsp;            return !(tokenized instanceof TokenizedJwe) &amp;&amp; Strings.hasText(tokenized.getDigest());</b>
<b class="fc">&nbsp;        } catch (MalformedJwtException e) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static boolean hasContentType(Header header) {
<b class="pc">&nbsp;        return header != null &amp;&amp; Strings.hasText(header.getContentType());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void verifySignature(final TokenizedJwt tokenized, final JwsHeader jwsHeader, final String alg,
&nbsp;                                 @SuppressWarnings(&quot;deprecation&quot;) SigningKeyResolver resolver, Claims claims, Payload payload) {
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(resolver, &quot;SigningKeyResolver instance cannot be null.&quot;);</b>
&nbsp;
&nbsp;        SecureDigestAlgorithm&lt;?, Key&gt; algorithm;
&nbsp;        try {
<b class="fc">&nbsp;            algorithm = (SecureDigestAlgorithm&lt;?, Key&gt;) sigAlgs.apply(jwsHeader);</b>
<b class="fc">&nbsp;        } catch (UnsupportedJwtException e) {</b>
&nbsp;            //For backwards compatibility.  TODO: remove this try/catch block for 1.0 and let UnsupportedJwtException propagate
<b class="fc">&nbsp;            String msg = &quot;Unsupported signature algorithm &#39;&quot; + alg + &quot;&#39;&quot;;</b>
<b class="fc">&nbsp;            throw new SignatureException(msg, e);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        Assert.stateNotNull(algorithm, &quot;JWS Signature Algorithm cannot be null.&quot;);</b>
&nbsp;
&nbsp;        //digitally signed, let&#39;s assert the signature:
&nbsp;        Key key;
<b class="fc">&nbsp;        if (claims != null) {</b>
<b class="fc">&nbsp;            key = resolver.resolveSigningKey(jwsHeader, claims);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            key = resolver.resolveSigningKey(jwsHeader, payload.getBytes());</b>
&nbsp;        }
<b class="fc">&nbsp;        if (key == null) {</b>
<b class="fc">&nbsp;            String msg = &quot;Cannot verify JWS signature: unable to locate signature verification key for JWS with header: &quot; + jwsHeader;</b>
<b class="fc">&nbsp;            throw new UnsupportedJwtException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        Provider provider = ProviderKey.getProvider(key, this.provider); // extract if necessary</b>
<b class="fc">&nbsp;        key = ProviderKey.getKey(key); // unwrap if necessary, MUST be called after ProviderKey.getProvider</b>
<b class="fc">&nbsp;        Assert.stateNotNull(key, &quot;ProviderKey cannot be null.&quot;); //ProviderKey impl doesn&#39;t allow null</b>
<b class="fc">&nbsp;        if (key instanceof PrivateKey) {</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(PRIV_KEY_VERIFY_MSG);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final byte[] signature = decode(tokenized.getDigest(), &quot;JWS signature&quot;);</b>
&nbsp;
&nbsp;        //re-create the jwt part without the signature.  This is what is needed for signature verification:
<b class="fc">&nbsp;        InputStream payloadStream = null;</b>
&nbsp;        InputStream verificationInput;
<b class="fc">&nbsp;        if (jwsHeader.isPayloadEncoded()) {</b>
<b class="fc">&nbsp;            int len = tokenized.getProtected().length() + 1 + tokenized.getPayload().length();</b>
<b class="fc">&nbsp;            CharBuffer cb = CharBuffer.allocate(len);</b>
<b class="fc">&nbsp;            cb.put(Strings.wrap(tokenized.getProtected()));</b>
<b class="fc">&nbsp;            cb.put(SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;            cb.put(Strings.wrap(tokenized.getPayload()));</b>
<b class="fc">&nbsp;            cb.rewind();</b>
<b class="fc">&nbsp;            ByteBuffer bb = StandardCharsets.US_ASCII.encode(cb);</b>
<b class="fc">&nbsp;            bb.rewind();</b>
<b class="fc">&nbsp;            byte[] data = new byte[bb.remaining()];</b>
<b class="fc">&nbsp;            bb.get(data);</b>
<b class="fc">&nbsp;            verificationInput = Streams.of(data);</b>
<b class="fc">&nbsp;        } else { // b64 extension</b>
<b class="fc">&nbsp;            ByteBuffer headerBuf = StandardCharsets.US_ASCII.encode(Strings.wrap(tokenized.getProtected()));</b>
<b class="fc">&nbsp;            headerBuf.rewind();</b>
<b class="fc">&nbsp;            ByteBuffer buf = ByteBuffer.allocate(headerBuf.remaining() + 1);</b>
<b class="fc">&nbsp;            buf.put(headerBuf);</b>
<b class="fc">&nbsp;            buf.put((byte) SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;            buf.rewind();</b>
<b class="fc">&nbsp;            byte[] data = new byte[buf.remaining()];</b>
<b class="fc">&nbsp;            buf.get(data);</b>
<b class="fc">&nbsp;            InputStream prefixStream = Streams.of(data);</b>
<b class="fc">&nbsp;            payloadStream = payload.toInputStream();</b>
&nbsp;            // We wrap the payloadStream here in an UncloseableInputStream to prevent the SequenceInputStream from
&nbsp;            // closing it since we&#39;ll need to rewind/reset it if decompression is enabled
<b class="fc">&nbsp;            verificationInput = new SequenceInputStream(prefixStream, new UncloseableInputStream(payloadStream));</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            VerifySecureDigestRequest&lt;Key&gt; request =</b>
&nbsp;                    new DefaultVerifySecureDigestRequest&lt;&gt;(verificationInput, provider, null, key, signature);
<b class="fc">&nbsp;            if (!algorithm.verify(request)) {</b>
<b class="fc">&nbsp;                String msg = &quot;JWT signature does not match locally computed signature. JWT validity cannot be &quot; +</b>
&nbsp;                        &quot;asserted and should not be trusted.&quot;;
<b class="fc">&nbsp;                throw new SignatureException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;        } catch (WeakKeyException e) {</b>
<b class="fc">&nbsp;            throw e;</b>
<b class="fc">&nbsp;        } catch (InvalidKeyException | IllegalArgumentException e) {</b>
<b class="fc">&nbsp;            String algId = algorithm.getId();</b>
<b class="fc">&nbsp;            String msg = &quot;The parsed JWT indicates it was signed with the &#39;&quot; + algId + &quot;&#39; signature &quot; +</b>
<b class="fc">&nbsp;                    &quot;algorithm, but the provided &quot; + key.getClass().getName() + &quot; key may &quot; +</b>
&nbsp;                    &quot;not be used to verify &quot; + algId + &quot; signatures.  Because the specified &quot; +
&nbsp;                    &quot;key reflects a specific and expected algorithm, and the JWT does not reflect &quot; +
&nbsp;                    &quot;this algorithm, it is likely that the JWT was not expected and therefore should not be &quot; +
&nbsp;                    &quot;trusted.  Another possibility is that the parser was provided the incorrect &quot; +
&nbsp;                    &quot;signature verification key, but this cannot be assumed for security reasons.&quot;;
<b class="fc">&nbsp;            throw new UnsupportedJwtException(msg, e);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Streams.reset(payloadStream);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwt&lt;?, ?&gt; parse(Reader reader) {
<b class="fc">&nbsp;        Assert.notNull(reader, &quot;Reader cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return parse(reader, Payload.EMPTY);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Jwt&lt;?, ?&gt; parse(Reader compact, Payload unencodedPayload) {
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(compact, &quot;Compact reader cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.stateNotNull(unencodedPayload, &quot;internal error: unencodedPayload is null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        final TokenizedJwt tokenized = jwtTokenizer.tokenize(compact);</b>
<b class="fc">&nbsp;        final CharSequence base64UrlHeader = tokenized.getProtected();</b>
<b class="fc">&nbsp;        if (!Strings.hasText(base64UrlHeader)) {</b>
<b class="fc">&nbsp;            String msg = &quot;Compact JWT strings MUST always have a Base64Url protected header per &quot; +</b>
&nbsp;                    &quot;https://tools.ietf.org/html/rfc7519#section-7.2 (steps 2-4).&quot;;
<b class="fc">&nbsp;            throw new MalformedJwtException(msg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // =============== Header =================
<b class="fc">&nbsp;        final byte[] headerBytes = decode(base64UrlHeader, &quot;protected header&quot;);</b>
<b class="fc">&nbsp;        Map&lt;String, ?&gt; m = deserialize(Streams.of(headerBytes), &quot;protected header&quot;);</b>
&nbsp;        Header header;
&nbsp;        try {
<b class="fc">&nbsp;            header = tokenized.createHeader(m);</b>
<b class="fc">&nbsp;        } catch (Exception e) {</b>
<b class="fc">&nbsp;            String msg = &quot;Invalid protected header: &quot; + e.getMessage();</b>
<b class="fc">&nbsp;            throw new MalformedJwtException(msg, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // https://tools.ietf.org/html/rfc7515#section-10.7 , second-to-last bullet point, note the use of &#39;always&#39;:
&nbsp;        //
&nbsp;        //   *  Require that the &quot;alg&quot; Header Parameter be carried in the JWS
&nbsp;        //      Protected Header.  (This is always the case when using the JWS
&nbsp;        //      Compact Serialization and is the approach taken by CMS [RFC6211].)
&nbsp;        //
<b class="fc">&nbsp;        final String alg = Strings.clean(header.getAlgorithm());</b>
<b class="fc">&nbsp;        if (!Strings.hasText(alg)) {</b>
<b class="fc">&nbsp;            String msg = tokenized instanceof TokenizedJwe ? MISSING_JWE_ALG_MSG : MISSING_JWS_ALG_MSG;</b>
<b class="fc">&nbsp;            throw new MalformedJwtException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        final boolean unsecured = Jwts.SIG.NONE.getId().equalsIgnoreCase(alg);</b>
&nbsp;
<b class="fc">&nbsp;        final CharSequence base64UrlDigest = tokenized.getDigest();</b>
<b class="fc">&nbsp;        final boolean hasDigest = Strings.hasText(base64UrlDigest);</b>
<b class="fc">&nbsp;        if (unsecured) {</b>
<b class="fc">&nbsp;            if (tokenized instanceof TokenizedJwe) {</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(JWE_NONE_MSG);</b>
&nbsp;            }
&nbsp;            // Unsecured JWTs are disabled by default per the RFC:
<b class="fc">&nbsp;            if (!this.unsecured) {</b>
<b class="fc">&nbsp;                String msg = UNSECURED_DISABLED_MSG_PREFIX + header;</b>
<b class="fc">&nbsp;                throw new UnsupportedJwtException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (hasDigest) {</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(JWS_NONE_SIG_MISMATCH_MSG);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (header.containsKey(DefaultProtectedHeader.CRIT.getId())) {</b>
<b class="fc">&nbsp;                String msg = String.format(CRIT_UNSECURED_MSG, header);</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (!hasDigest) { // something other than &#39;none&#39;.  Must have a digest component:</b>
<b class="fc">&nbsp;            String fmt = tokenized instanceof TokenizedJwe ? MISSING_JWE_DIGEST_MSG_FMT : MISSING_JWS_DIGEST_MSG_FMT;</b>
<b class="fc">&nbsp;            String msg = String.format(fmt, alg);</b>
<b class="fc">&nbsp;            throw new MalformedJwtException(msg);</b>
&nbsp;        }
&nbsp;        // ----- crit assertions -----
<b class="fc">&nbsp;        if (header instanceof ProtectedHeader) {</b>
<b class="fc">&nbsp;            Set&lt;String&gt; crit = Collections.nullSafe(((ProtectedHeader) header).getCritical());</b>
<b class="fc">&nbsp;            Set&lt;String&gt; supportedCrit = this.critical;</b>
<b class="fc">&nbsp;            String b64Id = DefaultJwsHeader.B64.getId();</b>
<b class="pc">&nbsp;            if (!unencodedPayload.isEmpty() &amp;&amp; !this.critical.contains(b64Id)) {</b>
&nbsp;                // The application developer explicitly indicates they&#39;re using a B64 payload, so
&nbsp;                // ensure that the B64 crit header is supported, even if they forgot to configure it on the
&nbsp;                // parser builder:
<b class="fc">&nbsp;                supportedCrit = new LinkedHashSet&lt;&gt;(Collections.size(this.critical) + 1);</b>
<b class="fc">&nbsp;                supportedCrit.add(DefaultJwsHeader.B64.getId());</b>
<b class="fc">&nbsp;                supportedCrit.addAll(this.critical);</b>
&nbsp;            }
&nbsp;            // assert any values per https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.11:
<b class="fc">&nbsp;            for (String name : crit) {</b>
<b class="fc">&nbsp;                if (!header.containsKey(name)) {</b>
<b class="fc">&nbsp;                    String msg = String.format(CRIT_MISSING_MSG, name, name, header);</b>
<b class="fc">&nbsp;                    throw new MalformedJwtException(msg);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!supportedCrit.contains(name)) {</b>
<b class="fc">&nbsp;                    String msg = String.format(CRIT_UNSUPPORTED_MSG, name, name, header);</b>
<b class="fc">&nbsp;                    throw new UnsupportedJwtException(msg);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // =============== Payload =================
<b class="fc">&nbsp;        final CharSequence payloadToken = tokenized.getPayload();</b>
&nbsp;        Payload payload;
<b class="fc">&nbsp;        boolean integrityVerified = false; // only true after successful signature verification or AEAD decryption</b>
&nbsp;
&nbsp;        // check if b64 extension enabled:
<b class="fc">&nbsp;        final boolean payloadBase64UrlEncoded = !(header instanceof JwsHeader) || ((JwsHeader) header).isPayloadEncoded();</b>
<b class="fc">&nbsp;        if (payloadBase64UrlEncoded) {</b>
&nbsp;            // standard encoding, so decode it:
<b class="fc">&nbsp;            byte[] data = decode(tokenized.getPayload(), &quot;payload&quot;);</b>
<b class="fc">&nbsp;            payload = new Payload(data, header.getContentType());</b>
<b class="fc">&nbsp;        } else {</b>
&nbsp;            // The JWT uses the b64 extension, and we already know the parser supports that extension at this point
&nbsp;            // in the code execution path because of the ----- crit ----- assertions section above as well as the
&nbsp;            // (JwsHeader).isPayloadEncoded() check
<b class="fc">&nbsp;            if (Strings.hasText(payloadToken)) {</b>
&nbsp;                // we need to verify what was in the token, otherwise it&#39;d be a security issue if we ignored it
&nbsp;                // and assumed the (likely safe) unencodedPayload value instead:
<b class="fc">&nbsp;                payload = new Payload(payloadToken, header.getContentType());</b>
&nbsp;            } else {
&nbsp;                //no payload token (a detached payload), so we need to ensure that they&#39;ve specified the payload value:
<b class="fc">&nbsp;                if (unencodedPayload.isEmpty()) {</b>
<b class="fc">&nbsp;                    String msg = String.format(B64_MISSING_PAYLOAD, header);</b>
<b class="fc">&nbsp;                    throw new SignatureException(msg);</b>
&nbsp;                }
&nbsp;                // otherwise, use the specified payload:
<b class="fc">&nbsp;                payload = unencodedPayload;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (tokenized instanceof TokenizedJwe &amp;&amp; payload.isEmpty()) {</b>
&nbsp;            // Only JWS payload can be empty per https://github.com/jwtk/jjwt/pull/540
<b class="fc">&nbsp;            String msg = &quot;Compact JWE strings MUST always contain a payload (ciphertext).&quot;;</b>
<b class="fc">&nbsp;            throw new MalformedJwtException(msg);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte[] iv = null;</b>
<b class="fc">&nbsp;        byte[] tag = null;</b>
<b class="fc">&nbsp;        if (tokenized instanceof TokenizedJwe) {</b>
&nbsp;
<b class="fc">&nbsp;            TokenizedJwe tokenizedJwe = (TokenizedJwe) tokenized;</b>
<b class="fc">&nbsp;            JweHeader jweHeader = Assert.stateIsInstance(JweHeader.class, header, &quot;Not a JweHeader. &quot;);</b>
&nbsp;
<b class="fc">&nbsp;            byte[] cekBytes = Bytes.EMPTY; //ignored unless using an encrypted key algorithm</b>
<b class="fc">&nbsp;            CharSequence base64Url = tokenizedJwe.getEncryptedKey();</b>
<b class="fc">&nbsp;            if (Strings.hasText(base64Url)) {</b>
<b class="fc">&nbsp;                cekBytes = decode(base64Url, &quot;JWE encrypted key&quot;);</b>
<b class="fc">&nbsp;                if (Bytes.isEmpty(cekBytes)) {</b>
<b class="fc">&nbsp;                    String msg = &quot;Compact JWE string represents an encrypted key, but the key is empty.&quot;;</b>
<b class="fc">&nbsp;                    throw new MalformedJwtException(msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            base64Url = tokenizedJwe.getIv();</b>
<b class="fc">&nbsp;            if (Strings.hasText(base64Url)) {</b>
<b class="fc">&nbsp;                iv = decode(base64Url, &quot;JWE Initialization Vector&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (Bytes.isEmpty(iv)) {</b>
<b class="fc">&nbsp;                String msg = &quot;Compact JWE strings must always contain an Initialization Vector.&quot;;</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(msg);</b>
&nbsp;            }
&nbsp;
&nbsp;            // The AAD (Additional Authenticated Data) scheme for compact JWEs is to use the ASCII bytes of the
&nbsp;            // raw base64url text as the AAD, and NOT the base64url-decoded bytes per
&nbsp;            // https://www.rfc-editor.org/rfc/rfc7516.html#section-5.1, Step 14.
<b class="fc">&nbsp;            ByteBuffer buf = StandardCharsets.US_ASCII.encode(Strings.wrap(base64UrlHeader));</b>
<b class="fc">&nbsp;            final byte[] aadBytes = new byte[buf.remaining()];</b>
<b class="fc">&nbsp;            buf.get(aadBytes);</b>
<b class="fc">&nbsp;            InputStream aad = Streams.of(aadBytes);</b>
&nbsp;
<b class="fc">&nbsp;            base64Url = base64UrlDigest;</b>
&nbsp;            //guaranteed to be non-empty via the `alg` + digest check above:
<b class="fc">&nbsp;            Assert.hasText(base64Url, &quot;JWE AAD Authentication Tag cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;            tag = decode(base64Url, &quot;JWE AAD Authentication Tag&quot;);</b>
<b class="fc">&nbsp;            if (Bytes.isEmpty(tag)) {</b>
<b class="fc">&nbsp;                String msg = &quot;Compact JWE strings must always contain an AAD Authentication Tag.&quot;;</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(msg);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            String enc = jweHeader.getEncryptionAlgorithm();</b>
<b class="fc">&nbsp;            if (!Strings.hasText(enc)) {</b>
<b class="fc">&nbsp;                throw new MalformedJwtException(MISSING_ENC_MSG);</b>
&nbsp;            }
<b class="fc">&nbsp;            final AeadAlgorithm encAlg = this.encAlgs.apply(jweHeader);</b>
<b class="fc">&nbsp;            Assert.stateNotNull(encAlg, &quot;JWE Encryption Algorithm cannot be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            @SuppressWarnings(&quot;rawtypes&quot;) final KeyAlgorithm keyAlg = this.keyAlgs.apply(jweHeader);</b>
<b class="fc">&nbsp;            Assert.stateNotNull(keyAlg, &quot;JWE Key Algorithm cannot be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            Key key = this.keyLocator.locate(jweHeader);</b>
<b class="fc">&nbsp;            if (key == null) {</b>
<b class="fc">&nbsp;                String msg = &quot;Cannot decrypt JWE payload: unable to locate key for JWE with header: &quot; + jweHeader;</b>
<b class="fc">&nbsp;                throw new UnsupportedJwtException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (key instanceof PublicKey) {</b>
<b class="fc">&nbsp;                throw new InvalidKeyException(PUB_KEY_DECRYPT_MSG);</b>
&nbsp;            }
&nbsp;
&nbsp;            // extract key-specific provider if necessary;
<b class="fc">&nbsp;            Provider provider = ProviderKey.getProvider(key, this.provider);</b>
<b class="fc">&nbsp;            key = ProviderKey.getKey(key); // this must be called after ProviderKey.getProvider</b>
<b class="fc">&nbsp;            DecryptionKeyRequest&lt;Key&gt; request =</b>
&nbsp;                    new DefaultDecryptionKeyRequest&lt;&gt;(cekBytes, provider, null, jweHeader, encAlg, key);
<b class="fc">&nbsp;            final SecretKey cek = keyAlg.getDecryptionKey(request);</b>
<b class="fc">&nbsp;            if (cek == null) {</b>
<b class="fc">&nbsp;                String msg = &quot;The &#39;&quot; + keyAlg.getId() + &quot;&#39; JWE key algorithm did not return a decryption key. &quot; +</b>
<b class="fc">&nbsp;                        &quot;Unable to perform &#39;&quot; + encAlg.getId() + &quot;&#39; decryption.&quot;;</b>
<b class="fc">&nbsp;                throw new IllegalStateException(msg);</b>
&nbsp;            }
&nbsp;
&nbsp;            // During decryption, the available Provider applies to the KeyAlgorithm, not the AeadAlgorithm, mostly
&nbsp;            // because all JVMs support the standard AeadAlgorithms (especially with BouncyCastle in the classpath).
&nbsp;            // As such, the provider here is intentionally omitted (null):
&nbsp;            // TODO: add encProvider(Provider) builder method that applies to this request only?
<b class="fc">&nbsp;            InputStream ciphertext = payload.toInputStream();</b>
<b class="fc">&nbsp;            ByteArrayOutputStream plaintext = new ByteArrayOutputStream(8192);</b>
<b class="fc">&nbsp;            DecryptAeadRequest dreq = new DefaultDecryptAeadRequest(ciphertext, cek, aad, iv, tag);</b>
<b class="fc">&nbsp;            encAlg.decrypt(dreq, plaintext);</b>
<b class="fc">&nbsp;            payload = new Payload(plaintext.toByteArray(), header.getContentType());</b>
&nbsp;
<b class="fc">&nbsp;            integrityVerified = true; // AEAD performs integrity verification, so no exception = verified</b>
&nbsp;
<b class="fc">&nbsp;        } else if (hasDigest &amp;&amp; this.signingKeyResolver == null) { //TODO: for 1.0, remove the == null check</b>
&nbsp;            // not using a signing key resolver, so we can verify the signature before reading the payload, which is
&nbsp;            // always safer:
<b class="fc">&nbsp;            JwsHeader jwsHeader = Assert.stateIsInstance(JwsHeader.class, header, &quot;Not a JwsHeader. &quot;);</b>
<b class="fc">&nbsp;            verifySignature(tokenized, jwsHeader, alg, new LocatingKeyResolver(this.keyLocator), null, payload);</b>
<b class="fc">&nbsp;            integrityVerified = true; // no exception means signature verified</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final CompressionAlgorithm compressionAlgorithm = zipAlgs.apply(header);</b>
<b class="fc">&nbsp;        if (compressionAlgorithm != null) {</b>
<b class="fc">&nbsp;            if (!integrityVerified) {</b>
<b class="fc">&nbsp;                if (!payloadBase64UrlEncoded) {</b>
<b class="fc">&nbsp;                    String msg = String.format(B64_DECOMPRESSION_MSG, compressionAlgorithm.getId());</b>
<b class="fc">&nbsp;                    throw new UnsupportedJwtException(msg);</b>
<b class="fc">&nbsp;                } else if (!unsecuredDecompression) {</b>
<b class="fc">&nbsp;                    String msg = String.format(UNPROTECTED_DECOMPRESSION_MSG, compressionAlgorithm.getId());</b>
<b class="fc">&nbsp;                    throw new UnsupportedJwtException(msg);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            payload = payload.decompress(compressionAlgorithm);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Claims claims = null;</b>
<b class="fc">&nbsp;        byte[] payloadBytes = payload.getBytes();</b>
<b class="fc">&nbsp;        if (payload.isConsumable()) {</b>
&nbsp;
<b class="fc">&nbsp;            InputStream in = payload.toInputStream();</b>
&nbsp;
<b class="fc">&nbsp;            if (!hasContentType(header)) {   // If there is a content type set, then the application using JJWT is expected</b>
&nbsp;                //                          to convert the byte payload themselves based on this content type
&nbsp;                //                          https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.10 :
&nbsp;                //
&nbsp;                //                          &quot;This parameter is ignored by JWS implementations; any processing of this
&nbsp;                //                          parameter is performed by the JWS application.&quot;
&nbsp;                //
<b class="fc">&nbsp;                Map&lt;String, ?&gt; claimsMap = null;</b>
&nbsp;                try {
&nbsp;                    // if deserialization fails, we&#39;ll need to rewind to convert to a byte array.  So if
&nbsp;                    // mark/reset isn&#39;t possible, we&#39;ll need to buffer:
<b class="fc">&nbsp;                    if (!in.markSupported()) {</b>
<b class="fc">&nbsp;                        in = new BufferedInputStream(in);</b>
<b class="fc">&nbsp;                        in.mark(0);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    claimsMap = deserialize(new UncloseableInputStream(in) /* Don&#39;t close in case we need to rewind */, &quot;claims&quot;);</b>
<b class="fc">&nbsp;                } catch (DeserializationException | MalformedJwtException ignored) { // not JSON, treat it as a byte[]</b>
&nbsp;//                String msg = &quot;Invalid claims: &quot; + e.getMessage();
&nbsp;//                throw new MalformedJwtException(msg, e);
&nbsp;                } finally {
<b class="fc">&nbsp;                    Streams.reset(in);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (claimsMap != null) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        claims = new DefaultClaims(claimsMap);</b>
<b class="fc">&nbsp;                    } catch (Throwable t) {</b>
<b class="fc">&nbsp;                        String msg = &quot;Invalid claims: &quot; + t.getMessage();</b>
<b class="fc">&nbsp;                        throw new MalformedJwtException(msg);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (claims == null) {</b>
&nbsp;                // consumable, but not claims, so convert to byte array:
<b class="fc">&nbsp;                payloadBytes = Streams.bytes(in, &quot;Unable to convert payload to byte array.&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        Jwt&lt;?, ?&gt; jwt;
<b class="fc">&nbsp;        Object body = claims != null ? claims : payloadBytes;</b>
<b class="fc">&nbsp;        if (header instanceof JweHeader) {</b>
<b class="fc">&nbsp;            jwt = new DefaultJwe&lt;&gt;((JweHeader) header, body, iv, tag);</b>
<b class="fc">&nbsp;        } else if (hasDigest) {</b>
<b class="fc">&nbsp;            JwsHeader jwsHeader = Assert.isInstanceOf(JwsHeader.class, header, &quot;JwsHeader required.&quot;);</b>
<b class="fc">&nbsp;            jwt = new DefaultJws&lt;&gt;(jwsHeader, body, base64UrlDigest.toString());</b>
<b class="fc">&nbsp;        } else {</b>
&nbsp;            //noinspection rawtypes
<b class="fc">&nbsp;            jwt = new DefaultJwt(header, body);</b>
&nbsp;        }
&nbsp;
&nbsp;        // =============== Signature =================
<b class="fc">&nbsp;        if (hasDigest &amp;&amp; signingKeyResolver != null) { // TODO: remove for 1.0</b>
&nbsp;            // A SigningKeyResolver has been configured, and due to it&#39;s API, we have to verify the signature after
&nbsp;            // parsing the body.  This can be a security risk, so it needs to be removed before 1.0
<b class="fc">&nbsp;            JwsHeader jwsHeader = Assert.stateIsInstance(JwsHeader.class, header, &quot;Not a JwsHeader. &quot;);</b>
<b class="fc">&nbsp;            verifySignature(tokenized, jwsHeader, alg, this.signingKeyResolver, claims, payload);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final boolean allowSkew = this.allowedClockSkewMillis &gt; 0;</b>
&nbsp;
&nbsp;        //since 0.3:
<b class="fc">&nbsp;        if (claims != null) {</b>
&nbsp;
<b class="fc">&nbsp;            final Date now = this.clock.now();</b>
<b class="fc">&nbsp;            long nowTime = now.getTime();</b>
&nbsp;
&nbsp;            // https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1.4
&nbsp;            // token MUST NOT be accepted on or after any specified exp time:
<b class="fc">&nbsp;            Date exp = claims.getExpiration();</b>
<b class="fc">&nbsp;            if (exp != null) {</b>
&nbsp;
<b class="fc">&nbsp;                long maxTime = nowTime - this.allowedClockSkewMillis;</b>
<b class="fc">&nbsp;                Date max = allowSkew ? new Date(maxTime) : now;</b>
<b class="fc">&nbsp;                if (max.after(exp)) {</b>
<b class="fc">&nbsp;                    String expVal = DateFormats.formatIso8601(exp, true);</b>
<b class="fc">&nbsp;                    String nowVal = DateFormats.formatIso8601(now, true);</b>
&nbsp;
<b class="fc">&nbsp;                    long differenceMillis = nowTime - exp.getTime();</b>
&nbsp;
<b class="fc">&nbsp;                    String msg = &quot;JWT expired &quot; + differenceMillis + &quot; milliseconds ago at &quot; + expVal + &quot;. &quot; +</b>
&nbsp;                            &quot;Current time: &quot; + nowVal + &quot;. Allowed clock skew: &quot; +
&nbsp;                            this.allowedClockSkewMillis + &quot; milliseconds.&quot;;
<b class="fc">&nbsp;                    throw new ExpiredJwtException(header, claims, msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1.5
&nbsp;            // token MUST NOT be accepted before any specified nbf time:
<b class="fc">&nbsp;            Date nbf = claims.getNotBefore();</b>
<b class="fc">&nbsp;            if (nbf != null) {</b>
&nbsp;
<b class="fc">&nbsp;                long minTime = nowTime + this.allowedClockSkewMillis;</b>
<b class="fc">&nbsp;                Date min = allowSkew ? new Date(minTime) : now;</b>
<b class="fc">&nbsp;                if (min.before(nbf)) {</b>
<b class="fc">&nbsp;                    String nbfVal = DateFormats.formatIso8601(nbf, true);</b>
<b class="fc">&nbsp;                    String nowVal = DateFormats.formatIso8601(now, true);</b>
&nbsp;
<b class="fc">&nbsp;                    long differenceMillis = nbf.getTime() - nowTime;</b>
&nbsp;
<b class="fc">&nbsp;                    String msg = &quot;JWT early by &quot; + differenceMillis + &quot; milliseconds before &quot; + nbfVal +</b>
&nbsp;                            &quot;. Current time: &quot; + nowVal + &quot;. Allowed clock skew: &quot; +
&nbsp;                            this.allowedClockSkewMillis + &quot; milliseconds.&quot;;
<b class="fc">&nbsp;                    throw new PrematureJwtException(header, claims, msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            validateExpectedClaims(header, claims);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return jwt;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 0.10.0
&nbsp;     */
&nbsp;    private static Object normalize(Object o) {
<b class="fc">&nbsp;        if (o instanceof Integer) {</b>
<b class="fc">&nbsp;            o = ((Integer) o).longValue();</b>
&nbsp;        }
<b class="fc">&nbsp;        return o;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void validateExpectedClaims(Header header, Claims claims) {
&nbsp;
<b class="fc">&nbsp;        final Claims expected = expectedClaims.build();</b>
&nbsp;
<b class="fc">&nbsp;        for (String expectedClaimName : expected.keySet()) {</b>
&nbsp;
<b class="fc">&nbsp;            Object expectedClaimValue = normalize(expected.get(expectedClaimName));</b>
<b class="fc">&nbsp;            Object actualClaimValue = normalize(claims.get(expectedClaimName));</b>
&nbsp;
<b class="fc">&nbsp;            if (expectedClaimValue instanceof Date) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    actualClaimValue = claims.get(expectedClaimName, Date.class);</b>
<b class="fc">&nbsp;                } catch (Exception e) {</b>
<b class="fc">&nbsp;                    String msg = &quot;JWT Claim &#39;&quot; + expectedClaimName + &quot;&#39; was expected to be a Date, but its value &quot; +</b>
&nbsp;                            &quot;cannot be converted to a Date using current heuristics.  Value: &quot; + actualClaimValue;
<b class="fc">&nbsp;                    throw new IncorrectClaimException(header, claims, expectedClaimName, expectedClaimValue, msg);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (actualClaimValue == null) {</b>
<b class="fc">&nbsp;                boolean collection = expectedClaimValue instanceof Collection;</b>
<b class="fc">&nbsp;                String msg = &quot;Missing &#39;&quot; + expectedClaimName + &quot;&#39; claim. Expected value&quot;;</b>
<b class="fc">&nbsp;                if (collection) {</b>
<b class="fc">&nbsp;                    msg += &quot;s: &quot; + expectedClaimValue;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    msg += &quot;: &quot; + expectedClaimValue;</b>
&nbsp;                }
<b class="fc">&nbsp;                throw new MissingClaimException(header, claims, expectedClaimName, expectedClaimValue, msg);</b>
<b class="fc">&nbsp;            } else if (expectedClaimValue instanceof Collection) {</b>
<b class="fc">&nbsp;                Collection&lt;?&gt; expectedValues = (Collection&lt;?&gt;) expectedClaimValue;</b>
<b class="fc">&nbsp;                Collection&lt;?&gt; actualValues = actualClaimValue instanceof Collection ? (Collection&lt;?&gt;) actualClaimValue :</b>
<b class="fc">&nbsp;                        Collections.setOf(actualClaimValue);</b>
<b class="fc">&nbsp;                for (Object expectedValue : expectedValues) {</b>
<b class="fc">&nbsp;                    if (!Collections.contains(actualValues.iterator(), expectedValue)) {</b>
<b class="fc">&nbsp;                        String msg = String.format(MISSING_EXPECTED_CLAIM_VALUE_MESSAGE_TEMPLATE,</b>
&nbsp;                                expectedValue, expectedClaimName, actualValues);
<b class="fc">&nbsp;                        throw new IncorrectClaimException(header, claims, expectedClaimName, expectedClaimValue, msg);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            } else if (!expectedClaimValue.equals(actualClaimValue)) {</b>
<b class="fc">&nbsp;                String msg = String.format(INCORRECT_EXPECTED_CLAIM_MESSAGE_TEMPLATE,</b>
&nbsp;                        expectedClaimName, expectedClaimValue, actualClaimValue);
<b class="fc">&nbsp;                throw new IncorrectClaimException(header, claims, expectedClaimName, expectedClaimValue, msg);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T parse(CharSequence compact, JwtHandler&lt;T&gt; handler) {
<b class="fc">&nbsp;        return parse(compact, Payload.EMPTY).accept(handler);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Jwt&lt;?, ?&gt; parse(CharSequence compact, Payload unencodedPayload) {
<b class="fc">&nbsp;        Assert.hasText(compact, &quot;JWT String argument cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        return parse(new CharSequenceReader(compact), unencodedPayload);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwt&lt;Header, byte[]&gt; parseContentJwt(CharSequence jwt) {
<b class="fc">&nbsp;        return parse(jwt).accept(Jwt.UNSECURED_CONTENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwt&lt;Header, Claims&gt; parseClaimsJwt(CharSequence jwt) {
<b class="fc">&nbsp;        return parse(jwt).accept(Jwt.UNSECURED_CLAIMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;byte[]&gt; parseContentJws(CharSequence jws) {
<b class="fc">&nbsp;        return parseSignedContent(jws);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;Claims&gt; parseClaimsJws(CharSequence jws) {
<b class="fc">&nbsp;        return parseSignedClaims(jws);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwt&lt;Header, byte[]&gt; parseUnsecuredContent(CharSequence jwt) throws JwtException, IllegalArgumentException {
<b class="fc">&nbsp;        return parse(jwt).accept(Jwt.UNSECURED_CONTENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwt&lt;Header, Claims&gt; parseUnsecuredClaims(CharSequence jwt) throws JwtException, IllegalArgumentException {
<b class="fc">&nbsp;        return parse(jwt).accept(Jwt.UNSECURED_CLAIMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;byte[]&gt; parseSignedContent(CharSequence compact) {
<b class="fc">&nbsp;        return parse(compact).accept(Jws.CONTENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws, Payload unencodedPayload) {
<b class="fc">&nbsp;        return parse(jws, unencodedPayload).accept(Jws.CONTENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;Claims&gt; parseSignedClaims(CharSequence compact) {
<b class="fc">&nbsp;        return parse(compact).accept(Jws.CLAIMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws, Payload unencodedPayload) {
<b class="fc">&nbsp;        unencodedPayload.setClaimsExpected(true);</b>
<b class="fc">&nbsp;        return parse(jws, unencodedPayload).accept(Jws.CLAIMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws, byte[] unencodedPayload) {
<b class="fc">&nbsp;        Assert.notEmpty(unencodedPayload, &quot;unencodedPayload argument cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        return parseSignedContent(jws, new Payload(unencodedPayload, null));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Payload payloadFor(InputStream in) {
<b class="fc">&nbsp;        if (in instanceof BytesInputStream) {</b>
<b class="fc">&nbsp;            byte[] data = Streams.bytes(in, &quot;Unable to obtain payload InputStream bytes.&quot;);</b>
<b class="fc">&nbsp;            return new Payload(data, null);</b>
&nbsp;        }
&nbsp;        //if (in.markSupported()) in.mark(0);
<b class="fc">&nbsp;        return new Payload(in, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;byte[]&gt; parseSignedContent(CharSequence jws, InputStream unencodedPayload) {
<b class="fc">&nbsp;        Assert.notNull(unencodedPayload, &quot;unencodedPayload InputStream cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return parseSignedContent(jws, payloadFor(unencodedPayload));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws, byte[] unencodedPayload) {
<b class="fc">&nbsp;        Assert.notEmpty(unencodedPayload, &quot;unencodedPayload argument cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        return parseSignedClaims(jws, new Payload(unencodedPayload, null));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jws&lt;Claims&gt; parseSignedClaims(CharSequence jws, InputStream unencodedPayload) {
<b class="fc">&nbsp;        Assert.notNull(unencodedPayload, &quot;unencodedPayload InputStream cannot be null.&quot;);</b>
<b class="fc">&nbsp;        byte[] bytes = Streams.bytes(unencodedPayload,</b>
&nbsp;                &quot;Unable to obtain Claims bytes from unencodedPayload InputStream&quot;);
<b class="fc">&nbsp;        return parseSignedClaims(jws, new Payload(bytes, null));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwe&lt;byte[]&gt; parseEncryptedContent(CharSequence compact) throws JwtException {
<b class="fc">&nbsp;        return parse(compact).accept(Jwe.CONTENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jwe&lt;Claims&gt; parseEncryptedClaims(CharSequence compact) throws JwtException {
<b class="fc">&nbsp;        return parse(compact).accept(Jwe.CLAIMS);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] decode(CharSequence base64UrlEncoded, String name) {
&nbsp;        try {
<b class="fc">&nbsp;            InputStream decoding = this.decoder.decode(Streams.of(Strings.utf8(base64UrlEncoded)));</b>
<b class="fc">&nbsp;            return Streams.bytes(decoding, &quot;Unable to Base64Url-decode input.&quot;);</b>
<b class="fc">&nbsp;        } catch (Throwable t) {</b>
&nbsp;            // Don&#39;t disclose potentially-sensitive information per https://github.com/jwtk/jjwt/issues/824:
<b class="fc">&nbsp;            String value = &quot;payload&quot;.equals(name) ? RedactedSupplier.REDACTED_VALUE : base64UrlEncoded.toString();</b>
<b class="fc">&nbsp;            String msg = &quot;Invalid Base64Url &quot; + name + &quot;: &quot; + value;</b>
<b class="fc">&nbsp;            throw new MalformedJwtException(msg, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected Map&lt;String, ?&gt; deserialize(InputStream in, final String name) {
&nbsp;        try {
<b class="fc">&nbsp;            Reader reader = Streams.reader(in);</b>
<b class="fc">&nbsp;            JsonObjectDeserializer deserializer = new JsonObjectDeserializer(this.deserializer, name);</b>
<b class="fc">&nbsp;            return deserializer.apply(reader);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Objects.nullSafeClose(in);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
