


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Base64</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.io</a>
</div>

<h1>Coverage Summary for Class: Base64 (io.jsonwebtoken.io)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Base64</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (71/72)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (90/90)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.io;
&nbsp;
&nbsp;import java.util.Arrays;
&nbsp;
&nbsp;/**
&nbsp; * A very fast and memory efficient class to encode and decode to and from BASE64 or BASE64URL in full accordance
&nbsp; * with &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;p&gt;Based initially on MigBase64 with continued modifications for Base64 URL support and JDK-standard code formatting.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;This encode/decode algorithm doesn&#39;t create any temporary arrays as many other codecs do, it only
&nbsp; * allocates the resulting array. This produces less garbage and it is possible to handle arrays twice
&nbsp; * as large as algorithms that create a temporary array.&lt;/p&gt;
&nbsp; *
&nbsp; * &lt;p&gt;There is also a &quot;fast&quot; version of all decode methods that works the same way as the normal ones, but
&nbsp; * has a few demands on the decoded input. Normally though, these fast versions should be used if the source if
&nbsp; * the input is known and it hasn&#39;t bee tampered with.&lt;/p&gt;
&nbsp; *
&nbsp; * @author Mikael Grev
&nbsp; * @author Les Hazlewood
&nbsp; * @since 0.10.0
&nbsp; */
&nbsp;@SuppressWarnings(&quot;Duplicates&quot;)
&nbsp;final class Base64 { //final and package-protected on purpose
&nbsp;
<b class="fc">&nbsp;    private static final char[] BASE64_ALPHABET = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.toCharArray();</b>
<b class="fc">&nbsp;    private static final char[] BASE64URL_ALPHABET = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;.toCharArray();</b>
<b class="fc">&nbsp;    private static final int[] BASE64_IALPHABET = new int[256];</b>
<b class="fc">&nbsp;    private static final int[] BASE64URL_IALPHABET = new int[256];</b>
<b class="fc">&nbsp;    private static final int IALPHABET_MAX_INDEX = BASE64_IALPHABET.length - 1;</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        Arrays.fill(BASE64_IALPHABET, -1);</b>
<b class="fc">&nbsp;        System.arraycopy(BASE64_IALPHABET, 0, BASE64URL_IALPHABET, 0, BASE64_IALPHABET.length);</b>
<b class="fc">&nbsp;        for (int i = 0, iS = BASE64_ALPHABET.length; i &lt; iS; i++) {</b>
<b class="fc">&nbsp;            BASE64_IALPHABET[BASE64_ALPHABET[i]] = i;</b>
<b class="fc">&nbsp;            BASE64URL_IALPHABET[BASE64URL_ALPHABET[i]] = i;</b>
&nbsp;        }
<b class="fc">&nbsp;        BASE64_IALPHABET[&#39;=&#39;] = 0;</b>
<b class="fc">&nbsp;        BASE64URL_IALPHABET[&#39;=&#39;] = 0;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static final Base64 DEFAULT = new Base64(false);</b>
<b class="fc">&nbsp;    static final Base64 URL_SAFE = new Base64(true);</b>
&nbsp;
&nbsp;    private final boolean urlsafe;
&nbsp;    private final char[] ALPHABET;
&nbsp;    private final int[] IALPHABET;
&nbsp;
<b class="fc">&nbsp;    private Base64(boolean urlsafe) {</b>
<b class="fc">&nbsp;        this.urlsafe = urlsafe;</b>
<b class="fc">&nbsp;        this.ALPHABET = urlsafe ? BASE64URL_ALPHABET : BASE64_ALPHABET;</b>
<b class="fc">&nbsp;        this.IALPHABET = urlsafe ? BASE64URL_IALPHABET : BASE64_IALPHABET;</b>
&nbsp;    }
&nbsp;
&nbsp;    // ****************************************************************************************
&nbsp;    // *  char[] version
&nbsp;    // ****************************************************************************************
&nbsp;
&nbsp;    private String getName() {
<b class="fc">&nbsp;        return urlsafe ? &quot;base64url&quot; : &quot;base64&quot;; // RFC 4648 codec names are all lowercase</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a raw byte array into a BASE64 &lt;code&gt;char[]&lt;/code&gt; representation in accordance with RFC 2045.
&nbsp;     *
&nbsp;     * @param sArr    The bytes to convert. If &lt;code&gt;null&lt;/code&gt; or length 0 an empty array will be returned.
&nbsp;     * @param lineSep Optional &quot;\r\n&quot; after 76 characters, unless end of file.&lt;br&gt;
&nbsp;     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
&nbsp;     *                little faster.
&nbsp;     * @return A BASE64 encoded array. Never &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    private char[] encodeToChar(byte[] sArr, boolean lineSep) {
&nbsp;
&nbsp;        // Check special case
<b class="fc">&nbsp;        int sLen = sArr != null ? sArr.length : 0;</b>
<b class="fc">&nbsp;        if (sLen == 0) {</b>
<b class="fc">&nbsp;            return new char[0];</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int eLen = (sLen / 3) * 3; // # of bytes that can encode evenly into 24-bit chunks</b>
<b class="fc">&nbsp;        int left = sLen - eLen;    // # of bytes that remain after 24-bit chunking. Always 0, 1 or 2</b>
&nbsp;
<b class="fc">&nbsp;        int cCnt = (((sLen - 1) / 3 + 1) &lt;&lt; 2); // # of base64-encoded characters including padding</b>
<b class="fc">&nbsp;        int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 &lt;&lt; 1 : 0); // Length of returned char array with padding and any line separators</b>
&nbsp;
<b class="fc">&nbsp;        int padCount = 0;</b>
<b class="fc">&nbsp;        if (left == 2) {</b>
<b class="fc">&nbsp;            padCount = 1;</b>
<b class="fc">&nbsp;        } else if (left == 1) {</b>
<b class="fc">&nbsp;            padCount = 2;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        char[] dArr = new char[urlsafe ? (dLen - padCount) : dLen];</b>
&nbsp;
&nbsp;        // Encode even 24-bits
<b class="fc">&nbsp;        for (int s = 0, d = 0, cc = 0; s &lt; eLen; ) {</b>
&nbsp;
&nbsp;            // Copy next three bytes into lower 24 bits of int, paying attention to sign.
<b class="fc">&nbsp;            int i = (sArr[s++] &amp; 0xff) &lt;&lt; 16 | (sArr[s++] &amp; 0xff) &lt;&lt; 8 | (sArr[s++] &amp; 0xff);</b>
&nbsp;
&nbsp;            // Encode the int into four chars
<b class="fc">&nbsp;            dArr[d++] = ALPHABET[(i &gt;&gt;&gt; 18) &amp; 0x3f];</b>
<b class="fc">&nbsp;            dArr[d++] = ALPHABET[(i &gt;&gt;&gt; 12) &amp; 0x3f];</b>
<b class="fc">&nbsp;            dArr[d++] = ALPHABET[(i &gt;&gt;&gt; 6) &amp; 0x3f];</b>
<b class="fc">&nbsp;            dArr[d++] = ALPHABET[i &amp; 0x3f];</b>
&nbsp;
&nbsp;            // Add optional line separator
<b class="pc">&nbsp;            if (lineSep &amp;&amp; ++cc == 19 &amp;&amp; d &lt; dLen - 2) {</b>
<b class="fc">&nbsp;                dArr[d++] = &#39;\r&#39;;</b>
<b class="fc">&nbsp;                dArr[d++] = &#39;\n&#39;;</b>
<b class="fc">&nbsp;                cc = 0;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Pad and encode last bits if source isn&#39;t even 24 bits.
<b class="fc">&nbsp;        if (left &gt; 0) {</b>
&nbsp;            // Prepare the int
<b class="fc">&nbsp;            int i = ((sArr[eLen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((sArr[sLen - 1] &amp; 0xff) &lt;&lt; 2) : 0);</b>
&nbsp;
&nbsp;            // Set last four chars
<b class="fc">&nbsp;            dArr[dLen - 4] = ALPHABET[i &gt;&gt; 12];</b>
<b class="fc">&nbsp;            dArr[dLen - 3] = ALPHABET[(i &gt;&gt;&gt; 6) &amp; 0x3f];</b>
&nbsp;            //dArr[dLen - 2] = left == 2 ? ALPHABET[i &amp; 0x3f] : &#39;=&#39;;
&nbsp;            //dArr[dLen - 1] = &#39;=&#39;;
<b class="fc">&nbsp;            if (left == 2) {</b>
<b class="fc">&nbsp;                dArr[dLen - 2] = ALPHABET[i &amp; 0x3f];</b>
<b class="fc">&nbsp;            } else if (!urlsafe) { // if not urlsafe, we need to include the padding characters</b>
<b class="fc">&nbsp;                dArr[dLen - 2] = &#39;=&#39;;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!urlsafe) { // include padding</b>
<b class="fc">&nbsp;                dArr[dLen - 1] = &#39;=&#39;;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return dArr;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Decodes a BASE64 encoded char array. All illegal characters will be ignored and can handle both arrays with
&nbsp;     * and without line separators.
&nbsp;     *
&nbsp;     * @param sArr The source array. &lt;code&gt;null&lt;/code&gt; or length 0 will return an empty array.
&nbsp;     * @return The decoded array of bytes. May be of length 0. Will be &lt;code&gt;null&lt;/code&gt; if the legal characters
&nbsp;     * (including &#39;=&#39;) isn&#39;t divideable by 4.  (I.e. definitely corrupted).
&nbsp;     *
&nbsp;    public final byte[] decode(char[] sArr) {
&nbsp;        // Check special case
&nbsp;        int sLen = sArr != null ? sArr.length : 0;
&nbsp;        if (sLen == 0) {
&nbsp;            return new byte[0];
&nbsp;        }
&nbsp;
&nbsp;        // Count illegal characters (including &#39;\r&#39;, &#39;\n&#39;) to know what size the returned array will be,
&nbsp;        // so we don&#39;t have to reallocate &amp; copy it later.
&nbsp;        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that&#39;s a bonus...)
&nbsp;        for (int i = 0; i &lt; sLen; i++) { // If input is &quot;pure&quot; (I.e. no line separators or illegal chars) base64 this loop can be commented out.
&nbsp;            if (IALPHABET[sArr[i]] &lt; 0) {
&nbsp;                sepCnt++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check so that legal chars (including &#39;=&#39;) are evenly divideable by 4 as specified in RFC 2045.
&nbsp;        if ((sLen - sepCnt) % 4 != 0) {
&nbsp;            return null;
&nbsp;        }
&nbsp;
&nbsp;        int pad = 0;
&nbsp;        for (int i = sLen; i &gt; 1 &amp;&amp; IALPHABET[sArr[--i]] &lt;= 0; ) {
&nbsp;            if (sArr[i] == &#39;=&#39;) {
&nbsp;                pad++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int len = ((sLen - sepCnt) * 6 &gt;&gt; 3) - pad;
&nbsp;
&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
&nbsp;
&nbsp;        for (int s = 0, d = 0; d &lt; len; ) {
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
&nbsp;            int i = 0;
&nbsp;            for (int j = 0; j &lt; 4; j++) {   // j only increased if a valid char was found.
&nbsp;                int c = IALPHABET[sArr[s++]];
&nbsp;                if (c &gt;= 0) {
&nbsp;                    i |= c &lt;&lt; (18 - j * 6);
&nbsp;                } else {
&nbsp;                    j--;
&nbsp;                }
&nbsp;            }
&nbsp;            // Add the bytes
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);
&nbsp;            if (d &lt; len) {
&nbsp;                dArr[d++] = (byte) (i &gt;&gt; 8);
&nbsp;                if (d &lt; len) {
&nbsp;                    dArr[d++] = (byte) i;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        return dArr;
&nbsp;    }
&nbsp;    */
&nbsp;
&nbsp;    private int ctoi(char c) {
<b class="fc">&nbsp;        int i = c &gt; IALPHABET_MAX_INDEX ? -1 : IALPHABET[c];</b>
<b class="fc">&nbsp;        if (i &lt; 0) {</b>
<b class="fc">&nbsp;            String msg = &quot;Illegal &quot; + getName() + &quot; character: &#39;&quot; + c + &quot;&#39;&quot;;</b>
<b class="fc">&nbsp;            throw new DecodingException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        return i;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Decodes a BASE64-encoded {@code CharSequence} that is known to be reasonably well formatted. The preconditions
&nbsp;     * are:&lt;br&gt;
&nbsp;     * + The sequence must have a line length of 76 chars OR no line separators at all (one line).&lt;br&gt;
&nbsp;     * + Line separator must be &quot;\r\n&quot;, as specified in RFC 2045
&nbsp;     * + The sequence must not contain illegal characters within the encoded string&lt;br&gt;
&nbsp;     * + The sequence CAN have illegal characters at the beginning and end, those will be dealt with appropriately.&lt;br&gt;
&nbsp;     *
&nbsp;     * @param seq The source sequence. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
&nbsp;     * @return The decoded array of bytes. May be of length 0.
&nbsp;     * @throws DecodingException on illegal input
&nbsp;     */
&nbsp;    byte[] decodeFast(CharSequence seq) throws DecodingException {
&nbsp;
&nbsp;        // Check special case
<b class="fc">&nbsp;        int sLen = seq != null ? seq.length() : 0;</b>
<b class="fc">&nbsp;        if (sLen == 0) {</b>
<b class="fc">&nbsp;            return new byte[0];</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.</b>
&nbsp;
&nbsp;        // Trim illegal chars from start
<b class="fc">&nbsp;        while (sIx &lt; eIx &amp;&amp; IALPHABET[seq.charAt(sIx)] &lt; 0) {</b>
<b class="fc">&nbsp;            sIx++;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Trim illegal chars from end
<b class="fc">&nbsp;        while (eIx &gt; 0 &amp;&amp; IALPHABET[seq.charAt(eIx)] &lt; 0) {</b>
<b class="fc">&nbsp;            eIx--;</b>
&nbsp;        }
&nbsp;
&nbsp;        // get the padding count (=) (0, 1 or 2)
<b class="fc">&nbsp;        int pad = seq.charAt(eIx) == &#39;=&#39; ? (seq.charAt(eIx - 1) == &#39;=&#39; ? 2 : 1) : 0;  // Count &#39;=&#39; at end.</b>
<b class="fc">&nbsp;        int cCnt = eIx - sIx + 1;   // Content count including possible separators</b>
<b class="fc">&nbsp;        int sepCnt = sLen &gt; 76 ? (seq.charAt(76) == &#39;\r&#39; ? cCnt / 78 : 0) &lt;&lt; 1 : 0;</b>
&nbsp;
<b class="fc">&nbsp;        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes</b>
<b class="fc">&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length</b>
&nbsp;
&nbsp;        // Decode all but the last 0 - 2 bytes.
<b class="fc">&nbsp;        int d = 0;</b>
<b class="fc">&nbsp;        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) {</b>
&nbsp;
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
<b class="fc">&nbsp;            int i = ctoi(seq.charAt(sIx++)) &lt;&lt; 18 | ctoi(seq.charAt(sIx++)) &lt;&lt; 12 | ctoi(seq.charAt(sIx++)) &lt;&lt; 6 | ctoi(seq.charAt(sIx++));</b>
&nbsp;
&nbsp;            // Add the bytes
<b class="fc">&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);</b>
<b class="fc">&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 8);</b>
<b class="fc">&nbsp;            dArr[d++] = (byte) i;</b>
&nbsp;
&nbsp;            // If line separator, jump over it.
<b class="fc">&nbsp;            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {</b>
<b class="fc">&nbsp;                sIx += 2;</b>
<b class="fc">&nbsp;                cc = 0;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (d &lt; len) {</b>
&nbsp;            // Decode last 1-3 bytes (incl &#39;=&#39;) into 1-3 bytes
<b class="fc">&nbsp;            int i = 0;</b>
<b class="fc">&nbsp;            for (int j = 0; sIx &lt;= eIx - pad; j++) {</b>
<b class="fc">&nbsp;                i |= ctoi(seq.charAt(sIx++)) &lt;&lt; (18 - j * 6);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            for (int r = 16; d &lt; len; r -= 8) {</b>
<b class="fc">&nbsp;                dArr[d++] = (byte) (i &gt;&gt; r);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return dArr;</b>
&nbsp;    }
&nbsp;
&nbsp;    // ****************************************************************************************
&nbsp;    // *  byte[] version
&nbsp;    // ****************************************************************************************
&nbsp;
&nbsp;    /*
&nbsp;     * Encodes a raw byte array into a BASE64 &lt;code&gt;byte[]&lt;/code&gt; representation i accordance with RFC 2045.
&nbsp;     *
&nbsp;     * @param sArr    The bytes to convert. If &lt;code&gt;null&lt;/code&gt; or length 0 an empty array will be returned.
&nbsp;     * @param lineSep Optional &quot;\r\n&quot; after 76 characters, unless end of file.&lt;br&gt;
&nbsp;     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
&nbsp;     *                little faster.
&nbsp;     * @return A BASE64 encoded array. Never &lt;code&gt;null&lt;/code&gt;.
&nbsp;     *
&nbsp;    public final byte[] encodeToByte(byte[] sArr, boolean lineSep) {
&nbsp;        return encodeToByte(sArr, 0, sArr != null ? sArr.length : 0, lineSep);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a raw byte array into a BASE64 &lt;code&gt;byte[]&lt;/code&gt; representation i accordance with RFC 2045.
&nbsp;     *
&nbsp;     * @param sArr    The bytes to convert. If &lt;code&gt;null&lt;/code&gt; an empty array will be returned.
&nbsp;     * @param sOff    The starting position in the bytes to convert.
&nbsp;     * @param sLen    The number of bytes to convert. If 0 an empty array will be returned.
&nbsp;     * @param lineSep Optional &quot;\r\n&quot; after 76 characters, unless end of file.&lt;br&gt;
&nbsp;     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
&nbsp;     *                little faster.
&nbsp;     * @return A BASE64 encoded array. Never &lt;code&gt;null&lt;/code&gt;.
&nbsp;     *
&nbsp;    public final byte[] encodeToByte(byte[] sArr, int sOff, int sLen, boolean lineSep) {
&nbsp;
&nbsp;        // Check special case
&nbsp;        if (sArr == null || sLen == 0) {
&nbsp;            return new byte[0];
&nbsp;        }
&nbsp;
&nbsp;        int eLen = (sLen / 3) * 3;                              // Length of even 24-bits.
&nbsp;        int cCnt = ((sLen - 1) / 3 + 1) &lt;&lt; 2;                   // Returned character count
&nbsp;        int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 &lt;&lt; 1 : 0); // Length of returned array
&nbsp;        byte[] dArr = new byte[dLen];
&nbsp;
&nbsp;        // Encode even 24-bits
&nbsp;        for (int s = sOff, d = 0, cc = 0; s &lt; sOff + eLen; ) {
&nbsp;
&nbsp;            // Copy next three bytes into lower 24 bits of int, paying attention to sign.
&nbsp;            int i = (sArr[s++] &amp; 0xff) &lt;&lt; 16 | (sArr[s++] &amp; 0xff) &lt;&lt; 8 | (sArr[s++] &amp; 0xff);
&nbsp;
&nbsp;            // Encode the int into four chars
&nbsp;            dArr[d++] = (byte) ALPHABET[(i &gt;&gt;&gt; 18) &amp; 0x3f];
&nbsp;            dArr[d++] = (byte) ALPHABET[(i &gt;&gt;&gt; 12) &amp; 0x3f];
&nbsp;            dArr[d++] = (byte) ALPHABET[(i &gt;&gt;&gt; 6) &amp; 0x3f];
&nbsp;            dArr[d++] = (byte) ALPHABET[i &amp; 0x3f];
&nbsp;
&nbsp;            // Add optional line separator
&nbsp;            if (lineSep &amp;&amp; ++cc == 19 &amp;&amp; d &lt; dLen - 2) {
&nbsp;                dArr[d++] = &#39;\r&#39;;
&nbsp;                dArr[d++] = &#39;\n&#39;;
&nbsp;                cc = 0;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Pad and encode last bits if source isn&#39;t an even 24 bits.
&nbsp;        int left = sLen - eLen; // 0 - 2.
&nbsp;        if (left &gt; 0) {
&nbsp;            // Prepare the int
&nbsp;            int i = ((sArr[sOff + eLen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((sArr[sOff + sLen - 1] &amp; 0xff) &lt;&lt; 2) : 0);
&nbsp;
&nbsp;            // Set last four chars
&nbsp;            dArr[dLen - 4] = (byte) ALPHABET[i &gt;&gt; 12];
&nbsp;            dArr[dLen - 3] = (byte) ALPHABET[(i &gt;&gt;&gt; 6) &amp; 0x3f];
&nbsp;            dArr[dLen - 2] = left == 2 ? (byte) ALPHABET[i &amp; 0x3f] : (byte) &#39;=&#39;;
&nbsp;            dArr[dLen - 1] = &#39;=&#39;;
&nbsp;        }
&nbsp;        return dArr;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Decodes a BASE64 encoded byte array. All illegal characters will be ignored and can handle both arrays with
&nbsp;     * and without line separators.
&nbsp;     *
&nbsp;     * @param sArr The source array. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
&nbsp;     * @return The decoded array of bytes. May be of length 0. Will be &lt;code&gt;null&lt;/code&gt; if the legal characters
&nbsp;     * (including &#39;=&#39;) isn&#39;t divideable by 4. (I.e. definitely corrupted).
&nbsp;     *
&nbsp;    public final byte[] decode(byte[] sArr) {
&nbsp;        return decode(sArr, 0, sArr.length);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Decodes a BASE64 encoded byte array. All illegal characters will be ignored and can handle both arrays with
&nbsp;     * and without line separators.
&nbsp;     *
&nbsp;     * @param sArr The source array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
&nbsp;     * @param sOff The starting position in the source array.
&nbsp;     * @param sLen The number of bytes to decode from the source array. Length 0 will return an empty array.
&nbsp;     * @return The decoded array of bytes. May be of length 0. Will be &lt;code&gt;null&lt;/code&gt; if the legal characters
&nbsp;     * (including &#39;=&#39;) isn&#39;t divideable by 4. (I.e. definitely corrupted).
&nbsp;     *
&nbsp;    public final byte[] decode(byte[] sArr, int sOff, int sLen) {
&nbsp;
&nbsp;        // Count illegal characters (including &#39;\r&#39;, &#39;\n&#39;) to know what size the returned array will be,
&nbsp;        // so we don&#39;t have to reallocate &amp; copy it later.
&nbsp;        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that&#39;s a bonus...)
&nbsp;        for (int i = 0; i &lt; sLen; i++) {     // If input is &quot;pure&quot; (I.e. no line separators or illegal chars) base64 this loop can be commented out.
&nbsp;            if (IALPHABET[sArr[sOff + i] &amp; 0xff] &lt; 0) {
&nbsp;                sepCnt++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check so that legal chars (including &#39;=&#39;) are evenly divisible by 4 as specified in RFC 2045.
&nbsp;        if ((sLen - sepCnt) % 4 != 0) {
&nbsp;            return null;
&nbsp;        }
&nbsp;
&nbsp;        int pad = 0;
&nbsp;        for (int i = sLen; i &gt; 1 &amp;&amp; IALPHABET[sArr[sOff + --i] &amp; 0xff] &lt;= 0; ) {
&nbsp;            if (sArr[sOff + i] == &#39;=&#39;) {
&nbsp;                pad++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int len = ((sLen - sepCnt) * 6 &gt;&gt; 3) - pad;
&nbsp;
&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
&nbsp;
&nbsp;        for (int s = 0, d = 0; d &lt; len; ) {
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
&nbsp;            int i = 0;
&nbsp;            for (int j = 0; j &lt; 4; j++) {   // j only increased if a valid char was found.
&nbsp;                int c = IALPHABET[sArr[sOff + s++] &amp; 0xff];
&nbsp;                if (c &gt;= 0) {
&nbsp;                    i |= c &lt;&lt; (18 - j * 6);
&nbsp;                } else {
&nbsp;                    j--;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Add the bytes
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);
&nbsp;            if (d &lt; len) {
&nbsp;                dArr[d++] = (byte) (i &gt;&gt; 8);
&nbsp;                if (d &lt; len) {
&nbsp;                    dArr[d++] = (byte) i;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return dArr;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /*
&nbsp;     * Decodes a BASE64 encoded byte array that is known to be reasonably well formatted. The method is about twice as
&nbsp;     * fast as {@link #decode(byte[])}. The preconditions are:&lt;br&gt;
&nbsp;     * + The array must have a line length of 76 chars OR no line separators at all (one line).&lt;br&gt;
&nbsp;     * + Line separator must be &quot;\r\n&quot;, as specified in RFC 2045
&nbsp;     * + The array must not contain illegal characters within the encoded string&lt;br&gt;
&nbsp;     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.&lt;br&gt;
&nbsp;     *
&nbsp;     * @param sArr The source array. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
&nbsp;     * @return The decoded array of bytes. May be of length 0.
&nbsp;     *
&nbsp;    public final byte[] decodeFast(byte[] sArr) {
&nbsp;
&nbsp;        // Check special case
&nbsp;        int sLen = sArr.length;
&nbsp;        if (sLen == 0) {
&nbsp;            return new byte[0];
&nbsp;        }
&nbsp;
&nbsp;        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.
&nbsp;
&nbsp;        // Trim illegal chars from start
&nbsp;        while (sIx &lt; eIx &amp;&amp; IALPHABET[sArr[sIx] &amp; 0xff] &lt; 0) {
&nbsp;            sIx++;
&nbsp;        }
&nbsp;
&nbsp;        // Trim illegal chars from end
&nbsp;        while (eIx &gt; 0 &amp;&amp; IALPHABET[sArr[eIx] &amp; 0xff] &lt; 0) {
&nbsp;            eIx--;
&nbsp;        }
&nbsp;
&nbsp;        // get the padding count (=) (0, 1 or 2)
&nbsp;        int pad = sArr[eIx] == &#39;=&#39; ? (sArr[eIx - 1] == &#39;=&#39; ? 2 : 1) : 0;  // Count &#39;=&#39; at end.
&nbsp;        int cCnt = eIx - sIx + 1;   // Content count including possible separators
&nbsp;        int sepCnt = sLen &gt; 76 ? (sArr[76] == &#39;\r&#39; ? cCnt / 78 : 0) &lt;&lt; 1 : 0;
&nbsp;
&nbsp;        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes
&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
&nbsp;
&nbsp;        // Decode all but the last 0 - 2 bytes.
&nbsp;        int d = 0;
&nbsp;        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) {
&nbsp;
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
&nbsp;            int i = IALPHABET[sArr[sIx++]] &lt;&lt; 18 | IALPHABET[sArr[sIx++]] &lt;&lt; 12 | IALPHABET[sArr[sIx++]] &lt;&lt; 6 | IALPHABET[sArr[sIx++]];
&nbsp;
&nbsp;            // Add the bytes
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 8);
&nbsp;            dArr[d++] = (byte) i;
&nbsp;
&nbsp;            // If line separator, jump over it.
&nbsp;            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {
&nbsp;                sIx += 2;
&nbsp;                cc = 0;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        if (d &lt; len) {
&nbsp;            // Decode last 1-3 bytes (incl &#39;=&#39;) into 1-3 bytes
&nbsp;            int i = 0;
&nbsp;            for (int j = 0; sIx &lt;= eIx - pad; j++) {
&nbsp;                i |= IALPHABET[sArr[sIx++]] &lt;&lt; (18 - j * 6);
&nbsp;            }
&nbsp;
&nbsp;            for (int r = 16; d &lt; len; r -= 8) {
&nbsp;                dArr[d++] = (byte) (i &gt;&gt; r);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return dArr;
&nbsp;    }
&nbsp;    */
&nbsp;
&nbsp;    // ****************************************************************************************
&nbsp;    // * String version
&nbsp;    // ****************************************************************************************
&nbsp;
&nbsp;    /**
&nbsp;     * Encodes a raw byte array into a BASE64 &lt;code&gt;String&lt;/code&gt; representation i accordance with RFC 2045.
&nbsp;     *
&nbsp;     * @param sArr    The bytes to convert. If &lt;code&gt;null&lt;/code&gt; or length 0 an empty array will be returned.
&nbsp;     * @param lineSep Optional &quot;\r\n&quot; after 76 characters, unless end of file.&lt;br&gt;
&nbsp;     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a
&nbsp;     *                little faster.
&nbsp;     * @return A BASE64 encoded array. Never &lt;code&gt;null&lt;/code&gt;.
&nbsp;     */
&nbsp;    String encodeToString(byte[] sArr, boolean lineSep) {
&nbsp;        // Reuse char[] since we can&#39;t create a String incrementally anyway and StringBuffer/Builder would be slower.
<b class="fc">&nbsp;        return new String(encodeToChar(sArr, lineSep));</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * Decodes a BASE64 encoded &lt;code&gt;String&lt;/code&gt;. All illegal characters will be ignored and can handle both strings with
&nbsp;     * and without line separators.&lt;br&gt;
&nbsp;     * &lt;b&gt;Note!&lt;/b&gt; It can be up to about 2x the speed to call &lt;code&gt;decode(str.toCharArray())&lt;/code&gt; instead. That
&nbsp;     * will create a temporary array though. This version will use &lt;code&gt;str.charAt(i)&lt;/code&gt; to iterate the string.
&nbsp;     *
&nbsp;     * @param str The source string. &lt;code&gt;null&lt;/code&gt; or length 0 will return an empty array.
&nbsp;     * @return The decoded array of bytes. May be of length 0. Will be &lt;code&gt;null&lt;/code&gt; if the legal characters
&nbsp;     * (including &#39;=&#39;) isn&#39;t divideable by 4.  (I.e. definitely corrupted).
&nbsp;     *
&nbsp;    public final byte[] decode(String str) {
&nbsp;
&nbsp;        // Check special case
&nbsp;        int sLen = str != null ? str.length() : 0;
&nbsp;        if (sLen == 0) {
&nbsp;            return new byte[0];
&nbsp;        }
&nbsp;
&nbsp;        // Count illegal characters (including &#39;\r&#39;, &#39;\n&#39;) to know what size the returned array will be,
&nbsp;        // so we don&#39;t have to reallocate &amp; copy it later.
&nbsp;        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that&#39;s a bonus...)
&nbsp;        for (int i = 0; i &lt; sLen; i++) { // If input is &quot;pure&quot; (I.e. no line separators or illegal chars) base64 this loop can be commented out.
&nbsp;            if (IALPHABET[str.charAt(i)] &lt; 0) {
&nbsp;                sepCnt++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Check so that legal chars (including &#39;=&#39;) are evenly divideable by 4 as specified in RFC 2045.
&nbsp;        if ((sLen - sepCnt) % 4 != 0) {
&nbsp;            return null;
&nbsp;        }
&nbsp;
&nbsp;        // Count &#39;=&#39; at end
&nbsp;        int pad = 0;
&nbsp;        for (int i = sLen; i &gt; 1 &amp;&amp; IALPHABET[str.charAt(--i)] &lt;= 0; ) {
&nbsp;            if (str.charAt(i) == &#39;=&#39;) {
&nbsp;                pad++;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        int len = ((sLen - sepCnt) * 6 &gt;&gt; 3) - pad;
&nbsp;
&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
&nbsp;
&nbsp;        for (int s = 0, d = 0; d &lt; len; ) {
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
&nbsp;            int i = 0;
&nbsp;            for (int j = 0; j &lt; 4; j++) {   // j only increased if a valid char was found.
&nbsp;                int c = IALPHABET[str.charAt(s++)];
&nbsp;                if (c &gt;= 0) {
&nbsp;                    i |= c &lt;&lt; (18 - j * 6);
&nbsp;                } else {
&nbsp;                    j--;
&nbsp;                }
&nbsp;            }
&nbsp;            // Add the bytes
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);
&nbsp;            if (d &lt; len) {
&nbsp;                dArr[d++] = (byte) (i &gt;&gt; 8);
&nbsp;                if (d &lt; len) {
&nbsp;                    dArr[d++] = (byte) i;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;        return dArr;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Decodes a BASE64 encoded string that is known to be resonably well formatted. The method is about twice as
&nbsp;     * fast as {@link #decode(String)}. The preconditions are:&lt;br&gt;
&nbsp;     * + The array must have a line length of 76 chars OR no line separators at all (one line).&lt;br&gt;
&nbsp;     * + Line separator must be &quot;\r\n&quot;, as specified in RFC 2045
&nbsp;     * + The array must not contain illegal characters within the encoded string&lt;br&gt;
&nbsp;     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.&lt;br&gt;
&nbsp;     *
&nbsp;     * @param s The source string. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
&nbsp;     * @return The decoded array of bytes. May be of length 0.
&nbsp;     *
&nbsp;    public final byte[] decodeFast(String s) {
&nbsp;
&nbsp;        // Check special case
&nbsp;        int sLen = s.length();
&nbsp;        if (sLen == 0) {
&nbsp;            return new byte[0];
&nbsp;        }
&nbsp;
&nbsp;        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.
&nbsp;
&nbsp;        // Trim illegal chars from start
&nbsp;        while (sIx &lt; eIx &amp;&amp; IALPHABET[s.charAt(sIx) &amp; 0xff] &lt; 0) {
&nbsp;            sIx++;
&nbsp;        }
&nbsp;
&nbsp;        // Trim illegal chars from end
&nbsp;        while (eIx &gt; 0 &amp;&amp; IALPHABET[s.charAt(eIx) &amp; 0xff] &lt; 0) {
&nbsp;            eIx--;
&nbsp;        }
&nbsp;
&nbsp;        // get the padding count (=) (0, 1 or 2)
&nbsp;        int pad = s.charAt(eIx) == &#39;=&#39; ? (s.charAt(eIx - 1) == &#39;=&#39; ? 2 : 1) : 0;  // Count &#39;=&#39; at end.
&nbsp;        int cCnt = eIx - sIx + 1;   // Content count including possible separators
&nbsp;        int sepCnt = sLen &gt; 76 ? (s.charAt(76) == &#39;\r&#39; ? cCnt / 78 : 0) &lt;&lt; 1 : 0;
&nbsp;
&nbsp;        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes
&nbsp;        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length
&nbsp;
&nbsp;        // Decode all but the last 0 - 2 bytes.
&nbsp;        int d = 0;
&nbsp;        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) {
&nbsp;            // Assemble three bytes into an int from four &quot;valid&quot; characters.
&nbsp;            int i = IALPHABET[s.charAt(sIx++)] &lt;&lt; 18 | IALPHABET[s.charAt(sIx++)] &lt;&lt; 12 | IALPHABET[s.charAt(sIx++)] &lt;&lt; 6 | IALPHABET[s.charAt(sIx++)];
&nbsp;
&nbsp;            // Add the bytes
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 16);
&nbsp;            dArr[d++] = (byte) (i &gt;&gt; 8);
&nbsp;            dArr[d++] = (byte) i;
&nbsp;
&nbsp;            // If line separator, jump over it.
&nbsp;            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {
&nbsp;                sIx += 2;
&nbsp;                cc = 0;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        if (d &lt; len) {
&nbsp;            // Decode last 1-3 bytes (incl &#39;=&#39;) into 1-3 bytes
&nbsp;            int i = 0;
&nbsp;            for (int j = 0; sIx &lt;= eIx - pad; j++) {
&nbsp;                i |= IALPHABET[s.charAt(sIx++)] &lt;&lt; (18 - j * 6);
&nbsp;            }
&nbsp;
&nbsp;            for (int r = 16; d &lt; len; r -= 8) {
&nbsp;                dArr[d++] = (byte) (i &gt;&gt; r);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return dArr;
&nbsp;    }
&nbsp;    */
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
