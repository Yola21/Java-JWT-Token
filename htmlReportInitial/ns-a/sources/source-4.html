


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Collections</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.lang</a>
</div>

<h1>Coverage Summary for Class: Collections (io.jsonwebtoken.lang)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Collections</td>
<td class="coverageStat">
  <span class="percent">
    58.1%
  </span>
  <span class="absValue">
    (18/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.2%
  </span>
  <span class="absValue">
    (31/114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30.8%
  </span>
  <span class="absValue">
    (40/130)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Collections$asSet$0</td>
  </tr>
  <tr>
    <td class="name">Collections$emptyList</td>
  </tr>
  <tr>
    <td class="name">Collections$EnumerationIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Collections$nullSafe</td>
  </tr>
  <tr>
    <td class="name">Collections$nullSafe$1</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    51.4%
  </span>
  <span class="absValue">
    (18/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.2%
  </span>
  <span class="absValue">
    (31/114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.6%
  </span>
  <span class="absValue">
    (40/135)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.lang;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;/**
&nbsp; * Utility methods for working with {@link Collection}s, {@link List}s, {@link Set}s, and {@link Maps}.
&nbsp; */
&nbsp;@SuppressWarnings({&quot;unused&quot;, &quot;rawtypes&quot;})
&nbsp;public final class Collections {
&nbsp;
&nbsp;    private Collections() {
&nbsp;    } //prevent instantiation
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type-safe immutable empty {@code List}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; list element type
&nbsp;     * @return a type-safe immutable empty {@code List}.
&nbsp;     */
&nbsp;    public static &lt;T&gt; List&lt;T&gt; emptyList() {
<b class="fc">&nbsp;        return java.util.Collections.emptyList();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type-safe immutable empty {@code Set}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; set element type
&nbsp;     * @return a type-safe immutable empty {@code Set}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; emptySet() {
<b class="fc">&nbsp;        return java.util.Collections.emptySet();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type-safe immutable empty {@code Map}.
&nbsp;     *
&nbsp;     * @param &lt;K&gt; map key type
&nbsp;     * @param &lt;V&gt; map value type
&nbsp;     * @return a type-safe immutable empty {@code Map}.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public static &lt;K, V&gt; Map&lt;K, V&gt; emptyMap() {
<b class="nc">&nbsp;        return java.util.Collections.emptyMap();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type-safe immutable {@code List} containing the specified array elements.
&nbsp;     *
&nbsp;     * @param elements array elements to include in the list
&nbsp;     * @param &lt;T&gt;      list element type
&nbsp;     * @return a type-safe immutable {@code List} containing the specified array elements.
&nbsp;     */
&nbsp;    @SafeVarargs
&nbsp;    public static &lt;T&gt; List&lt;T&gt; of(T... elements) {
<b class="pc">&nbsp;        if (elements == null || elements.length == 0) {</b>
<b class="nc">&nbsp;            return java.util.Collections.emptyList();</b>
&nbsp;        }
<b class="fc">&nbsp;        return java.util.Collections.unmodifiableList(Arrays.asList(elements));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the specified collection as a {@link Set} instance.
&nbsp;     *
&nbsp;     * @param c   the collection to represent as a set
&nbsp;     * @param &lt;T&gt; collection element type
&nbsp;     * @return a type-safe immutable {@code Set} containing the specified collection elements.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; asSet(Collection&lt;T&gt; c) {
<b class="fc">&nbsp;        if (c instanceof Set) {</b>
<b class="fc">&nbsp;            return (Set&lt;T&gt;) c;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (isEmpty(c)) {</b>
<b class="fc">&nbsp;            return java.util.Collections.emptySet();</b>
&nbsp;        }
<b class="fc">&nbsp;        return java.util.Collections.unmodifiableSet(new LinkedHashSet&lt;&gt;(c));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type-safe immutable {@code Set} containing the specified array elements.
&nbsp;     *
&nbsp;     * @param elements array elements to include in the set
&nbsp;     * @param &lt;T&gt;      set element type
&nbsp;     * @return a type-safe immutable {@code Set} containing the specified array elements.
&nbsp;     */
&nbsp;    @SafeVarargs
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; setOf(T... elements) {
<b class="pc">&nbsp;        if (elements == null || elements.length == 0) {</b>
<b class="nc">&nbsp;            return java.util.Collections.emptySet();</b>
&nbsp;        }
<b class="fc">&nbsp;        Set&lt;T&gt; set = new LinkedHashSet&lt;&gt;(Arrays.asList(elements));</b>
<b class="fc">&nbsp;        return immutable(set);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shorter null-safe convenience alias for {@link java.util.Collections#unmodifiableList(List)} so both classes
&nbsp;     * don&#39;t need to be imported.
&nbsp;     *
&nbsp;     * @param m   map to wrap in an immutable/unmodifiable collection
&nbsp;     * @param &lt;K&gt; map key type
&nbsp;     * @param &lt;V&gt; map value type
&nbsp;     * @return an immutable wrapper for {@code m}.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static &lt;K, V&gt; Map&lt;K, V&gt; immutable(Map&lt;K, V&gt; m) {
<b class="pc">&nbsp;        return m != null ? java.util.Collections.unmodifiableMap(m) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shorter null-safe convenience alias for {@link java.util.Collections#unmodifiableSet(Set)} so both classes don&#39;t
&nbsp;     * need to be imported.
&nbsp;     *
&nbsp;     * @param set set to wrap in an immutable Set
&nbsp;     * @param &lt;T&gt; set element type
&nbsp;     * @return an immutable wrapper for {@code set}
&nbsp;     */
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; immutable(Set&lt;T&gt; set) {
<b class="fc">&nbsp;        return set != null ? java.util.Collections.unmodifiableSet(set) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shorter null-safe convenience alias for {@link java.util.Collections#unmodifiableList(List)} so both classes
&nbsp;     * don&#39;t need to be imported.
&nbsp;     *
&nbsp;     * @param list list to wrap in an immutable List
&nbsp;     * @param &lt;T&gt;  list element type
&nbsp;     * @return an immutable wrapper for {@code list}
&nbsp;     */
&nbsp;    public static &lt;T&gt; List&lt;T&gt; immutable(List&lt;T&gt; list) {
<b class="fc">&nbsp;        return list != null ? java.util.Collections.unmodifiableList(list) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Null-safe factory method that returns an immutable/unmodifiable view of the specified collection instance.
&nbsp;     * Works for {@link List}, {@link Set} and {@link Collection} arguments.
&nbsp;     *
&nbsp;     * @param c   collection to wrap in an immutable/unmodifiable collection
&nbsp;     * @param &lt;C&gt; type of collection
&nbsp;     * @param &lt;T&gt; type of elements in the collection
&nbsp;     * @return an immutable wrapper for {@code l}.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static &lt;T, C extends Collection&lt;T&gt;&gt; C immutable(C c) {
<b class="pc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            return null;</b>
<b class="fc">&nbsp;        } else if (c instanceof Set) {</b>
<b class="fc">&nbsp;            return (C) java.util.Collections.unmodifiableSet((Set&lt;T&gt;) c);</b>
<b class="fc">&nbsp;        } else if (c instanceof List) {</b>
<b class="fc">&nbsp;            return (C) java.util.Collections.unmodifiableList((List&lt;T&gt;) c);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return (C) java.util.Collections.unmodifiableCollection(c);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a non-null set, either {@code s} if it is not null, or {@link #emptySet()} otherwise.
&nbsp;     *
&nbsp;     * @param s   the set to check for null
&nbsp;     * @param &lt;T&gt; type of elements in the set
&nbsp;     * @return a non-null set, either {@code s} if it is not null, or {@link #emptySet()} otherwise.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; nullSafe(Set&lt;T&gt; s) {
<b class="fc">&nbsp;        return s == null ? Collections.&lt;T&gt;emptySet() : s;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a non-null collection, either {@code c} if it is not null, or {@link #emptyList()} otherwise.
&nbsp;     *
&nbsp;     * @param c   the collection to check for null
&nbsp;     * @param &lt;T&gt; type of elements in the collection
&nbsp;     * @return a non-null collection, either {@code c} if it is not null, or {@link #emptyList()} otherwise.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static &lt;T&gt; Collection&lt;T&gt; nullSafe(Collection&lt;T&gt; c) {
<b class="fc">&nbsp;        return c == null ? Collections.&lt;T&gt;emptyList() : c;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return &lt;code&gt;true&lt;/code&gt; if the supplied Collection is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * or empty. Otherwise, return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param collection the Collection to check
&nbsp;     * @return whether the given Collection is empty
&nbsp;     */
&nbsp;    public static boolean isEmpty(Collection&lt;?&gt; collection) {
<b class="fc">&nbsp;        return size(collection) == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the collection&#39;s size or {@code 0} if the collection is {@code null}.
&nbsp;     *
&nbsp;     * @param collection the collection to check.
&nbsp;     * @return the collection&#39;s size or {@code 0} if the collection is {@code null}.
&nbsp;     * @since 0.9.2
&nbsp;     */
&nbsp;    public static int size(Collection&lt;?&gt; collection) {
<b class="fc">&nbsp;        return collection == null ? 0 : collection.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the map&#39;s size or {@code 0} if the map is {@code null}.
&nbsp;     *
&nbsp;     * @param map the map to check
&nbsp;     * @return the map&#39;s size or {@code 0} if the map is {@code null}.
&nbsp;     * @since 0.9.2
&nbsp;     */
&nbsp;    public static int size(Map&lt;?, ?&gt; map) {
<b class="fc">&nbsp;        return map == null ? 0 : map.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return &lt;code&gt;true&lt;/code&gt; if the supplied Map is &lt;code&gt;null&lt;/code&gt;
&nbsp;     * or empty. Otherwise, return &lt;code&gt;false&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param map the Map to check
&nbsp;     * @return whether the given Map is empty
&nbsp;     */
&nbsp;    public static boolean isEmpty(Map&lt;?, ?&gt; map) {
<b class="fc">&nbsp;        return size(map) == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convert the supplied array into a List. A primitive array gets
&nbsp;     * converted into a List of the appropriate wrapper type.
&nbsp;     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source value will be converted to an
&nbsp;     * empty List.
&nbsp;     *
&nbsp;     * @param source the (potentially primitive) array
&nbsp;     * @return the converted List result
&nbsp;     * @see Objects#toObjectArray(Object)
&nbsp;     */
&nbsp;    public static List arrayToList(Object source) {
<b class="fc">&nbsp;        return Arrays.asList(Objects.toObjectArray(source));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Concatenate the specified set with the specified array elements, resulting in a new {@link LinkedHashSet} with
&nbsp;     * the array elements appended to the end of the existing Set.
&nbsp;     *
&nbsp;     * @param c        the set to append to
&nbsp;     * @param elements the array elements to append to the end of the set
&nbsp;     * @param &lt;T&gt;      set element type
&nbsp;     * @return a new {@link LinkedHashSet} with the array elements appended to the end of the original set.
&nbsp;     */
&nbsp;    @SafeVarargs
&nbsp;    public static &lt;T&gt; Set&lt;T&gt; concat(Set&lt;T&gt; c, T... elements) {
<b class="fc">&nbsp;        int size = Math.max(1, Collections.size(c) + io.jsonwebtoken.lang.Arrays.length(elements));</b>
<b class="fc">&nbsp;        Set&lt;T&gt; set = new LinkedHashSet&lt;&gt;(size);</b>
<b class="fc">&nbsp;        set.addAll(c);</b>
<b class="fc">&nbsp;        java.util.Collections.addAll(set, elements);</b>
<b class="fc">&nbsp;        return immutable(set);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Merge the given array into the given Collection.
&nbsp;     *
&nbsp;     * @param array      the array to merge (may be &lt;code&gt;null&lt;/code&gt;)
&nbsp;     * @param collection the target Collection to merge the array into
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static void mergeArrayIntoCollection(Object array, Collection collection) {
<b class="nc">&nbsp;        if (collection == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Collection must not be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        Object[] arr = Objects.toObjectArray(array);</b>
<b class="nc">&nbsp;        java.util.Collections.addAll(collection, arr);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Merge the given Properties instance into the given Map,
&nbsp;     * copying all properties (key-value pairs) over.
&nbsp;     * &lt;p&gt;Uses &lt;code&gt;Properties.propertyNames()&lt;/code&gt; to even catch
&nbsp;     * default properties linked into the original Properties instance.
&nbsp;     *
&nbsp;     * @param props the Properties instance to merge (may be &lt;code&gt;null&lt;/code&gt;)
&nbsp;     * @param map   the target Map to merge the properties into
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static void mergePropertiesIntoMap(Properties props, Map map) {
<b class="nc">&nbsp;        if (map == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Map must not be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (props != null) {</b>
<b class="nc">&nbsp;            for (Enumeration en = props.propertyNames(); en.hasMoreElements(); ) {</b>
<b class="nc">&nbsp;                String key = (String) en.nextElement();</b>
<b class="nc">&nbsp;                Object value = props.getProperty(key);</b>
<b class="nc">&nbsp;                if (value == null) {</b>
&nbsp;                    // Potentially a non-String value...
<b class="nc">&nbsp;                    value = props.get(key);</b>
&nbsp;                }
<b class="nc">&nbsp;                map.put(key, value);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Check whether the given Iterator contains the given element.
&nbsp;     *
&nbsp;     * @param iterator the Iterator to check
&nbsp;     * @param element  the element to look for
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if found, &lt;code&gt;false&lt;/code&gt; else
&nbsp;     */
&nbsp;    public static boolean contains(Iterator iterator, Object element) {
<b class="pc">&nbsp;        if (iterator != null) {</b>
<b class="fc">&nbsp;            while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                Object candidate = iterator.next();</b>
<b class="fc">&nbsp;                if (Objects.nullSafeEquals(candidate, element)) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check whether the given Enumeration contains the given element.
&nbsp;     *
&nbsp;     * @param enumeration the Enumeration to check
&nbsp;     * @param element     the element to look for
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if found, &lt;code&gt;false&lt;/code&gt; else
&nbsp;     */
&nbsp;    public static boolean contains(Enumeration enumeration, Object element) {
<b class="nc">&nbsp;        if (enumeration != null) {</b>
<b class="nc">&nbsp;            while (enumeration.hasMoreElements()) {</b>
<b class="nc">&nbsp;                Object candidate = enumeration.nextElement();</b>
<b class="nc">&nbsp;                if (Objects.nullSafeEquals(candidate, element)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check whether the given Collection contains the given element instance.
&nbsp;     * &lt;p&gt;Enforces the given instance to be present, rather than returning
&nbsp;     * &lt;code&gt;true&lt;/code&gt; for an equal element as well.
&nbsp;     *
&nbsp;     * @param collection the Collection to check
&nbsp;     * @param element    the element to look for
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if found, &lt;code&gt;false&lt;/code&gt; else
&nbsp;     */
&nbsp;    public static boolean containsInstance(Collection collection, Object element) {
<b class="nc">&nbsp;        if (collection != null) {</b>
<b class="nc">&nbsp;            for (Object candidate : collection) {</b>
<b class="nc">&nbsp;                if (candidate == element) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return &lt;code&gt;true&lt;/code&gt; if any element in &#39;&lt;code&gt;candidates&lt;/code&gt;&#39; is
&nbsp;     * contained in &#39;&lt;code&gt;source&lt;/code&gt;&#39;; otherwise returns &lt;code&gt;false&lt;/code&gt;.
&nbsp;     *
&nbsp;     * @param source     the source Collection
&nbsp;     * @param candidates the candidates to search for
&nbsp;     * @return whether any of the candidates has been found
&nbsp;     */
&nbsp;    public static boolean containsAny(Collection source, Collection candidates) {
<b class="nc">&nbsp;        if (isEmpty(source) || isEmpty(candidates)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Object candidate : candidates) {</b>
<b class="nc">&nbsp;            if (source.contains(candidate)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the first element in &#39;&lt;code&gt;candidates&lt;/code&gt;&#39; that is contained in
&nbsp;     * &#39;&lt;code&gt;source&lt;/code&gt;&#39;. If no element in &#39;&lt;code&gt;candidates&lt;/code&gt;&#39; is present in
&nbsp;     * &#39;&lt;code&gt;source&lt;/code&gt;&#39; returns &lt;code&gt;null&lt;/code&gt;. Iteration order is
&nbsp;     * {@link Collection} implementation specific.
&nbsp;     *
&nbsp;     * @param source     the source Collection
&nbsp;     * @param candidates the candidates to search for
&nbsp;     * @return the first present object, or &lt;code&gt;null&lt;/code&gt; if not found
&nbsp;     */
&nbsp;    public static Object findFirstMatch(Collection source, Collection candidates) {
<b class="nc">&nbsp;        if (isEmpty(source) || isEmpty(candidates)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Object candidate : candidates) {</b>
<b class="nc">&nbsp;            if (source.contains(candidate)) {</b>
<b class="nc">&nbsp;                return candidate;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Find a single value of the given type in the given Collection.
&nbsp;     *
&nbsp;     * @param collection the Collection to search
&nbsp;     * @param type       the type to look for
&nbsp;     * @param &lt;T&gt;        the generic type parameter for {@code type}
&nbsp;     * @return a value of the given type found if there is a clear match,
&nbsp;     * or &lt;code&gt;null&lt;/code&gt; if none or more than one such value found
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static &lt;T&gt; T findValueOfType(Collection&lt;?&gt; collection, Class&lt;T&gt; type) {
<b class="nc">&nbsp;        if (isEmpty(collection)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        T value = null;</b>
<b class="nc">&nbsp;        for (Object element : collection) {</b>
<b class="nc">&nbsp;            if (type == null || type.isInstance(element)) {</b>
<b class="nc">&nbsp;                if (value != null) {</b>
&nbsp;                    // More than one value found... no clear single value.
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                value = (T) element;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return value;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Find a single value of one of the given types in the given Collection:
&nbsp;     * searching the Collection for a value of the first type, then
&nbsp;     * searching for a value of the second type, etc.
&nbsp;     *
&nbsp;     * @param collection the collection to search
&nbsp;     * @param types      the types to look for, in prioritized order
&nbsp;     * @return a value of one of the given types found if there is a clear match,
&nbsp;     * or &lt;code&gt;null&lt;/code&gt; if none or more than one such value found
&nbsp;     */
&nbsp;    public static Object findValueOfType(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types) {
<b class="nc">&nbsp;        if (isEmpty(collection) || Objects.isEmpty(types)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Class&lt;?&gt; type : types) {</b>
<b class="nc">&nbsp;            Object value = findValueOfType(collection, type);</b>
<b class="nc">&nbsp;            if (value != null) {</b>
<b class="nc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine whether the given Collection only contains a single unique object.
&nbsp;     *
&nbsp;     * @param collection the Collection to check
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the collection contains a single reference or
&nbsp;     * multiple references to the same instance, &lt;code&gt;false&lt;/code&gt; else
&nbsp;     */
&nbsp;    public static boolean hasUniqueObject(Collection collection) {
<b class="nc">&nbsp;        if (isEmpty(collection)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean hasCandidate = false;</b>
<b class="nc">&nbsp;        Object candidate = null;</b>
<b class="nc">&nbsp;        for (Object elem : collection) {</b>
<b class="nc">&nbsp;            if (!hasCandidate) {</b>
<b class="nc">&nbsp;                hasCandidate = true;</b>
<b class="nc">&nbsp;                candidate = elem;</b>
<b class="nc">&nbsp;            } else if (candidate != elem) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Find the common element type of the given Collection, if any.
&nbsp;     *
&nbsp;     * @param collection the Collection to check
&nbsp;     * @return the common element type, or &lt;code&gt;null&lt;/code&gt; if no clear
&nbsp;     * common type has been found (or the collection was empty)
&nbsp;     */
&nbsp;    public static Class&lt;?&gt; findCommonElementType(Collection collection) {
<b class="nc">&nbsp;        if (isEmpty(collection)) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Class&lt;?&gt; candidate = null;</b>
<b class="nc">&nbsp;        for (Object val : collection) {</b>
<b class="nc">&nbsp;            if (val != null) {</b>
<b class="nc">&nbsp;                if (candidate == null) {</b>
<b class="nc">&nbsp;                    candidate = val.getClass();</b>
<b class="nc">&nbsp;                } else if (candidate != val.getClass()) {</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return candidate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marshal the elements from the given enumeration into an array of the given type.
&nbsp;     * Enumeration elements must be assignable to the type of the given array. The array
&nbsp;     * returned will be a different instance than the array given.
&nbsp;     *
&nbsp;     * @param enumeration the collection to convert to an array
&nbsp;     * @param array       an array instance that matches the type of array to return
&nbsp;     * @param &lt;A&gt;         the element type of the array that will be created
&nbsp;     * @param &lt;E&gt;         the element type contained within the enumeration.
&nbsp;     * @return a new array of type {@code A} that contains the elements in the specified {@code enumeration}.
&nbsp;     */
&nbsp;    public static &lt;A, E extends A&gt; A[] toArray(Enumeration&lt;E&gt; enumeration, A[] array) {
<b class="nc">&nbsp;        ArrayList&lt;A&gt; elements = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        while (enumeration.hasMoreElements()) {</b>
<b class="nc">&nbsp;            elements.add(enumeration.nextElement());</b>
&nbsp;        }
<b class="nc">&nbsp;        return elements.toArray(array);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adapt an enumeration to an iterator.
&nbsp;     *
&nbsp;     * @param enumeration the enumeration
&nbsp;     * @param &lt;E&gt;         the type of elements in the enumeration
&nbsp;     * @return the iterator
&nbsp;     */
&nbsp;    public static &lt;E&gt; Iterator&lt;E&gt; toIterator(Enumeration&lt;E&gt; enumeration) {
<b class="nc">&nbsp;        return new EnumerationIterator&lt;&gt;(enumeration);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Iterator wrapping an Enumeration.
&nbsp;     */
&nbsp;    private static class EnumerationIterator&lt;E&gt; implements Iterator&lt;E&gt; {
&nbsp;
&nbsp;        private final Enumeration&lt;E&gt; enumeration;
&nbsp;
<b class="nc">&nbsp;        public EnumerationIterator(Enumeration&lt;E&gt; enumeration) {</b>
<b class="nc">&nbsp;            this.enumeration = enumeration;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean hasNext() {
<b class="nc">&nbsp;            return this.enumeration.hasMoreElements();</b>
&nbsp;        }
&nbsp;
&nbsp;        public E next() {
<b class="nc">&nbsp;            return this.enumeration.nextElement();</b>
&nbsp;        }
&nbsp;
&nbsp;        public void remove() throws UnsupportedOperationException {
<b class="nc">&nbsp;            throw new UnsupportedOperationException(&quot;Not supported&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:13</div>
</div>
</body>
</html>
