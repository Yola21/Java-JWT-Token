


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Jwts</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken</a>
</div>

<h1>Coverage Summary for Class: Jwts (io.jsonwebtoken)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Jwts</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Jwts$builder</td>
  </tr>
  <tr>
    <td class="name">Jwts$claims$2</td>
  </tr>
  <tr>
    <td class="name">Jwts$claims$3</td>
  </tr>
  <tr>
    <td class="name">Jwts$ENC</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jwts$ENC$get</td>
  </tr>
  <tr>
    <td class="name">Jwts$header$1</td>
  </tr>
  <tr>
    <td class="name">Jwts$HeaderBuilder</td>
  </tr>
  <tr>
    <td class="name">Jwts$KEY</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jwts$KEY$get</td>
  </tr>
  <tr>
    <td class="name">Jwts$parser$0</td>
  </tr>
  <tr>
    <td class="name">Jwts$SIG</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jwts$SIG$get</td>
  </tr>
  <tr>
    <td class="name">Jwts$ZIP</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jwts$ZIP$get</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (54/54)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken;
&nbsp;
&nbsp;import io.jsonwebtoken.io.CompressionAlgorithm;
&nbsp;import io.jsonwebtoken.lang.Builder;
&nbsp;import io.jsonwebtoken.lang.Classes;
&nbsp;import io.jsonwebtoken.lang.Registry;
&nbsp;import io.jsonwebtoken.security.AeadAlgorithm;
&nbsp;import io.jsonwebtoken.security.KeyAlgorithm;
&nbsp;import io.jsonwebtoken.security.KeyPairBuilderSupplier;
&nbsp;import io.jsonwebtoken.security.MacAlgorithm;
&nbsp;import io.jsonwebtoken.security.Password;
&nbsp;import io.jsonwebtoken.security.SecretKeyAlgorithm;
&nbsp;import io.jsonwebtoken.security.SecureDigestAlgorithm;
&nbsp;import io.jsonwebtoken.security.SignatureAlgorithm;
&nbsp;import io.jsonwebtoken.security.X509Builder;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.PublicKey;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;/**
&nbsp; * Factory class useful for creating instances of JWT interfaces.  Using this factory class can be a good
&nbsp; * alternative to tightly coupling your code to implementation classes.
&nbsp; *
&nbsp; * &lt;p&gt;&lt;b&gt;Standard Algorithm References&lt;/b&gt;&lt;/p&gt;
&nbsp; * &lt;p&gt;Standard JSON Web Token algorithms used during JWS or JWE building or parsing are available organized by
&nbsp; * algorithm type. Each organized collection of algorithms is available via a constant to allow
&nbsp; * for easy code-completion in IDEs, showing available algorithm instances.  For example, when typing:&lt;/p&gt;
&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
&nbsp; * Jwts.// press code-completion hotkeys to suggest available algorithm registry fields
&nbsp; * Jwts.{@link SIG SIG}.// press hotkeys to suggest individual Digital Signature or MAC algorithms or utility methods
&nbsp; * Jwts.{@link ENC ENC}.// press hotkeys to suggest individual encryption algorithms or utility methods
&nbsp; * Jwts.{@link KEY KEY}.// press hotkeys to suggest individual key algorithms or utility methods&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp; *
&nbsp; * @since 0.1
&nbsp; */
<b class="fc">&nbsp;public final class Jwts {</b>
&nbsp;
&nbsp;
&nbsp;    // do not change this visibility.  Raw type method signature not be publicly exposed:
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private static &lt;T&gt; T get(Registry&lt;String, ?&gt; registry, String id) {
<b class="fc">&nbsp;        return (T) registry.forKey(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constants for all standard JWA
&nbsp;     * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-5&quot;&gt;Cryptographic Algorithms for Content
&nbsp;     * Encryption&lt;/a&gt; defined in the &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.1&quot;&gt;JSON
&nbsp;     * Web Signature and Encryption Algorithms Registry&lt;/a&gt;. Each standard algorithm is available as a
&nbsp;     * ({@code public static final}) constant for direct type-safe reference in application code. For example:
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwts.builder()
&nbsp;     *    // ... etc ...
&nbsp;     *    .encryptWith(aKey, &lt;b&gt;Jwts.ENC.A256GCM&lt;/b&gt;) // or A128GCM, A192GCM, etc...
&nbsp;     *    .build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     * &lt;p&gt;They are also available together as a {@link Registry} instance via the {@link #get()} method.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see #get()
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static final class ENC {
&nbsp;
&nbsp;        private static final String IMPL_CLASSNAME = &quot;io.jsonwebtoken.impl.security.StandardEncryptionAlgorithms&quot;;
<b class="fc">&nbsp;        private static final Registry&lt;String, AeadAlgorithm&gt; REGISTRY = Classes.newInstance(IMPL_CLASSNAME);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns all standard JWA &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-5&quot;&gt;Cryptographic
&nbsp;         * Algorithms for Content Encryption&lt;/a&gt; defined in the
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.1&quot;&gt;JSON Web Signature and Encryption
&nbsp;         * Algorithms Registry&lt;/a&gt;.
&nbsp;         *
&nbsp;         * @return all standard JWA content encryption algorithms.
&nbsp;         */
&nbsp;        public static Registry&lt;String, AeadAlgorithm&gt; get() {
<b class="fc">&nbsp;            return REGISTRY;</b>
&nbsp;        }
&nbsp;
&nbsp;        // prevent instantiation
&nbsp;        private ENC() {
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@code AES_128_CBC_HMAC_SHA_256} authenticated encryption algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.2.3&quot;&gt;RFC 7518, Section 5.2.3&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 256-bit (32 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A128CBC_HS256 = get().forKey(&quot;A128CBC-HS256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code AES_192_CBC_HMAC_SHA_384} authenticated encryption algorithm, as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.2.4&quot;&gt;RFC 7518, Section 5.2.4&lt;/a&gt;. This algorithm
&nbsp;         * requires a 384-bit (48 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A192CBC_HS384 = get().forKey(&quot;A192CBC-HS384&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code AES_256_CBC_HMAC_SHA_512} authenticated encryption algorithm, as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.2.5&quot;&gt;RFC 7518, Section 5.2.5&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 512-bit (64 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A256CBC_HS512 = get().forKey(&quot;A256CBC-HS512&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * &amp;quot;AES GCM using 128-bit key&amp;quot; as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.3&quot;&gt;RFC 7518, Section 5.3&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.  This
&nbsp;         * algorithm requires a 128-bit (16 byte) key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 7 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A128GCM = get().forKey(&quot;A128GCM&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * &amp;quot;AES GCM using 192-bit key&amp;quot; as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.3&quot;&gt;RFC 7518, Section 5.3&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.  This
&nbsp;         * algorithm requires a 192-bit (24 byte) key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 7 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A192GCM = get().forKey(&quot;A192GCM&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * &amp;quot;AES GCM using 256-bit key&amp;quot; as defined by
&nbsp;         * &lt;a href=&quot;https://tools.ietf.org/html/rfc7518#section-5.3&quot;&gt;RFC 7518, Section 5.3&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.  This
&nbsp;         * algorithm requires a 256-bit (32 byte) key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 8 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 7 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final AeadAlgorithm A256GCM = get().forKey(&quot;A256GCM&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constants for all JWA (RFC 7518) standard &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3&quot;&gt;
&nbsp;     * Cryptographic Algorithms for Digital Signatures and MACs&lt;/a&gt; defined in the
&nbsp;     * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.1&quot;&gt;JSON Web Signature and Encryption Algorithms
&nbsp;     * Registry&lt;/a&gt;. Each standard algorithm is available as a ({@code public static final}) constant for
&nbsp;     * direct type-safe reference in application code. For example:
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwts.builder()
&nbsp;     *    // ... etc ...
&nbsp;     *    .signWith(aKey, &lt;b&gt;Jwts.SIG.HS512&lt;/b&gt;) // or RS512, PS256, EdDSA, etc...
&nbsp;     *    .build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     * &lt;p&gt;They are also available together as a {@link Registry} instance via the {@link #get()} method.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see #get()
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static final class SIG {
&nbsp;
&nbsp;        private static final String IMPL_CLASSNAME = &quot;io.jsonwebtoken.impl.security.StandardSecureDigestAlgorithms&quot;;
<b class="fc">&nbsp;        private static final Registry&lt;String, SecureDigestAlgorithm&lt;?, ?&gt;&gt; REGISTRY = Classes.newInstance(IMPL_CLASSNAME);</b>
&nbsp;
&nbsp;        //prevent instantiation
&nbsp;        private SIG() {
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns all standard JWA &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3&quot;&gt;Cryptographic
&nbsp;         * Algorithms for Digital Signatures and MACs&lt;/a&gt; defined in the
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.1&quot;&gt;JSON Web Signature and Encryption
&nbsp;         * Algorithms Registry&lt;/a&gt;.
&nbsp;         *
&nbsp;         * @return all standard JWA digital signature and MAC algorithms.
&nbsp;         */
&nbsp;        public static Registry&lt;String, SecureDigestAlgorithm&lt;?, ?&gt;&gt; get() {
<b class="fc">&nbsp;            return REGISTRY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The &amp;quot;none&amp;quot; signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.6&quot;&gt;RFC 7518, Section 3.6&lt;/a&gt;.  This algorithm
&nbsp;         * is used only when creating unsecured (not integrity protected) JWSs and is not usable in any other scenario.
&nbsp;         * Any attempt to call its methods will result in an exception being thrown.
&nbsp;         */
<b class="fc">&nbsp;        public static final SecureDigestAlgorithm&lt;Key, Key&gt; NONE = Jwts.get(REGISTRY, &quot;none&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code HMAC using SHA-256} message authentication algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.2&quot;&gt;RFC 7518, Section 3.2&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 256-bit (32 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final MacAlgorithm HS256 = Jwts.get(REGISTRY, &quot;HS256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code HMAC using SHA-384} message authentication algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.2&quot;&gt;RFC 7518, Section 3.2&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 384-bit (48 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final MacAlgorithm HS384 = Jwts.get(REGISTRY, &quot;HS384&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code HMAC using SHA-512} message authentication algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.2&quot;&gt;RFC 7518, Section 3.2&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 512-bit (64 byte) key.
&nbsp;         */
<b class="fc">&nbsp;        public static final MacAlgorithm HS512 = Jwts.get(REGISTRY, &quot;HS512&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PKCS1-v1_5 using SHA-256} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.3&quot;&gt;RFC 7518, Section 3.3&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 2048-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm RS256 = Jwts.get(REGISTRY, &quot;RS256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PKCS1-v1_5 using SHA-384} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.3&quot;&gt;RFC 7518, Section 3.3&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 2048-bit key, but the JJWT team recommends a 3072-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm RS384 = Jwts.get(REGISTRY, &quot;RS384&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PKCS1-v1_5 using SHA-512} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.3&quot;&gt;RFC 7518, Section 3.3&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 2048-bit key, but the JJWT team recommends a 4096-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm RS512 = Jwts.get(REGISTRY, &quot;RS512&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PSS using SHA-256 and MGF1 with SHA-256} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5&quot;&gt;RFC 7518, Section 3.5&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.
&nbsp;         * This algorithm requires a 2048-bit key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 10 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm PS256 = Jwts.get(REGISTRY, &quot;PS256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PSS using SHA-384 and MGF1 with SHA-384} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5&quot;&gt;RFC 7518, Section 3.5&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.
&nbsp;         * This algorithm requires a 2048-bit key, but the JJWT team recommends a 3072-bit key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 10 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm PS384 = Jwts.get(REGISTRY, &quot;PS384&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code RSASSA-PSS using SHA-512 and MGF1 with SHA-512} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.5&quot;&gt;RFC 7518, Section 3.5&lt;/a&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt;.
&nbsp;         * This algorithm requires a 2048-bit key, but the JJWT team recommends a 4096-bit key.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/b&gt; Requires Java 11 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath. If on Java 10 or earlier, BouncyCastle will be used automatically if found in the runtime
&nbsp;         * classpath.&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm PS512 = Jwts.get(REGISTRY, &quot;PS512&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code ECDSA using P-256 and SHA-256} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4&quot;&gt;RFC 7518, Section 3.4&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 256-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm ES256 = Jwts.get(REGISTRY, &quot;ES256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code ECDSA using P-384 and SHA-384} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4&quot;&gt;RFC 7518, Section 3.4&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 384-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm ES384 = Jwts.get(REGISTRY, &quot;ES384&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code ECDSA using P-521 and SHA-512} signature algorithm as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4&quot;&gt;RFC 7518, Section 3.4&lt;/a&gt;.  This algorithm
&nbsp;         * requires a 521-bit key.
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm ES512 = Jwts.get(REGISTRY, &quot;ES512&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@code EdDSA} signature algorithm defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8037#section-3.1&quot;&gt;RFC 8037, Section 3.1&lt;/a&gt; that requires
&nbsp;         * either {@code Ed25519} or {@code Ed448} Edwards Elliptic Curve&lt;sup&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sup&gt; keys.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;KeyPair Generation&lt;/b&gt;&lt;/p&gt;
&nbsp;         *
&nbsp;         * &lt;p&gt;This instance&#39;s {@link KeyPairBuilderSupplier#keyPair() keyPair()} builder creates {@code Ed448} keys,
&nbsp;         * and is essentially an alias for
&nbsp;         * &lt;code&gt;{@link io.jsonwebtoken.security.Jwks.CRV Jwks.CRV}.{@link io.jsonwebtoken.security.Jwks.CRV#Ed448 Ed448}.{@link KeyPairBuilderSupplier#keyPair() keyPair()}&lt;/code&gt;.&lt;/p&gt;
&nbsp;         *
&nbsp;         * &lt;p&gt;If you would like to generate an {@code Ed25519} {@code KeyPair} for use with the {@code EdDSA} algorithm,
&nbsp;         * you may use the
&nbsp;         * &lt;code&gt;{@link io.jsonwebtoken.security.Jwks.CRV Jwks.CRV}.{@link io.jsonwebtoken.security.Jwks.CRV#Ed25519 Ed25519}.{@link KeyPairBuilderSupplier#keyPair() keyPair()}&lt;/code&gt;
&nbsp;         * builder instead.&lt;/p&gt;
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;&lt;sup&gt;1&lt;/sup&gt;This algorithm requires at least JDK 15 or a compatible JCA Provider (like BouncyCastle) in the runtime
&nbsp;         * classpath.&lt;/b&gt;&lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SignatureAlgorithm EdDSA = Jwts.get(REGISTRY, &quot;EdDSA&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constants for all standard JWA (RFC 7518) &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4&quot;&gt;
&nbsp;     * Cryptographic Algorithms for Key Management&lt;/a&gt;. Each standard algorithm is available as a
&nbsp;     * ({@code public static final}) constant for direct type-safe reference in application code. For example:
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwts.builder()
&nbsp;     *    // ... etc ...
&nbsp;     *    .encryptWith(aKey, &lt;b&gt;Jwts.KEY.ECDH_ES_A256KW&lt;/b&gt;, Jwts.ENC.A256GCM)
&nbsp;     *    .build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     * &lt;p&gt;They are also available together as a {@link Registry} instance via the {@link #get()} method.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see #get()
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static final class KEY {
&nbsp;
&nbsp;        private static final String IMPL_CLASSNAME = &quot;io.jsonwebtoken.impl.security.StandardKeyAlgorithms&quot;;
<b class="fc">&nbsp;        private static final Registry&lt;String, KeyAlgorithm&lt;?, ?&gt;&gt; REGISTRY = Classes.newInstance(IMPL_CLASSNAME);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns all standard JWA standard &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4&quot;&gt;Cryptographic
&nbsp;         * Algorithms for Key Management&lt;/a&gt;..
&nbsp;         *
&nbsp;         * @return all standard JWA Key Management algorithms.
&nbsp;         */
&nbsp;        public static Registry&lt;String, KeyAlgorithm&lt;?, ?&gt;&gt; get() {
<b class="fc">&nbsp;            return REGISTRY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Key algorithm reflecting direct use of a shared symmetric key as the JWE AEAD encryption key, as defined
&nbsp;         * by &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.5&quot;&gt;RFC 7518 (JWA), Section 4.5&lt;/a&gt;.  This
&nbsp;         * algorithm does not produce encrypted key ciphertext.
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;SecretKey, SecretKey&gt; DIRECT = Jwts.get(REGISTRY, &quot;dir&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * AES Key Wrap algorithm with default initial value using a 128-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.4&quot;&gt;RFC 7518 (JWA), Section 4.4&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 128-bit shared symmetric key using the
&nbsp;         *     AES Key Wrap algorithm, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 128-bit shared symmetric key,
&nbsp;         *     using the AES Key Unwrap algorithm, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A128KW = Jwts.get(REGISTRY, &quot;A128KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * AES Key Wrap algorithm with default initial value using a 192-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.4&quot;&gt;RFC 7518 (JWA), Section 4.4&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 192-bit shared symmetric key using the
&nbsp;         *     AES Key Wrap algorithm, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 192-bit shared symmetric key,
&nbsp;         *     using the AES Key Unwrap algorithm, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A192KW = Jwts.get(REGISTRY, &quot;A192KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * AES Key Wrap algorithm with default initial value using a 256-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.4&quot;&gt;RFC 7518 (JWA), Section 4.4&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 256-bit shared symmetric key using the
&nbsp;         *     AES Key Wrap algorithm, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 256-bit shared symmetric key,
&nbsp;         *     using the AES Key Unwrap algorithm, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A256KW = Jwts.get(REGISTRY, &quot;A256KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key wrap algorithm with AES GCM using a 128-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7&quot;&gt;RFC 7518 (JWA), Section 4.7&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random 96-bit Initialization Vector to use during key wrap/encryption.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 128-bit shared symmetric key using the
&nbsp;         *     AES GCM Key Wrap algorithm with the generated Initialization Vector, producing encrypted key ciphertext
&nbsp;         *     and GCM authentication tag.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated initialization vector as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the resulting GCM authentication tag as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required initialization vector from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required GCM authentication tag from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 128-bit shared symmetric key, the initialization vector
&nbsp;         *     and GCM authentication tag using the AES GCM Key Unwrap algorithm, producing the decryption key
&nbsp;         *     plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A128GCMKW = Jwts.get(REGISTRY, &quot;A128GCMKW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key wrap algorithm with AES GCM using a 192-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7&quot;&gt;RFC 7518 (JWA), Section 4.7&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random 96-bit Initialization Vector to use during key wrap/encryption.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 192-bit shared symmetric key using the
&nbsp;         *     AES GCM Key Wrap algorithm with the generated Initialization Vector, producing encrypted key ciphertext
&nbsp;         *     and GCM authentication tag.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated initialization vector as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the resulting GCM authentication tag as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required initialization vector from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required GCM authentication tag from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 192-bit shared symmetric key, the initialization vector
&nbsp;         *     and GCM authentication tag using the AES GCM Key Unwrap algorithm, producing the decryption key \
&nbsp;         *     plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A192GCMKW = Jwts.get(REGISTRY, &quot;A192GCMKW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key wrap algorithm with AES GCM using a 256-bit key, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7&quot;&gt;RFC 7518 (JWA), Section 4.7&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random 96-bit Initialization Vector to use during key wrap/encryption.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with a 256-bit shared symmetric key using the
&nbsp;         *     AES GCM Key Wrap algorithm with the generated Initialization Vector, producing encrypted key ciphertext
&nbsp;         *     and GCM authentication tag.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated initialization vector as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the resulting GCM authentication tag as the required
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required initialization vector from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.1&quot;&gt;&amp;quot;iv&amp;quot;
&nbsp;         *     (Initialization Vector) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required GCM authentication tag from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.7.1.2&quot;&gt;&amp;quot;tag&amp;quot;
&nbsp;         *     (Authentication Tag) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the 256-bit shared symmetric key, the initialization vector
&nbsp;         *     and GCM authentication tag using the AES GCM Key Unwrap algorithm, producing the decryption key \
&nbsp;         *     plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final SecretKeyAlgorithm A256GCMKW = Jwts.get(REGISTRY, &quot;A256GCMKW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key encryption algorithm using &lt;code&gt;PBES2 with HMAC SHA-256 and &amp;quot;A128KW&amp;quot; wrapping&lt;/code&gt;
&nbsp;         * as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8&quot;&gt;RFC 7518 (JWA), Section 4.8&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Determines the number of PBDKF2 iterations via the JWE header&#39;s
&nbsp;         *     {@link JweHeader#getPbes2Count() pbes2Count} value.  If that value is not set, a suitable number of
&nbsp;         *     iterations will be chosen based on
&nbsp;         *     &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2&quot;&gt;OWASP
&nbsp;         *     PBKDF2 recommendations&lt;/a&gt; and then that value is set as the JWE header {@code pbes2Count} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random salt input and sets it as the JWE header
&nbsp;         *     {@link JweHeader#getPbes2Salt() pbes2Salt} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives a 128-bit Key Encryption Key with the PBES2-HS256 password-based key derivation algorithm,
&nbsp;         *     using the provided password, iteration count, and input salt as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Content Encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated Content Encryption {@code SecretKey} with the {@code A128KW} key wrap
&nbsp;         *      algorithm using the 128-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     Content Encryption {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated
&nbsp;         *     {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 input salt from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.1&quot;&gt;&amp;quot;p2s&amp;quot;
&nbsp;         *     (PBES2 Salt Input) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 iteration count from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.2&quot;&gt;&amp;quot;p2c&amp;quot;
&nbsp;         *     (PBES2 Count) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives the 128-bit Key Encryption Key with the PBES2-HS256 password-based key derivation algorithm,
&nbsp;         *     using the provided password, obtained salt input, and obtained iteration count as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with with the {@code A128KW} key unwrap
&nbsp;         *      algorithm using the 128-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;Password, Password&gt; PBES2_HS256_A128KW = Jwts.get(REGISTRY, &quot;PBES2-HS256+A128KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key encryption algorithm using &lt;code&gt;PBES2 with HMAC SHA-384 and &amp;quot;A192KW&amp;quot; wrapping&lt;/code&gt;
&nbsp;         * as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8&quot;&gt;RFC 7518 (JWA), Section 4.8&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Determines the number of PBDKF2 iterations via the JWE header&#39;s
&nbsp;         *     {@link JweHeader#getPbes2Count() pbes2Count} value.  If that value is not set, a suitable number of
&nbsp;         *     iterations will be chosen based on
&nbsp;         *     &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2&quot;&gt;OWASP
&nbsp;         *     PBKDF2 recommendations&lt;/a&gt; and then that value is set as the JWE header {@code pbes2Count} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random salt input and sets it as the JWE header
&nbsp;         *     {@link JweHeader#getPbes2Salt() pbes2Salt} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives a 192-bit Key Encryption Key with the PBES2-HS384 password-based key derivation algorithm,
&nbsp;         *     using the provided password, iteration count, and input salt as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Content Encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated Content Encryption {@code SecretKey} with the {@code A192KW} key wrap
&nbsp;         *      algorithm using the 192-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     Content Encryption {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated
&nbsp;         *     {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 input salt from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.1&quot;&gt;&amp;quot;p2s&amp;quot;
&nbsp;         *     (PBES2 Salt Input) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 iteration count from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.2&quot;&gt;&amp;quot;p2c&amp;quot;
&nbsp;         *     (PBES2 Count) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives the 192-bit Key Encryption Key with the PBES2-HS384 password-based key derivation algorithm,
&nbsp;         *     using the provided password, obtained salt input, and obtained iteration count as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with with the {@code A192KW} key unwrap
&nbsp;         *      algorithm using the 192-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;Password, Password&gt; PBES2_HS384_A192KW = Jwts.get(REGISTRY, &quot;PBES2-HS384+A192KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key encryption algorithm using &lt;code&gt;PBES2 with HMAC SHA-512 and &amp;quot;A256KW&amp;quot; wrapping&lt;/code&gt;
&nbsp;         * as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8&quot;&gt;RFC 7518 (JWA), Section 4.8&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Determines the number of PBDKF2 iterations via the JWE header&#39;s
&nbsp;         *     {@link JweHeader#getPbes2Count() pbes2Count} value.  If that value is not set, a suitable number of
&nbsp;         *     iterations will be chosen based on
&nbsp;         *     &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2&quot;&gt;OWASP
&nbsp;         *     PBKDF2 recommendations&lt;/a&gt; and then that value is set as the JWE header {@code pbes2Count} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random salt input and sets it as the JWE header
&nbsp;         *     {@link JweHeader#getPbes2Salt() pbes2Salt} value.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives a 256-bit Key Encryption Key with the PBES2-HS512 password-based key derivation algorithm,
&nbsp;         *     using the provided password, iteration count, and input salt as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Content Encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated Content Encryption {@code SecretKey} with the {@code A256KW} key wrap
&nbsp;         *      algorithm using the 256-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     Content Encryption {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated
&nbsp;         *     {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 input salt from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.1&quot;&gt;&amp;quot;p2s&amp;quot;
&nbsp;         *     (PBES2 Salt Input) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the required PBKDF2 iteration count from the
&nbsp;         *     &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.8.1.2&quot;&gt;&amp;quot;p2c&amp;quot;
&nbsp;         *     (PBES2 Count) Header Parameter&lt;/a&gt;&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Derives the 256-bit Key Encryption Key with the PBES2-HS512 password-based key derivation algorithm,
&nbsp;         *     using the provided password, obtained salt input, and obtained iteration count as arguments.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with with the {@code A256KW} key unwrap
&nbsp;         *      algorithm using the 256-bit derived password-based Key Encryption Key from step {@code #3},
&nbsp;         *      producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;Password, Password&gt; PBES2_HS512_A256KW = Jwts.get(REGISTRY, &quot;PBES2-HS512+A256KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Encryption with {@code RSAES-PKCS1-v1_5}, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.2&quot;&gt;RFC 7518 (JWA), Section 4.2&lt;/a&gt;.
&nbsp;         * This algorithm requires a key size of 2048 bits or larger.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the RSA key wrap algorithm, using the JWE
&nbsp;         *     recipient&#39;s RSA Public Key, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Receives the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the RSA key unwrap algorithm, using the JWE recipient&#39;s
&nbsp;         *     RSA Private Key, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}. &lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; RSA1_5 = Jwts.get(REGISTRY, &quot;RSA1_5&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Encryption with {@code RSAES OAEP using default parameters}, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.3&quot;&gt;RFC 7518 (JWA), Section 4.3&lt;/a&gt;.
&nbsp;         * This algorithm requires a key size of 2048 bits or larger.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the RSA OAEP with SHA-1 and MGF1 key wrap algorithm,
&nbsp;         *     using the JWE recipient&#39;s RSA Public Key, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Receives the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the RSA OAEP with SHA-1 and MGF1 key unwrap algorithm,
&nbsp;         *     using the JWE recipient&#39;s RSA Private Key, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}. &lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; RSA_OAEP = Jwts.get(REGISTRY, &quot;RSA-OAEP&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Encryption with {@code RSAES OAEP using SHA-256 and MGF1 with SHA-256}, as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.3&quot;&gt;RFC 7518 (JWA), Section 4.3&lt;/a&gt;.
&nbsp;         * This algorithm requires a key size of 2048 bits or larger.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *     specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the RSA OAEP with SHA-256 and MGF1 key wrap
&nbsp;         *     algorithm, using the JWE recipient&#39;s RSA Public Key, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Receives the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Decrypts the encrypted key ciphertext with the RSA OAEP with SHA-256 and MGF1 key unwrap algorithm,
&nbsp;         *     using the JWE recipient&#39;s RSA Private Key, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *     JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}. &lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; RSA_OAEP_256 = Jwts.get(REGISTRY, &quot;RSA-OAEP-256&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Agreement with {@code ECDH-ES using Concat KDF} as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6&quot;&gt;RFC 7518 (JWA), Section 4.6&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Elliptic Curve public/private key pair on the same curve as the
&nbsp;         *     JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a shared secret with the ECDH key agreement algorithm using the generated EC Private Key
&nbsp;         *     and the JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; a symmetric Content
&nbsp;         *     Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *     generated shared secret and any available
&nbsp;         *     {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *     {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated EC key pair&#39;s Public Key as the required
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt; to be transmitted in the JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the derived symmetric {@code SecretKey} for JJWT to use to encrypt the entire JWE with the
&nbsp;         *     associated {@link AeadAlgorithm}. Encrypted key ciphertext is not produced with this algorithm, so
&nbsp;         *     the resulting JWE will not contain any embedded key ciphertext.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required ephemeral Elliptic Curve Public Key from the
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt;.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Validates that the ephemeral Public Key is on the same curve as the recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the shared secret with the ECDH key agreement algorithm using the obtained EC Public Key
&nbsp;         *      and the JWE recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; the symmetric Content
&nbsp;         *      Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *      obtained shared secret and any available
&nbsp;         *      {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *      {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Returns the derived symmetric {@code SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *      JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; ECDH_ES = Jwts.get(REGISTRY, &quot;ECDH-ES&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Agreement with Key Wrapping via
&nbsp;         * &lt;code&gt;ECDH-ES using Concat KDF and CEK wrapped with &amp;quot;A128KW&amp;quot;&lt;/code&gt; as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6&quot;&gt;RFC 7518 (JWA), Section 4.6&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Elliptic Curve public/private key pair on the same curve as the
&nbsp;         *     JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a shared secret with the ECDH key agreement algorithm using the generated EC Private Key
&nbsp;         *     and the JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; a 128-bit symmetric Key
&nbsp;         *     Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *     generated shared secret and any available
&nbsp;         *     {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *     {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated EC key pair&#39;s Public Key as the required
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt; to be transmitted in the JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the {@code A128KW} key wrap
&nbsp;         *      algorithm using the derived symmetric Key Encryption Key from step {@code #3}, producing encrypted key ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required ephemeral Elliptic Curve Public Key from the
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt;.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Validates that the ephemeral Public Key is on the same curve as the recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the shared secret with the ECDH key agreement algorithm using the obtained EC Public Key
&nbsp;         *      and the JWE recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; the symmetric Key
&nbsp;         *      Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *      obtained shared secret and any available
&nbsp;         *      {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *      {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Decrypts the encrypted key ciphertext with the AES Key Unwrap algorithm using the
&nbsp;         *      128-bit derived symmetric key from step {@code #4}, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *      JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; ECDH_ES_A128KW = Jwts.get(REGISTRY, &quot;ECDH-ES+A128KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Agreement with Key Wrapping via
&nbsp;         * &lt;code&gt;ECDH-ES using Concat KDF and CEK wrapped with &amp;quot;A192KW&amp;quot;&lt;/code&gt; as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6&quot;&gt;RFC 7518 (JWA), Section 4.6&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Elliptic Curve public/private key pair on the same curve as the
&nbsp;         *     JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a shared secret with the ECDH key agreement algorithm using the generated EC Private Key
&nbsp;         *     and the JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; a 192-bit symmetric Key
&nbsp;         *     Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *     generated shared secret and any available
&nbsp;         *     {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *     {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated EC key pair&#39;s Public Key as the required
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt; to be transmitted in the JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the {@code A192KW} key wrap
&nbsp;         *      algorithm using the derived symmetric Key Encryption Key from step {@code #3}, producing encrypted key
&nbsp;         *      ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required ephemeral Elliptic Curve Public Key from the
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt;.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Validates that the ephemeral Public Key is on the same curve as the recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the shared secret with the ECDH key agreement algorithm using the obtained EC Public Key
&nbsp;         *      and the JWE recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; the 192-bit symmetric
&nbsp;         *      Key Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *      obtained shared secret and any available
&nbsp;         *      {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *      {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Decrypts the encrypted key ciphertext with the AES Key Unwrap algorithm using the
&nbsp;         *      192-bit derived symmetric key from step {@code #4}, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *      JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; ECDH_ES_A192KW = Jwts.get(REGISTRY, &quot;ECDH-ES+A192KW&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Key Agreement with Key Wrapping via
&nbsp;         * &lt;code&gt;ECDH-ES using Concat KDF and CEK wrapped with &amp;quot;A256KW&amp;quot;&lt;/code&gt; as defined by
&nbsp;         * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6&quot;&gt;RFC 7518 (JWA), Section 4.6&lt;/a&gt;.
&nbsp;         *
&nbsp;         * &lt;p&gt;During JWE creation, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random Elliptic Curve public/private key pair on the same curve as the
&nbsp;         *     JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a shared secret with the ECDH key agreement algorithm using the generated EC Private Key
&nbsp;         *     and the JWE recipient&#39;s EC Public Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; a 256-bit symmetric Key
&nbsp;         *     Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *     generated shared secret and any available
&nbsp;         *     {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *     {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Sets the generated EC key pair&#39;s Public Key as the required
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt; to be transmitted in the JWE.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Generates a new secure-random content encryption {@link SecretKey} suitable for use with a
&nbsp;         *      specified {@link AeadAlgorithm} (using {@link AeadAlgorithm#key()}).&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Encrypts this newly-generated {@code SecretKey} with the {@code A256KW} key wrap
&nbsp;         *      algorithm using the derived symmetric Key Encryption Key from step {@code #3}, producing encrypted key
&nbsp;         *      ciphertext.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Returns the encrypted key ciphertext for inclusion in the final JWE as well as the newly-generated
&nbsp;         *     {@code SecretKey} for JJWT to use to encrypt the entire JWE with associated {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         * &lt;p&gt;For JWE decryption, this algorithm:&lt;/p&gt;
&nbsp;         * &lt;ol&gt;
&nbsp;         *     &lt;li&gt;Obtains the required ephemeral Elliptic Curve Public Key from the
&nbsp;         *      &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.1.1&quot;&gt;&amp;quot;epk&amp;quot;
&nbsp;         *      (Ephemeral Public Key) Header Parameter&lt;/a&gt;.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Validates that the ephemeral Public Key is on the same curve as the recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;Obtains the shared secret with the ECDH key agreement algorithm using the obtained EC Public Key
&nbsp;         *      and the JWE recipient&#39;s EC Private Key.&lt;/li&gt;
&nbsp;         *     &lt;li&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-4.6.2&quot;&gt;Derives&lt;/a&gt; the 256-bit symmetric
&nbsp;         *      Key Encryption {@code SecretKey} with the Concat KDF algorithm using the
&nbsp;         *      obtained shared secret and any available
&nbsp;         *      {@link JweHeader#getAgreementPartyUInfo() PartyUInfo} and
&nbsp;         *      {@link JweHeader#getAgreementPartyVInfo() PartyVInfo}.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Obtains the encrypted key ciphertext embedded in the received JWE.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Decrypts the encrypted key ciphertext with the AES Key Unwrap algorithm using the
&nbsp;         *      256-bit derived symmetric key from step {@code #4}, producing the decryption key plaintext.&lt;/li&gt;
&nbsp;         *      &lt;li&gt;Returns the decryption key plaintext as a {@link SecretKey} for JJWT to use to decrypt the entire
&nbsp;         *      JWE using the JWE&#39;s identified &amp;quot;enc&amp;quot; {@link AeadAlgorithm}.&lt;/li&gt;
&nbsp;         * &lt;/ol&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final KeyAlgorithm&lt;PublicKey, PrivateKey&gt; ECDH_ES_A256KW = Jwts.get(REGISTRY, &quot;ECDH-ES+A256KW&quot;);</b>
&nbsp;
&nbsp;        //prevent instantiation
&nbsp;        private KEY() {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constants for JWA (RFC 7518) compression algorithms referenced in the {@code zip} header defined in the
&nbsp;     * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.3&quot;&gt;JSON Web Encryption Compression Algorithms
&nbsp;     * Registry&lt;/a&gt;. Each algorithm is available as a ({@code public static final}) constant for
&nbsp;     * direct type-safe reference in application code. For example:
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;     * Jwts.builder()
&nbsp;     *    // ... etc ...
&nbsp;     *    .compressWith(&lt;b&gt;Jwts.ZIP.DEF&lt;/b&gt;)
&nbsp;     *    .build();&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     * &lt;p&gt;They are also available together as a {@link Registry} instance via the {@link #get()} method.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @see #get()
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static final class ZIP {
&nbsp;
&nbsp;        private static final String IMPL_CLASSNAME = &quot;io.jsonwebtoken.impl.io.StandardCompressionAlgorithms&quot;;
<b class="fc">&nbsp;        private static final Registry&lt;String, CompressionAlgorithm&gt; REGISTRY = Classes.newInstance(IMPL_CLASSNAME);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns various useful &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-7.3&quot;&gt;
&nbsp;         * Compression Algorithms&lt;/a&gt;.
&nbsp;         *
&nbsp;         * @return various standard and non-standard useful compression algorithms.
&nbsp;         */
&nbsp;        public static Registry&lt;String, CompressionAlgorithm&gt; get() {
<b class="fc">&nbsp;            return REGISTRY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The JWE-standard &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc1951&quot;&gt;DEFLATE&lt;/a&gt;
&nbsp;         * compression algorithm with a {@code zip} header value of {@code &quot;DEF&quot;}.
&nbsp;         *
&nbsp;         * @see &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7516.html#section-4.1.3&quot;&gt;JWE RFC 7516, Section 4.1.3&lt;/a&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static final CompressionAlgorithm DEF = get().forKey(&quot;DEF&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A commonly used, but &lt;b&gt;NOT JWA-STANDARD&lt;/b&gt;
&nbsp;         * &lt;a href=&quot;https://en.wikipedia.org/wiki/Gzip&quot;&gt;gzip&lt;/a&gt; compression algorithm with a {@code zip} header value
&nbsp;         * of {@code &quot;GZIP&quot;}.
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;Compatibility Warning&lt;/b&gt;&lt;/p&gt;
&nbsp;         *
&nbsp;         * &lt;p&gt;&lt;b&gt;This is not a standard JWE compression algorithm&lt;/b&gt;.  Be sure to use this only when you are confident
&nbsp;         * that all parties accessing the token support the &amp;quot;GZIP&amp;quot; identifier and associated algorithm.&lt;/p&gt;
&nbsp;         *
&nbsp;         * &lt;p&gt;If you&#39;re concerned about compatibility, {@link #DEF DEF} is the only JWA standards-compliant algorithm.&lt;/p&gt;
&nbsp;         *
&nbsp;         * @see #DEF
&nbsp;         */
<b class="fc">&nbsp;        public static final CompressionAlgorithm GZIP = get().forKey(&quot;GZIP&quot;);</b>
&nbsp;
&nbsp;        //prevent instantiation
&nbsp;        private ZIP() {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link Builder} that dynamically determines the type of {@link Header} to create based on builder state.
&nbsp;     *
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public interface HeaderBuilder extends JweHeaderMutator&lt;HeaderBuilder&gt;, X509Builder&lt;HeaderBuilder&gt;, Builder&lt;Header&gt; {
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new {@link HeaderBuilder} that can build any type of {@link Header} instance depending on
&nbsp;     * which builder properties are set.
&nbsp;     *
&nbsp;     * @return a new {@link HeaderBuilder} that can build any type of {@link Header} instance depending on
&nbsp;     * which builder properties are set.
&nbsp;     * @since 0.12.0
&nbsp;     */
&nbsp;    public static HeaderBuilder header() {
<b class="fc">&nbsp;        return Classes.newInstance(&quot;io.jsonwebtoken.impl.DefaultJwtHeaderBuilder&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new {@link Claims} builder instance to be used to populate JWT claims, which in aggregate will be
&nbsp;     * the JWT payload.
&nbsp;     *
&nbsp;     * @return a new {@link Claims} builder instance to be used to populate JWT claims, which in aggregate will be
&nbsp;     * the JWT payload.
&nbsp;     */
&nbsp;    public static ClaimsBuilder claims() {
<b class="fc">&nbsp;        return Classes.newInstance(&quot;io.jsonwebtoken.impl.DefaultClaimsBuilder&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;&lt;b&gt;Deprecated since 0.12.0 in favor of
&nbsp;     * {@code Jwts.}{@link #claims()}{@code .add(map).build()}&lt;/b&gt;.
&nbsp;     * This method will be removed before 1.0.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;Returns a new {@link Claims} instance populated with the specified name/value pairs.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param claims the name/value pairs to populate the new Claims instance.
&nbsp;     * @return a new {@link Claims} instance populated with the specified name/value pairs.
&nbsp;     * @deprecated since 0.12.0 in favor of {@code Jwts.}{@link #claims()}{@code .putAll(map).build()}.
&nbsp;     * This method will be removed before 1.0.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static Claims claims(Map&lt;String, Object&gt; claims) {
<b class="fc">&nbsp;        return claims().add(claims).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new {@link JwtBuilder} instance that can be configured and then used to create JWT compact serialized
&nbsp;     * strings.
&nbsp;     *
&nbsp;     * @return a new {@link JwtBuilder} instance that can be configured and then used to create JWT compact serialized
&nbsp;     * strings.
&nbsp;     */
&nbsp;    public static JwtBuilder builder() {
<b class="fc">&nbsp;        return Classes.newInstance(&quot;io.jsonwebtoken.impl.DefaultJwtBuilder&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new {@link JwtParserBuilder} instance that can be configured to create an immutable/thread-safe {@link JwtParser}.
&nbsp;     *
&nbsp;     * @return a new {@link JwtParser} instance that can be configured create an immutable/thread-safe {@link JwtParser}.
&nbsp;     */
&nbsp;    public static JwtParserBuilder parser() {
<b class="fc">&nbsp;        return Classes.newInstance(&quot;io.jsonwebtoken.impl.DefaultJwtParserBuilder&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Private constructor, prevent instantiation.
&nbsp;     */
&nbsp;    private Jwts() {
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
