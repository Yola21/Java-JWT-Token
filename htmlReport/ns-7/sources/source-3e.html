


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > EcSignatureAlgorithm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.security</a>
</div>

<h1>Coverage Summary for Class: EcSignatureAlgorithm (io.jsonwebtoken.impl.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EcSignatureAlgorithm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (76/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (118/118)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EcSignatureAlgorithm$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EcSignatureAlgorithm$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.5%
  </span>
  <span class="absValue">
    (83/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (139/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2021 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.security;
&nbsp;
&nbsp;import io.jsonwebtoken.JwtException;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.impl.lang.CheckedFunction;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.KeyPairBuilder;
&nbsp;import io.jsonwebtoken.security.SecureRequest;
&nbsp;import io.jsonwebtoken.security.SignatureAlgorithm;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;import io.jsonwebtoken.security.VerifySecureDigestRequest;
&nbsp;
&nbsp;import java.io.InputStream;
&nbsp;import java.math.BigInteger;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.PublicKey;
&nbsp;import java.security.Signature;
&nbsp;import java.security.interfaces.ECKey;
&nbsp;import java.security.spec.ECGenParameterSpec;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;// @since 0.12.0
<b class="fc">&nbsp;final class EcSignatureAlgorithm extends AbstractSignatureAlgorithm {</b>
&nbsp;
&nbsp;    private static final String REQD_ORDER_BIT_LENGTH_MSG = &quot;orderBitLength must equal 256, 384, or 521.&quot;;
&nbsp;
&nbsp;    private static final String DER_ENCODING_SYS_PROPERTY_NAME = &quot;io.jsonwebtoken.impl.crypto.EllipticCurveSignatureValidator.derEncodingSupported&quot;;
&nbsp;
&nbsp;    private static final String ES256_OID = &quot;1.2.840.10045.4.3.2&quot;;
&nbsp;    private static final String ES384_OID = &quot;1.2.840.10045.4.3.3&quot;;
&nbsp;    private static final String ES512_OID = &quot;1.2.840.10045.4.3.4&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final Set&lt;String&gt; KEY_ALG_NAMES = Collections.setOf(&quot;EC&quot;, &quot;ECDSA&quot;, ES256_OID, ES384_OID, ES512_OID);</b>
&nbsp;
&nbsp;    private final ECGenParameterSpec KEY_PAIR_GEN_PARAMS;
&nbsp;
&nbsp;    private final int orderBitLength;
&nbsp;
&nbsp;    private final String OID;
&nbsp;
&nbsp;    /**
&nbsp;     * JWA EC (concat formatted) length in bytes for this instance&#39;s {@link #orderBitLength}.
&nbsp;     */
&nbsp;    private final int signatureByteLength;
&nbsp;    private final int sigFieldByteLength;
&nbsp;
&nbsp;    private static int shaSize(int orderBitLength) {
<b class="fc">&nbsp;        return orderBitLength == 521 ? 512 : orderBitLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} for Order bit lengths defined in the JWA specification, {@code false} otherwise.
&nbsp;     * Specifically, returns {@code true} &lt;em&gt;only&lt;/em&gt; for values of {@code 256}, {@code 384} and {@code 521}.  See
&nbsp;     * &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4&quot;&gt;RFC 7518, Section 3.4&lt;/a&gt; for more.
&nbsp;     *
&nbsp;     * @param orderBitLength the EC key Order bit length to check
&nbsp;     * @return {@code true} for Order bit lengths defined in the JWA specification, {@code false} otherwise.
&nbsp;     */
&nbsp;    private static boolean isSupportedOrderBitLength(int orderBitLength) {
&nbsp;        // This implementation supports only those defined in the JWA specification.
<b class="fc">&nbsp;        return orderBitLength == 256 || orderBitLength == 384 || orderBitLength == 521;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static final EcSignatureAlgorithm ES256 = new EcSignatureAlgorithm(256, ES256_OID);</b>
<b class="fc">&nbsp;    static final EcSignatureAlgorithm ES384 = new EcSignatureAlgorithm(384, ES384_OID);</b>
<b class="fc">&nbsp;    static final EcSignatureAlgorithm ES512 = new EcSignatureAlgorithm(521, ES512_OID);</b>
&nbsp;
<b class="fc">&nbsp;    private static final Map&lt;String, SignatureAlgorithm&gt; BY_OID = new LinkedHashMap&lt;&gt;(3);</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        for (EcSignatureAlgorithm alg : Collections.of(ES256, ES384, ES512)) {</b>
<b class="fc">&nbsp;            BY_OID.put(alg.OID, alg);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    static SignatureAlgorithm findByKey(Key key) {
&nbsp;
<b class="fc">&nbsp;        String algName = KeysBridge.findAlgorithm(key);</b>
<b class="fc">&nbsp;        if (!Strings.hasText(algName)) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        algName = algName.toUpperCase(Locale.ENGLISH);</b>
&nbsp;
<b class="fc">&nbsp;        SignatureAlgorithm alg = BY_OID.get(algName);</b>
<b class="fc">&nbsp;        if (alg != null) {</b>
<b class="fc">&nbsp;            return alg;</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (&quot;EC&quot;.equalsIgnoreCase(algName) || &quot;ECDSA&quot;.equalsIgnoreCase(algName)) {</b>
&nbsp;            // some PKCS11 keystores and HSMs won&#39;t expose the RSAKey interface, so we can&#39;t assume it:
<b class="fc">&nbsp;            final int bitLength = KeysBridge.findBitLength(key); // returns -1 if we&#39;re unable to find out</b>
<b class="fc">&nbsp;            if (bitLength == ES512.orderBitLength) {</b>
<b class="fc">&nbsp;                return ES512;</b>
<b class="fc">&nbsp;            } else if (bitLength == ES384.orderBitLength) {</b>
<b class="fc">&nbsp;                return ES384;</b>
<b class="fc">&nbsp;            } else if (bitLength == ES256.orderBitLength) {</b>
<b class="fc">&nbsp;                return ES256;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private EcSignatureAlgorithm(int orderBitLength, String oid) {
<b class="fc">&nbsp;        super(&quot;ES&quot; + shaSize(orderBitLength), &quot;SHA&quot; + shaSize(orderBitLength) + &quot;withECDSA&quot;);</b>
<b class="fc">&nbsp;        Assert.isTrue(isSupportedOrderBitLength(orderBitLength), REQD_ORDER_BIT_LENGTH_MSG);</b>
<b class="fc">&nbsp;        this.OID = Assert.hasText(oid, &quot;Invalid OID.&quot;);</b>
<b class="fc">&nbsp;        String curveName = &quot;secp&quot; + orderBitLength + &quot;r1&quot;;</b>
<b class="fc">&nbsp;        this.KEY_PAIR_GEN_PARAMS = new ECGenParameterSpec(curveName);</b>
<b class="fc">&nbsp;        this.orderBitLength = orderBitLength;</b>
<b class="fc">&nbsp;        this.sigFieldByteLength = Bytes.length(this.orderBitLength);</b>
<b class="fc">&nbsp;        this.signatureByteLength = this.sigFieldByteLength * 2; // R bytes + S bytes = concat signature bytes</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public KeyPairBuilder keyPair() {
<b class="fc">&nbsp;        return new DefaultKeyPairBuilder(ECCurve.KEY_PAIR_GENERATOR_JCA_NAME, this.KEY_PAIR_GEN_PARAMS)</b>
<b class="fc">&nbsp;                .random(Randoms.secureRandom());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void validateKey(Key key, boolean signing) {
<b class="fc">&nbsp;        super.validateKey(key, signing);</b>
<b class="fc">&nbsp;        if (!KEY_ALG_NAMES.contains(KeysBridge.findAlgorithm(key))) {</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(&quot;Unrecognized EC key algorithm name.&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        int size = KeysBridge.findBitLength(key);</b>
<b class="fc">&nbsp;        if (size &lt; 0) return; // likely PKCS11 or HSM key, can&#39;t get the data we need</b>
<b class="fc">&nbsp;        int sigFieldByteLength = Bytes.length(size);</b>
<b class="fc">&nbsp;        int concatByteLength = sigFieldByteLength * 2;</b>
<b class="fc">&nbsp;        if (concatByteLength != this.signatureByteLength) {</b>
<b class="fc">&nbsp;            String msg = &quot;The provided Elliptic Curve &quot; + keyType(signing) +</b>
<b class="fc">&nbsp;                    &quot; key size (aka order bit length) is &quot; + Bytes.bitsMsg(size) + &quot;, but the &#39;&quot; +</b>
<b class="fc">&nbsp;                    getId() + &quot;&#39; algorithm requires EC Keys with &quot; + Bytes.bitsMsg(this.orderBitLength) +</b>
&nbsp;                    &quot; per [RFC 7518, Section 3.4](https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4).&quot;;
<b class="fc">&nbsp;            throw new InvalidKeyException(msg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected byte[] doDigest(final SecureRequest&lt;InputStream, PrivateKey&gt; request) {
<b class="fc">&nbsp;        return jca(request).withSignature(new CheckedFunction&lt;Signature, byte[]&gt;() {</b>
&nbsp;            @Override
&nbsp;            public byte[] apply(Signature sig) throws Exception {
<b class="fc">&nbsp;                sig.initSign(KeysBridge.root(request));</b>
<b class="fc">&nbsp;                byte[] signature = sign(sig, request.getPayload());</b>
<b class="fc">&nbsp;                return transcodeDERToConcat(signature, signatureByteLength);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    boolean isValidRAndS(PublicKey key, byte[] concatSignature) {
<b class="fc">&nbsp;        if (key instanceof ECKey) { //Some PKCS11 providers and HSMs won&#39;t expose the ECKey interface, so we have to check first</b>
<b class="fc">&nbsp;            ECKey ecKey = (ECKey) key;</b>
<b class="fc">&nbsp;            BigInteger order = ecKey.getParams().getOrder();</b>
<b class="fc">&nbsp;            BigInteger r = new BigInteger(1, Arrays.copyOfRange(concatSignature, 0, sigFieldByteLength));</b>
<b class="fc">&nbsp;            BigInteger s = new BigInteger(1, Arrays.copyOfRange(concatSignature, sigFieldByteLength, concatSignature.length));</b>
<b class="pc">&nbsp;            return r.signum() &gt;= 1 &amp;&amp; s.signum() &gt;= 1 &amp;&amp; r.compareTo(order) &lt; 0 &amp;&amp; s.compareTo(order) &lt; 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected boolean doVerify(final VerifySecureDigestRequest&lt;PublicKey&gt; request) {
&nbsp;
<b class="fc">&nbsp;        final PublicKey key = request.getKey();</b>
&nbsp;
<b class="fc">&nbsp;        return jca(request).withSignature(new CheckedFunction&lt;Signature, Boolean&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Boolean apply(Signature sig) {
<b class="fc">&nbsp;                byte[] concatSignature = request.getDigest();</b>
&nbsp;                byte[] derSignature;
&nbsp;                try {
&nbsp;                    // mandated per https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4 :
<b class="fc">&nbsp;                    if (signatureByteLength != concatSignature.length) {</b>
&nbsp;                        /*
&nbsp;                         * If the expected size is not valid for JOSE, fall back to ASN.1 DER signature IFF the application
&nbsp;                         * is configured to do so.  This fallback is for backwards compatibility ONLY (to support tokens
&nbsp;                         * generated by early versions of jjwt) and backwards compatibility will be removed in a future
&nbsp;                         * version of this library.  This fallback is only enabled if the system property is set to &#39;true&#39; due to
&nbsp;                         * the risk of CVE-2022-21449 attacks on early JVM versions 15, 17 and 18.
&nbsp;                         */
&nbsp;                        // TODO: remove for 1.0 (DER-encoding support is not in the JWT RFCs)
<b class="pc">&nbsp;                        if (concatSignature[0] == 0x30 &amp;&amp;</b>
<b class="fc">&nbsp;                                &quot;true&quot;.equalsIgnoreCase(System.getProperty(DER_ENCODING_SYS_PROPERTY_NAME))) {</b>
<b class="fc">&nbsp;                            derSignature = concatSignature;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            String msg = &quot;Provided signature is &quot; + Bytes.bytesMsg(concatSignature.length) + &quot; but &quot; +</b>
<b class="fc">&nbsp;                                    getId() + &quot; signatures must be exactly &quot; + Bytes.bytesMsg(signatureByteLength) +</b>
&nbsp;                                    &quot; per [RFC 7518, Section 3.4 (validation)]&quot; +
&nbsp;                                    &quot;(https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4).&quot;;
<b class="fc">&nbsp;                            throw new SignatureException(msg);</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        //guard for JVM security bug CVE-2022-21449:
<b class="fc">&nbsp;                        if (!isValidRAndS(key, concatSignature)) {</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // Convert from concat to DER encoding since
&nbsp;                        // 1) SHAXXXWithECDSAInP1363Format algorithms are only available on &gt;= JDK 9 and
&nbsp;                        // 2) the SignatureAlgorithm enum JCA alg names are all SHAXXXwithECDSA (which expects DER formatting)
<b class="fc">&nbsp;                        derSignature = transcodeConcatToDER(concatSignature);</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    sig.initVerify(key);</b>
<b class="fc">&nbsp;                    return verify(sig, request.getPayload(), derSignature);</b>
&nbsp;
<b class="fc">&nbsp;                } catch (Exception e) {</b>
<b class="fc">&nbsp;                    String msg = &quot;Unable to verify Elliptic Curve signature using provided ECPublicKey: &quot; + e.getMessage();</b>
<b class="fc">&nbsp;                    throw new SignatureException(msg, e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Transcodes the JCA ASN.1/DER-encoded signature into the concatenated
&nbsp;     * R + S format expected by ECDSA JWS.
&nbsp;     *
&nbsp;     * @param derSignature The ASN1./DER-encoded. Must not be {@code null}.
&nbsp;     * @param outputLength The expected length of the ECDSA JWS signature.
&nbsp;     * @return The ECDSA JWS encoded signature.
&nbsp;     * @throws JwtException If the ASN.1/DER signature format is invalid.
&nbsp;     * @author Martin Treurnicht via &lt;a href=&quot;https://github.com/jwtk/jjwt/commit/61510dfca58dd40b4b32c708935126785dcff48c&quot;&gt;61510dfca58dd40b4b32c708935126785dcff48c&lt;/a&gt;
&nbsp;     */
&nbsp;    public static byte[] transcodeDERToConcat(final byte[] derSignature, int outputLength) throws JwtException {
&nbsp;
<b class="fc">&nbsp;        if (derSignature.length &lt; 8 || derSignature[0] != 48) {</b>
<b class="fc">&nbsp;            throw new JwtException(&quot;Invalid ECDSA signature format&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        int offset;
<b class="fc">&nbsp;        if (derSignature[1] &gt; 0) {</b>
<b class="fc">&nbsp;            offset = 2;</b>
<b class="fc">&nbsp;        } else if (derSignature[1] == (byte) 0x81) {</b>
<b class="fc">&nbsp;            offset = 3;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            throw new JwtException(&quot;Invalid ECDSA signature format&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte rLength = derSignature[offset + 1];</b>
&nbsp;
<b class="fc">&nbsp;        int i = rLength;</b>
<b class="fc">&nbsp;        while ((i &gt; 0) &amp;&amp; (derSignature[(offset + 2 + rLength) - i] == 0)) {</b>
<b class="fc">&nbsp;            i--;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byte sLength = derSignature[offset + 2 + rLength + 1];</b>
&nbsp;
<b class="fc">&nbsp;        int j = sLength;</b>
<b class="fc">&nbsp;        while ((j &gt; 0) &amp;&amp; (derSignature[(offset + 2 + rLength + 2 + sLength) - j] == 0)) {</b>
<b class="fc">&nbsp;            j--;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int rawLen = Math.max(i, j);</b>
<b class="fc">&nbsp;        rawLen = Math.max(rawLen, outputLength / 2);</b>
&nbsp;
<b class="fc">&nbsp;        if ((derSignature[offset - 1] &amp; 0xff) != derSignature.length - offset ||</b>
&nbsp;                (derSignature[offset - 1] &amp; 0xff) != 2 + rLength + 2 + sLength ||
&nbsp;                derSignature[offset] != 2 || derSignature[offset + 2 + rLength] != 2) {
<b class="fc">&nbsp;            throw new JwtException(&quot;Invalid ECDSA signature format&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final byte[] concatSignature = new byte[2 * rawLen];</b>
&nbsp;
<b class="fc">&nbsp;        System.arraycopy(derSignature, (offset + 2 + rLength) - i, concatSignature, rawLen - i, i);</b>
<b class="fc">&nbsp;        System.arraycopy(derSignature, (offset + 2 + rLength + 2 + sLength) - j, concatSignature, 2 * rawLen - j, j);</b>
&nbsp;
<b class="fc">&nbsp;        return concatSignature;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Transcodes the ECDSA JWS signature into ASN.1/DER format for use by the JCA verifier.
&nbsp;     *
&nbsp;     * @param jwsSignature The JWS signature, consisting of the concatenated R and S values. Must not be {@code null}.
&nbsp;     * @return The ASN.1/DER encoded signature.
&nbsp;     * @throws JwtException If the ECDSA JWS signature format is invalid.
&nbsp;     */
&nbsp;    public static byte[] transcodeConcatToDER(byte[] jwsSignature) throws JwtException {
&nbsp;        try {
<b class="fc">&nbsp;            return concatToDER(jwsSignature);</b>
<b class="fc">&nbsp;        } catch (Exception e) { // CVE-2022-21449 guard</b>
<b class="fc">&nbsp;            String msg = &quot;Invalid ECDSA signature format.&quot;;</b>
<b class="fc">&nbsp;            throw new SignatureException(msg, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts the specified concat-encoded signature to a DER-encoded signature.
&nbsp;     *
&nbsp;     * @param jwsSignature concat-encoded signature
&nbsp;     * @return correpsonding DER-encoded signature
&nbsp;     * @throws ArrayIndexOutOfBoundsException if the signature cannot be converted
&nbsp;     * @author Martin Treurnicht via &lt;a href=&quot;https://github.com/jwtk/jjwt/commit/61510dfca58dd40b4b32c708935126785dcff48c&quot;&gt;61510dfca58dd40b4b32c708935126785dcff48c&lt;/a&gt;
&nbsp;     */
&nbsp;    private static byte[] concatToDER(byte[] jwsSignature) throws ArrayIndexOutOfBoundsException {
&nbsp;
<b class="fc">&nbsp;        int rawLen = jwsSignature.length / 2;</b>
&nbsp;
<b class="fc">&nbsp;        int i = rawLen;</b>
&nbsp;
<b class="fc">&nbsp;        while ((i &gt; 0) &amp;&amp; (jwsSignature[rawLen - i] == 0)) {</b>
<b class="fc">&nbsp;            i--;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int j = i;</b>
&nbsp;
<b class="fc">&nbsp;        if (jwsSignature[rawLen - i] &lt; 0) {</b>
<b class="fc">&nbsp;            j += 1;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int k = rawLen;</b>
&nbsp;
<b class="fc">&nbsp;        while ((k &gt; 0) &amp;&amp; (jwsSignature[2 * rawLen - k] == 0)) {</b>
<b class="fc">&nbsp;            k--;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int l = k;</b>
&nbsp;
<b class="fc">&nbsp;        if (jwsSignature[2 * rawLen - k] &lt; 0) {</b>
<b class="fc">&nbsp;            l += 1;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int len = 2 + j + 2 + l;</b>
&nbsp;
<b class="fc">&nbsp;        if (len &gt; 255) {</b>
<b class="fc">&nbsp;            throw new JwtException(&quot;Invalid ECDSA signature format&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        int offset;
&nbsp;
&nbsp;        final byte[] derSignature;
&nbsp;
<b class="fc">&nbsp;        if (len &lt; 128) {</b>
<b class="fc">&nbsp;            derSignature = new byte[2 + 2 + j + 2 + l];</b>
<b class="fc">&nbsp;            offset = 1;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            derSignature = new byte[3 + 2 + j + 2 + l];</b>
<b class="fc">&nbsp;            derSignature[1] = (byte) 0x81;</b>
<b class="fc">&nbsp;            offset = 2;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        derSignature[0] = 48;</b>
<b class="fc">&nbsp;        derSignature[offset++] = (byte) len;</b>
<b class="fc">&nbsp;        derSignature[offset++] = 2;</b>
<b class="fc">&nbsp;        derSignature[offset++] = (byte) j;</b>
&nbsp;
<b class="fc">&nbsp;        System.arraycopy(jwsSignature, rawLen - i, derSignature, (offset + j) - i, i);</b>
&nbsp;
<b class="fc">&nbsp;        offset += j;</b>
&nbsp;
<b class="fc">&nbsp;        derSignature[offset++] = 2;</b>
<b class="fc">&nbsp;        derSignature[offset++] = (byte) l;</b>
&nbsp;
<b class="fc">&nbsp;        System.arraycopy(jwsSignature, 2 * rawLen - k, derSignature, (offset + l) - k, k);</b>
&nbsp;
<b class="fc">&nbsp;        return derSignature;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
