


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > EdwardsCurve</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.security</a>
</div>

<h1>Coverage Summary for Class: EdwardsCurve (io.jsonwebtoken.impl.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EdwardsCurve</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (54/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (128/128)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EdwardsCurve$derivePublic$5</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$findByKey$2</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$forKey</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$getJcaName$6</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$getKeyMaterial$1</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$isEdwards$4</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$toPrivateKey$3</td>
  </tr>
  <tr>
    <td class="name">EdwardsCurve$toPublicKey$0</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (54/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (128/128)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright © 2023 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.security;
&nbsp;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.impl.lang.Function;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.KeyException;
&nbsp;import io.jsonwebtoken.security.KeyLengthSupplier;
&nbsp;import io.jsonwebtoken.security.KeyPairBuilder;
&nbsp;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.Provider;
&nbsp;import java.security.PublicKey;
&nbsp;import java.security.spec.KeySpec;
&nbsp;import java.security.spec.PKCS8EncodedKeySpec;
&nbsp;import java.security.spec.X509EncodedKeySpec;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;public class EdwardsCurve extends AbstractCurve implements KeyLengthSupplier {
&nbsp;
&nbsp;    private static final String OID_PREFIX = &quot;1.3.101.&quot;;
&nbsp;
&nbsp;    // ASN.1-encoded edwards keys have this exact sequence identifying the type of key that follows.  The trailing
&nbsp;    // byte is the exact edwards curve subsection OID terminal node id.
<b class="fc">&nbsp;    private static final byte[] ASN1_OID_PREFIX = new byte[]{0x06, 0x03, 0x2B, 0x65};</b>
&nbsp;
<b class="fc">&nbsp;    private static final Function&lt;Key, String&gt; CURVE_NAME_FINDER = new NamedParameterSpecValueFinder();</b>
&nbsp;
<b class="fc">&nbsp;    public static final EdwardsCurve X25519 = new EdwardsCurve(&quot;X25519&quot;, 110); // Requires JDK &gt;= 11 or BC</b>
<b class="fc">&nbsp;    public static final EdwardsCurve X448 = new EdwardsCurve(&quot;X448&quot;, 111); // Requires JDK &gt;= 11 or BC</b>
<b class="fc">&nbsp;    public static final EdwardsCurve Ed25519 = new EdwardsCurve(&quot;Ed25519&quot;, 112); // Requires JDK &gt;= 15 or BC</b>
<b class="fc">&nbsp;    public static final EdwardsCurve Ed448 = new EdwardsCurve(&quot;Ed448&quot;, 113); // Requires JDK &gt;= 15 or BC</b>
&nbsp;
<b class="fc">&nbsp;    public static final Collection&lt;EdwardsCurve&gt; VALUES = Collections.of(X25519, X448, Ed25519, Ed448);</b>
&nbsp;
&nbsp;    private static final Map&lt;String, EdwardsCurve&gt; REGISTRY;
&nbsp;
&nbsp;    private static final Map&lt;Integer, EdwardsCurve&gt; BY_OID_TERMINAL_NODE;
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        REGISTRY = new LinkedHashMap&lt;&gt;(8);</b>
<b class="fc">&nbsp;        BY_OID_TERMINAL_NODE = new LinkedHashMap&lt;&gt;(4);</b>
<b class="fc">&nbsp;        for (EdwardsCurve curve : VALUES) {</b>
<b class="fc">&nbsp;            int subcategoryId = curve.ASN1_OID[curve.ASN1_OID.length - 1];</b>
<b class="fc">&nbsp;            BY_OID_TERMINAL_NODE.put(subcategoryId, curve);</b>
<b class="fc">&nbsp;            REGISTRY.put(curve.getId(), curve);</b>
<b class="fc">&nbsp;            REGISTRY.put(curve.OID, curve); // add OID as an alias for alg/id lookups</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static byte[] publicKeyAsn1Prefix(int byteLength, byte[] ASN1_OID) {
<b class="fc">&nbsp;        return Bytes.concat(</b>
&nbsp;                new byte[]{
&nbsp;                        0x30, (byte) (byteLength + 10),
&nbsp;                        0x30, 0x05}, // ASN.1 SEQUENCE of 5 bytes to follow (i.e. the OID)
&nbsp;                ASN1_OID,
&nbsp;                new byte[]{
&nbsp;                        0x03,
&nbsp;                        (byte) (byteLength + 1),
&nbsp;                        0x00}
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    private static byte[] privateKeyPkcs8Prefix(int byteLength, byte[] ASN1_OID, boolean ber) {
&nbsp;
<b class="fc">&nbsp;        byte[] keyPrefix = ber ?</b>
<b class="fc">&nbsp;                new byte[]{0x04, (byte) (byteLength + 2), 0x04, (byte) byteLength} : // correct</b>
<b class="fc">&nbsp;                new byte[]{0x04, (byte) byteLength}; // https://bugs.openjdk.org/browse/JDK-8213363</b>
&nbsp;
<b class="fc">&nbsp;        return Bytes.concat(</b>
&nbsp;                new byte[]{
&nbsp;                        0x30,
&nbsp;                        (byte) (5 + ASN1_OID.length + keyPrefix.length + byteLength),
&nbsp;                        0x02, 0x01, 0x00, // encoding version 1 (integer, 1 byte, value 0)
&nbsp;                        0x30, 0x05}, // ASN.1 SEQUENCE of 5 bytes to follow (i.e. the OID)
&nbsp;                ASN1_OID,
&nbsp;                keyPrefix
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    private final String OID;
&nbsp;
&nbsp;    /**
&nbsp;     * The byte sequence within an ASN.1-encoded key that indicates an Edwards curve encoded key follows. ASN.1 (hex)
&nbsp;     * notation:
&nbsp;     * &lt;pre&gt;
&nbsp;     * 06 03       ;   OBJECT IDENTIFIER (3 bytes long)
&nbsp;     * |  2B 65 $I ;     &quot;1.3.101.$I&quot; for Edwards alg OID, where $I = 6E, 6F, 70, or 71 (decimal 110, 111, 112, or 113)
&nbsp;     * &lt;/pre&gt;
&nbsp;     */
&nbsp;    final byte[] ASN1_OID;
&nbsp;
&nbsp;    private final int keyBitLength;
&nbsp;
&nbsp;    private final int encodedKeyByteLength;
&nbsp;
&nbsp;    /**
&nbsp;     * X.509 (ASN.1) encoding of a public key associated with this curve as a prefix (that is, &lt;em&gt;without&lt;/em&gt; the
&nbsp;     * actual encoded key material at the end). Appending the public key material directly to the end of this value
&nbsp;     * results in a complete X.509 (ASN.1) encoded public key.  ASN.1 (hex) notation:
&nbsp;     * &lt;pre&gt;
&nbsp;     * 30 $M               ; ASN.1 SEQUENCE ($M bytes long), where $M = encodedKeyByteLength + 10
&nbsp;     *    30 05            ;   ASN.1 SEQUENCE (5 bytes long)
&nbsp;     *       06 03         ;     OBJECT IDENTIFIER (3 bytes long)
&nbsp;     *          2B 65 $I   ;       &quot;1.3.101.$I&quot; for Edwards alg OID, where $I = 6E, 6F, 70, or 71 (110, 111, 112, or 113 decimal)
&nbsp;     *    03 $S            ;   ASN.1 BIT STRING ($S bytes long), where $S = encodedKeyByteLength + 1
&nbsp;     *       00            ;     ASN.1 bit string marker indicating zero unused bits at the end of the bit string
&nbsp;     *       XX XX XX ...  ;     encoded key material (not included in this PREFIX byte array variable)
&nbsp;     * &lt;/pre&gt;
&nbsp;     */
&nbsp;    private final byte[] PUBLIC_KEY_ASN1_PREFIX; // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.7
&nbsp;
&nbsp;    /**
&nbsp;     * PKCS8 (ASN.1) Version 1 encoding of a private key associated with this curve, as a prefix (that is,
&nbsp;     * &lt;em&gt;without&lt;/em&gt; actual encoded key material at the end). Appending the private key material directly to the
&nbsp;     * end of this value results in a complete PKCS8 (ASN.1) V1 encoded private key.  ASN.1 (hex) notation:
&nbsp;     * &lt;pre&gt;
&nbsp;     * 30 $M                  ; ASN.1 SEQUENCE ($M bytes long), where $M = encodedKeyByteLength + 14
&nbsp;     *    02 01               ;   ASN.1 INTEGER (1 byte long)
&nbsp;     *       00               ;     zero (private key encoding version V1)
&nbsp;     *    30 05               ;   ASN.1 SEQUENCE (5 bytes long)
&nbsp;     *       06 03            ;     OBJECT IDENTIFIER (3 bytes long). This is the edwards algorithm ID.
&nbsp;     *          2B 65 $I      ;       &quot;1.3.101.$I&quot; for Edwards alg OID, where $I = 6E, 6F, 70, or 71 (110, 111, 112, or 113 decimal)
&nbsp;     *    04 $B               ;   ASN.1 SEQUENCE ($B bytes long, where $B = encodedKeyByteLength + 2
&nbsp;     *       04 $K            ;     ASN.1 SEQUENCE ($K bytes long), where $K = encodedKeyByteLength
&nbsp;     *          XX XX XX ...  ;       encoded key material (not included in this PREFIX byte array variable)
&nbsp;     * &lt;/pre&gt;
&nbsp;     */
&nbsp;    private final byte[] PRIVATE_KEY_ASN1_PREFIX;
&nbsp;    private final byte[] PRIVATE_KEY_JDK11_PREFIX; // https://bugs.openjdk.org/browse/JDK-8213363
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} IFF the curve is used for digital signatures, {@code false} if used for key agreement
&nbsp;     */
&nbsp;    private final boolean signatureCurve;
&nbsp;
&nbsp;    EdwardsCurve(final String id, int oidTerminalNode) {
<b class="fc">&nbsp;        super(id, id);</b>
&nbsp;
<b class="pc">&nbsp;        if (oidTerminalNode &lt; 110 || oidTerminalNode &gt; 113) {</b>
<b class="fc">&nbsp;            String msg = &quot;Invalid Edwards Curve ASN.1 OID terminal node value&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // OIDs (with terminal node IDs) defined here: https://www.rfc-editor.org/rfc/rfc8410#section-3
&nbsp;        // X25519 (oid 1.3.101.110) has 255 bytes per https://www.rfc-editor.org/rfc/rfc7748.html#section-5 &quot;Here, the &quot;bits&quot; parameter should be set to 255 for X25519 and 448 for X448&quot;
&nbsp;        // X448 (oid 1.3.101.111) have 448 bits per https://www.rfc-editor.org/rfc/rfc7748.html#section-5
&nbsp;        // Ed25519 (oid 1.3.101.112) has 255 bits per https://www.rfc-editor.org/rfc/rfc8032#section-5.1
&nbsp;        // Ed448 (oid 1.3.101.113) has 456 (448 + 8) bits per https://www.rfc-editor.org/rfc/rfc8032#section-5.2
<b class="fc">&nbsp;        this.keyBitLength = oidTerminalNode % 2 == 0 ? 255 : 448;</b>
<b class="fc">&nbsp;        int encodingBitLen = oidTerminalNode == 113 ?</b>
<b class="fc">&nbsp;                this.keyBitLength + Byte.SIZE : // https://www.rfc-editor.org/rfc/rfc8032#section-5.2.2</b>
<b class="fc">&nbsp;                this.keyBitLength;</b>
<b class="fc">&nbsp;        this.encodedKeyByteLength = Bytes.length(encodingBitLen);</b>
&nbsp;
<b class="fc">&nbsp;        this.OID = OID_PREFIX + oidTerminalNode;</b>
<b class="fc">&nbsp;        this.signatureCurve = (oidTerminalNode == 112 || oidTerminalNode == 113);</b>
<b class="fc">&nbsp;        byte[] suffix = new byte[]{(byte) oidTerminalNode};</b>
<b class="fc">&nbsp;        this.ASN1_OID = Bytes.concat(ASN1_OID_PREFIX, suffix);</b>
&nbsp;
<b class="fc">&nbsp;        this.PUBLIC_KEY_ASN1_PREFIX = publicKeyAsn1Prefix(this.encodedKeyByteLength, this.ASN1_OID);</b>
<b class="fc">&nbsp;        this.PRIVATE_KEY_ASN1_PREFIX = privateKeyPkcs8Prefix(this.encodedKeyByteLength, this.ASN1_OID, true);</b>
<b class="fc">&nbsp;        this.PRIVATE_KEY_JDK11_PREFIX = privateKeyPkcs8Prefix(this.encodedKeyByteLength, this.ASN1_OID, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getKeyBitLength() {
<b class="fc">&nbsp;        return this.keyBitLength;</b>
&nbsp;    }
&nbsp;
&nbsp;    public byte[] getKeyMaterial(Key key) {
&nbsp;        try {
<b class="fc">&nbsp;            return doGetKeyMaterial(key); // can throw assertion and ArrayIndexOutOfBound exception on invalid input</b>
<b class="fc">&nbsp;        } catch (Throwable t) {</b>
<b class="fc">&nbsp;            if (t instanceof KeyException) { //propagate</b>
<b class="fc">&nbsp;                throw (KeyException) t;</b>
&nbsp;            }
<b class="fc">&nbsp;            String msg = &quot;Invalid &quot; + getId() + &quot; ASN.1 encoding: &quot; + t.getMessage();</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(msg, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the ASN.1-encoding of the specified key
&nbsp;     *
&nbsp;     * @param key the Edwards curve key
&nbsp;     * @return the key value, encoded according to &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc8032&quot;&gt;RFC 8032&lt;/a&gt;
&nbsp;     * @throws RuntimeException if the key&#39;s encoded bytes do not reflect a validly ASN.1-encoded edwards key
&nbsp;     */
&nbsp;    protected byte[] doGetKeyMaterial(Key key) {
<b class="fc">&nbsp;        byte[] encoded = KeysBridge.getEncoded(key);</b>
<b class="fc">&nbsp;        int i = Bytes.indexOf(encoded, ASN1_OID);</b>
<b class="fc">&nbsp;        Assert.gt(i, -1, &quot;Missing or incorrect algorithm OID.&quot;);</b>
<b class="fc">&nbsp;        i = i + ASN1_OID.length;</b>
<b class="fc">&nbsp;        int keyLen = 0;</b>
<b class="fc">&nbsp;        if (encoded[i] == 0x05) { // NULL terminator, next should be zero byte indicator</b>
<b class="fc">&nbsp;            int unusedBytes = encoded[++i];</b>
<b class="fc">&nbsp;            Assert.eq(unusedBytes, 0, &quot;OID NULL terminator should indicate zero unused bytes.&quot;);</b>
<b class="fc">&nbsp;            i++;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (encoded[i] == 0x03) { // ASN.1 bit stream, Public Key</b>
<b class="fc">&nbsp;            i++;</b>
<b class="fc">&nbsp;            keyLen = encoded[i++];</b>
<b class="fc">&nbsp;            int unusedBytes = encoded[i++];</b>
<b class="fc">&nbsp;            Assert.eq(unusedBytes, 0, &quot;BIT STREAM should not indicate unused bytes.&quot;);</b>
<b class="fc">&nbsp;            keyLen--;</b>
<b class="fc">&nbsp;        } else if (encoded[i] == 0x04) { // ASN.1 octet sequence, Private Key.  Key length follows as next byte.</b>
<b class="fc">&nbsp;            i++;</b>
<b class="fc">&nbsp;            keyLen = encoded[i++];</b>
<b class="fc">&nbsp;            if (encoded[i] == 0x04) { // ASN.1 octet sequence, key length follows as next byte.</b>
<b class="fc">&nbsp;                i++; // skip sequence marker</b>
<b class="fc">&nbsp;                keyLen = encoded[i++]; // next byte is length</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        Assert.eq(keyLen, this.encodedKeyByteLength, &quot;Invalid key length.&quot;);</b>
<b class="fc">&nbsp;        byte[] result = Arrays.copyOfRange(encoded, i, i + keyLen);</b>
<b class="fc">&nbsp;        keyLen = Bytes.length(result);</b>
<b class="fc">&nbsp;        Assert.eq(keyLen, this.encodedKeyByteLength, &quot;Invalid key length.&quot;);</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void assertLength(byte[] raw, boolean isPublic) {
<b class="fc">&nbsp;        int len = Bytes.length(raw);</b>
<b class="fc">&nbsp;        if (len != this.encodedKeyByteLength) {</b>
<b class="fc">&nbsp;            String msg = &quot;Invalid &quot; + getId() + &quot; encoded &quot; + (isPublic ? &quot;PublicKey&quot; : &quot;PrivateKey&quot;) +</b>
<b class="fc">&nbsp;                    &quot; length. Should be &quot; + Bytes.bytesMsg(this.encodedKeyByteLength) + &quot;, found &quot; +</b>
<b class="fc">&nbsp;                    Bytes.bytesMsg(len) + &quot;.&quot;;</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(msg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public PublicKey toPublicKey(byte[] x, Provider provider) {
<b class="fc">&nbsp;        assertLength(x, true);</b>
<b class="fc">&nbsp;        final byte[] encoded = Bytes.concat(this.PUBLIC_KEY_ASN1_PREFIX, x);</b>
<b class="fc">&nbsp;        final X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);</b>
<b class="fc">&nbsp;        JcaTemplate template = new JcaTemplate(getJcaName(), provider);</b>
<b class="fc">&nbsp;        return template.generatePublic(spec);</b>
&nbsp;    }
&nbsp;
&nbsp;    KeySpec privateKeySpec(byte[] d, boolean standard) {
<b class="fc">&nbsp;        byte[] prefix = standard ? this.PRIVATE_KEY_ASN1_PREFIX : this.PRIVATE_KEY_JDK11_PREFIX;</b>
<b class="fc">&nbsp;        byte[] encoded = Bytes.concat(prefix, d);</b>
<b class="fc">&nbsp;        return new PKCS8EncodedKeySpec(encoded);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PrivateKey toPrivateKey(final byte[] d, Provider provider) {
<b class="fc">&nbsp;        assertLength(d, false);</b>
<b class="fc">&nbsp;        KeySpec spec = privateKeySpec(d, true);</b>
<b class="fc">&nbsp;        JcaTemplate template = new JcaTemplate(getJcaName(), provider);</b>
<b class="fc">&nbsp;        return template.generatePrivate(spec);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this curve is used to compute signatures, {@code false} if used for key agreement.
&nbsp;     *
&nbsp;     * @return {@code true} if this curve is used to compute signatures, {@code false} if used for key agreement.
&nbsp;     */
&nbsp;    public boolean isSignatureCurve() {
<b class="fc">&nbsp;        return this.signatureCurve;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public KeyPairBuilder keyPair() {
<b class="fc">&nbsp;        return new DefaultKeyPairBuilder(getJcaName(), this.keyBitLength);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isEdwards(Key key) {
<b class="fc">&nbsp;        if (key == null) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        String alg = Strings.clean(key.getAlgorithm());</b>
<b class="pc">&nbsp;        return &quot;EdDSA&quot;.equals(alg) || &quot;XDH&quot;.equals(alg) || findByKey(key) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes the PublicKey associated with the specified Edwards-curve PrivateKey.
&nbsp;     *
&nbsp;     * @param pk the Edwards-curve {@code PrivateKey} to inspect.
&nbsp;     * @return the PublicKey associated with the specified Edwards-curve PrivateKey.
&nbsp;     * @throws KeyException if the PrivateKey is not an Edwards-curve key or unable to access the PrivateKey&#39;s
&nbsp;     *                      material.
&nbsp;     */
&nbsp;    public static PublicKey derivePublic(PrivateKey pk) throws KeyException {
<b class="fc">&nbsp;        return EdwardsPublicKeyDeriver.INSTANCE.apply(pk);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static EdwardsCurve findById(String id) {
<b class="fc">&nbsp;        return REGISTRY.get(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static EdwardsCurve findByKey(Key key) {
<b class="fc">&nbsp;        if (key == null) {</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        String alg = key.getAlgorithm();</b>
<b class="fc">&nbsp;        EdwardsCurve curve = findById(alg); // try constant time lookup first</b>
<b class="fc">&nbsp;        if (curve == null) { // Fall back to JDK 11+ NamedParameterSpec access if possible</b>
<b class="fc">&nbsp;            alg = CURVE_NAME_FINDER.apply(key);</b>
<b class="fc">&nbsp;            curve = findById(alg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // try to perform oid and/or length checks:
<b class="fc">&nbsp;        byte[] encoded = KeysBridge.findEncoded(key);</b>
&nbsp;
<b class="fc">&nbsp;        if (curve == null &amp;&amp; !Bytes.isEmpty(encoded)) { // Try to find the Key ASN.1 algorithm OID:</b>
<b class="fc">&nbsp;            int oidTerminalNode = findOidTerminalNode(encoded);</b>
<b class="fc">&nbsp;            curve = BY_OID_TERMINAL_NODE.get(oidTerminalNode);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (curve != null &amp;&amp; !Bytes.isEmpty(encoded)) {</b>
&nbsp;            // found a curve, and we have encoded bytes, let&#39;s make sure that the encoding represents
&nbsp;            // the correct key length:
&nbsp;            try {
<b class="fc">&nbsp;                curve.getKeyMaterial(key);</b>
<b class="fc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="fc">&nbsp;                curve = null; // key length is invalid for its indicated curve, not a match</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        //TODO: check if key exists on discovered curve via equation
&nbsp;
<b class="fc">&nbsp;        return curve;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean contains(Key key) {
<b class="fc">&nbsp;        EdwardsCurve curve = findByKey(key);</b>
<b class="fc">&nbsp;        return curve.equals(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int findOidTerminalNode(byte[] encoded) {
<b class="fc">&nbsp;        int index = Bytes.indexOf(encoded, ASN1_OID_PREFIX);</b>
<b class="fc">&nbsp;        if (index &gt; -1) {</b>
<b class="fc">&nbsp;            index = index + ASN1_OID_PREFIX.length;</b>
<b class="fc">&nbsp;            if (index &lt; encoded.length) {</b>
<b class="fc">&nbsp;                return encoded[index];</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static EdwardsCurve forKey(Key key) {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        EdwardsCurve curve = findByKey(key);</b>
<b class="fc">&nbsp;        if (curve == null) {</b>
<b class="fc">&nbsp;            String msg = &quot;Unrecognized Edwards Curve key: [&quot; + KeysBridge.toString(key) + &quot;]&quot;;</b>
<b class="fc">&nbsp;            throw new InvalidKeyException(msg);</b>
&nbsp;        }
&nbsp;        //TODO: assert key exists on discovered curve via equation
<b class="fc">&nbsp;        return curve;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;UnusedReturnValue&quot;)
&nbsp;    static &lt;K extends Key&gt; K assertEdwards(K key) {
<b class="fc">&nbsp;        forKey(key); // will throw UnsupportedKeyException if the key is not an Edwards key</b>
<b class="fc">&nbsp;        return key;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
