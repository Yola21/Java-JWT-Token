


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Base64Codec</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl.io</a>
</div>

<h1>Coverage Summary for Class: Base64Codec (io.jsonwebtoken.impl.io)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Base64Codec</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.5%
  </span>
  <span class="absValue">
    (5/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.8%
  </span>
  <span class="absValue">
    (25/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.7%
  </span>
  <span class="absValue">
    (45/103)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright © 2023 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl.io;
&nbsp;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;
&nbsp;/**
&nbsp; * Provides Base64 encoding and decoding as defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This class implements section &lt;cite&gt;6.8. Base64 Content-Transfer-Encoding&lt;/cite&gt; from RFC 2045 &lt;cite&gt;Multipurpose
&nbsp; * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&lt;/cite&gt; by Freed and Borenstein.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The class can be parameterized in the following manner with various constructors:
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;URL-safe mode: Default off.&lt;/li&gt;
&nbsp; * &lt;li&gt;Line length: Default 76. Line length that aren&#39;t multiples of 4 will still essentially end up being multiples of
&nbsp; * 4 in the encoded data.
&nbsp; * &lt;li&gt;Line separator: Default is CRLF (&quot;\r\n&quot;)&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The URL-safe parameter is only applied to encode operations. Decoding seamlessly handles both modes.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only
&nbsp; * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,
&nbsp; * UTF-8, etc).
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * This class is thread-safe.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
&nbsp; * @since 0.12.0, copied from
&nbsp; * &lt;a href=&quot;https://github.com/apache/commons-codec/tree/585497f09b026f6602daf986723a554e051bdfe6&quot;&gt;commons-codec
&nbsp; * 585497f09b026f6602daf986723a554e051bdfe6&lt;/a&gt;
&nbsp; */
&nbsp;class Base64Codec extends BaseNCodec {
&nbsp;
&nbsp;    /**
&nbsp;     * BASE64 characters are 6 bits in length.
&nbsp;     * They are formed by taking a block of 3 octets to form a 24-bit string,
&nbsp;     * which is converted into 4 BASE64 characters.
&nbsp;     */
&nbsp;    private static final int BITS_PER_ENCODED_BYTE = 6;
&nbsp;    private static final int BYTES_PER_UNENCODED_BLOCK = 3;
&nbsp;    private static final int BYTES_PER_ENCODED_BLOCK = 4;
&nbsp;
&nbsp;    /**
&nbsp;     * This array is a lookup table that translates 6-bit positive integer index values into their &quot;Base64 Alphabet&quot;
&nbsp;     * equivalents as specified in Table 1 of RFC 2045.
&nbsp;     * &lt;p&gt;
&nbsp;     * Thanks to &quot;commons&quot; project in ws.apache.org for this code.
&nbsp;     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
&nbsp;     * &lt;/p&gt;
&nbsp;     */
<b class="fc">&nbsp;    private static final byte[] STANDARD_ENCODE_TABLE = {</b>
&nbsp;            &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
&nbsp;            &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
&nbsp;            &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
&nbsp;            &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
&nbsp;            &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /
&nbsp;     * changed to - and _ to make the encoded Base64 results more URL-SAFE.
&nbsp;     * This table is only used when the Base64&#39;s mode is set to URL-SAFE.
&nbsp;     */
<b class="fc">&nbsp;    private static final byte[] URL_SAFE_ENCODE_TABLE = {</b>
&nbsp;            &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
&nbsp;            &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
&nbsp;            &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
&nbsp;            &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
&nbsp;            &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;_&#39;
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * This array is a lookup table that translates Unicode characters drawn from the &quot;Base64 Alphabet&quot; (as specified
&nbsp;     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
&nbsp;     * alphabet but fall within the bounds of the array are translated to -1.
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: &#39;+&#39; and &#39;-&#39; both decode to 62. &#39;/&#39; and &#39;_&#39; both decode to 63. This means decoder seamlessly handles both
&nbsp;     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Thanks to &quot;commons&quot; project in ws.apache.org for this code.
&nbsp;     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    // @formatter:off
<b class="fc">&nbsp;    private static final byte[] DECODE_TABLE = {</b>
&nbsp;          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
&nbsp;            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f
&nbsp;            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f
&nbsp;            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, // 20-2f + - /
&nbsp;            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, // 30-3f 0-9
&nbsp;            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O
&nbsp;            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, // 50-5f P-Z _
&nbsp;            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // 60-6f a-o
&nbsp;            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51                      // 70-7a p-z
&nbsp;    };
&nbsp;    // @formatter:on
&nbsp;
&nbsp;    // The static final fields above are used for the original static byte[] methods on Base64.
&nbsp;    // The private member fields below are used with the new streaming approach, which requires
&nbsp;    // some state be preserved between calls of encode() and decode().
&nbsp;
&nbsp;    /* Base64 uses 6-bit fields. */
&nbsp;    /**
&nbsp;     * Mask used to extract 6 bits, used when encoding
&nbsp;     */
&nbsp;    private static final int MASK_6BITS = 0x3f;
&nbsp;    /**
&nbsp;     * Mask used to extract 4 bits, used when decoding final trailing character.
&nbsp;     */
&nbsp;    private static final int MASK_4BITS = 0xf;
&nbsp;    /**
&nbsp;     * Mask used to extract 2 bits, used when decoding final trailing character.
&nbsp;     */
&nbsp;    private static final int MASK_2BITS = 0x3;
&nbsp;
&nbsp;    /**
&nbsp;     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able
&nbsp;     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch
&nbsp;     * between the two modes.
&nbsp;     */
&nbsp;    private final byte[] encodeTable;
&nbsp;
&nbsp;    /**
&nbsp;     * Only one decode table currently; keep for consistency with Base32 code.
&nbsp;     */
<b class="fc">&nbsp;    private final byte[] decodeTable = DECODE_TABLE;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Line separator for encoding. Not used when decoding. Only used if lineLength &amp;gt; 0.
&nbsp;     */
&nbsp;    private final byte[] lineSeparator;
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
&nbsp;     * {@code decodeSize = 3 + lineSeparator.length;}
&nbsp;     */
&nbsp;    private final int decodeSize;
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
&nbsp;     * {@code encodeSize = 4 + lineSeparator.length;}
&nbsp;     */
&nbsp;    private final int encodeSize;
&nbsp;
&nbsp;//    /**
&nbsp;//     * Decodes Base64 data into octets.
&nbsp;//     * &lt;p&gt;
&nbsp;//     * &lt;b&gt;Note:&lt;/b&gt; this method seamlessly handles data encoded in URL-safe or normal mode.
&nbsp;//     * &lt;/p&gt;
&nbsp;//     *
&nbsp;//     * @param base64Data Byte array containing Base64 data
&nbsp;//     * @return Array containing decoded data.
&nbsp;//     */
&nbsp;//    public static byte[] decodeBase64(final byte[] base64Data) {
&nbsp;//        return new Base64().decode(base64Data);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Decodes a Base64 String into octets.
&nbsp;//     * &lt;p&gt;
&nbsp;//     * &lt;b&gt;Note:&lt;/b&gt; this method seamlessly handles data encoded in URL-safe or normal mode.
&nbsp;//     * &lt;/p&gt;
&nbsp;//     *
&nbsp;//     * @param base64String String containing Base64 data
&nbsp;//     * @return Array containing decoded data.
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static byte[] decodeBase64(final String base64String) {
&nbsp;//        return new Base64().decode(base64String);
&nbsp;//    }
&nbsp;//
&nbsp;//    // Implementation of integer encoding used for crypto
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Decodes a byte64-encoded integer according to crypto standards such as W3C&#39;s XML-Signature.
&nbsp;//     *
&nbsp;//     * @param pArray a byte array containing base64 character data
&nbsp;//     * @return A BigInteger
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static BigInteger decodeInteger(final byte[] pArray) {
&nbsp;//        return new BigInteger(1, decodeBase64(pArray));
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm but does not chunk the output.
&nbsp;//     *
&nbsp;//     * @param binaryData binary data to encode
&nbsp;//     * @return byte[] containing Base64 characters in their UTF-8 representation.
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64(final byte[] binaryData) {
&nbsp;//        return encodeBase64(binaryData, false);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
&nbsp;//     *
&nbsp;//     * @param binaryData Array containing binary data to encode.
&nbsp;//     * @param isChunked  if {@code true} this encoder will chunk the base64 output into 76 character blocks
&nbsp;//     * @return Base64-encoded data.
&nbsp;//     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {
&nbsp;//        return encodeBase64(binaryData, isChunked, false);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
&nbsp;//     *
&nbsp;//     * @param binaryData Array containing binary data to encode.
&nbsp;//     * @param isChunked  if {@code true} this encoder will chunk the base64 output into 76 character blocks
&nbsp;//     * @param urlSafe    if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
&nbsp;//     *                   &lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;
&nbsp;//     * @return Base64-encoded data.
&nbsp;//     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {
&nbsp;//        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
&nbsp;//     *
&nbsp;//     * @param binaryData    Array containing binary data to encode.
&nbsp;//     * @param isChunked     if {@code true} this encoder will chunk the base64 output into 76 character blocks
&nbsp;//     * @param urlSafe       if {@code true} this encoder will emit - and _ instead of the usual + and / characters.
&nbsp;//     *                      &lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;
&nbsp;//     * @param maxResultSize The maximum result size to accept.
&nbsp;//     * @return Base64-encoded data.
&nbsp;//     * @throws IllegalArgumentException Thrown when the input array needs an output array bigger than maxResultSize
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,
&nbsp;//                                      final boolean urlSafe, final int maxResultSize) {
&nbsp;//        if (Bytes.isEmpty(binaryData)) {
&nbsp;//            return binaryData;
&nbsp;//        }
&nbsp;//
&nbsp;//        // Create this so can use the super-class method
&nbsp;//        // Also ensures that the same roundings are performed by the ctor and the code
&nbsp;//        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
&nbsp;//        final long len = b64.getEncodedLength(binaryData);
&nbsp;//        if (len &gt; maxResultSize) {
&nbsp;//            throw new IllegalArgumentException(&quot;Input array too big, the output array would be bigger (&quot; +
&nbsp;//                    len +
&nbsp;//                    &quot;) than the specified maximum size of &quot; +
&nbsp;//                    maxResultSize);
&nbsp;//        }
&nbsp;//
&nbsp;//        return b64.encode(binaryData);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
&nbsp;//     *
&nbsp;//     * @param binaryData binary data to encode
&nbsp;//     * @return Base64 characters chunked in 76 character blocks
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64Chunked(final byte[] binaryData) {
&nbsp;//        return encodeBase64(binaryData, true);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using the base64 algorithm but does not chunk the output.
&nbsp;//     * &lt;p&gt;
&nbsp;//     * NOTE:  We changed the behavior of this method from multi-line chunking (commons-codec-1.4) to
&nbsp;//     * single-line non-chunking (commons-codec-1.5).
&nbsp;//     *
&nbsp;//     * @param binaryData binary data to encode
&nbsp;//     * @return String containing Base64 characters.
&nbsp;//     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).
&nbsp;//     */
&nbsp;//    public static String encodeBase64String(final byte[] binaryData) {
&nbsp;//        byte[] encoded = encodeBase64(binaryData, false);
&nbsp;//        return new String(encoded, StandardCharsets.US_ASCII);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
&nbsp;//     * url-safe variation emits - and _ instead of + and / characters.
&nbsp;//     * &lt;b&gt;Note: no padding is added.&lt;/b&gt;
&nbsp;//     *
&nbsp;//     * @param binaryData binary data to encode
&nbsp;//     * @return byte[] containing Base64 characters in their UTF-8 representation.
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {
&nbsp;//        return encodeBase64(binaryData, false, true);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The
&nbsp;//     * url-safe variation emits - and _ instead of + and / characters.
&nbsp;//     * &lt;b&gt;Note: no padding is added.&lt;/b&gt;
&nbsp;//     *
&nbsp;//     * @param binaryData binary data to encode
&nbsp;//     * @return String containing Base64 characters
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static String encodeBase64URLSafeString(final byte[] binaryData) {
&nbsp;//        byte[] encoded = encodeBase64(binaryData, false, true);
&nbsp;//        return new String(encoded, StandardCharsets.US_ASCII);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Encodes to a byte64-encoded integer according to crypto standards such as W3C&#39;s XML-Signature.
&nbsp;//     *
&nbsp;//     * @param bigInteger a BigInteger
&nbsp;//     * @return A byte array containing base64 character data
&nbsp;//     * @throws NullPointerException if null is passed in
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static byte[] encodeInteger(final BigInteger bigInteger) {
&nbsp;//        Objects.requireNonNull(bigInteger, &quot;bigInteger&quot;);
&nbsp;//        return encodeBase64(toIntegerBytes(bigInteger), false);
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Returns whether or not the {@code octet} is in the base 64 alphabet.
&nbsp;//     *
&nbsp;//     * @param octet The value to test
&nbsp;//     * @return {@code true} if the value is defined in the base 64 alphabet, {@code false} otherwise.
&nbsp;//     * @since 1.4
&nbsp;//     */
&nbsp;//    public static boolean isBase64(final byte octet) {
&nbsp;//        return octet == PAD_DEFAULT || octet &gt;= 0 &amp;&amp; octet &lt; DECODE_TABLE.length &amp;&amp; DECODE_TABLE[octet] != -1;
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the
&nbsp;//     * method treats whitespace as valid.
&nbsp;//     *
&nbsp;//     * @param arrayOctet byte array to test
&nbsp;//     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;
&nbsp;//     * {@code false}, otherwise
&nbsp;//     * @since 1.5
&nbsp;//     */
&nbsp;//    public static boolean isBase64(final byte[] arrayOctet) {
&nbsp;//        for (final byte element : arrayOctet) {
&nbsp;//            if (!isBase64(element) &amp;&amp; !Character.isWhitespace(element)) {
&nbsp;//                return false;
&nbsp;//            }
&nbsp;//        }
&nbsp;//        return true;
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the
&nbsp;//     * method treats whitespace as valid.
&nbsp;//     *
&nbsp;//     * @param base64 String to test
&nbsp;//     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if
&nbsp;//     * the String is empty; {@code false}, otherwise
&nbsp;//     * @since 1.5
&nbsp;//     */
&nbsp;//    public static boolean isBase64(final String base64) {
&nbsp;//        return isBase64(Strings.utf8(base64));
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * Returns a byte-array representation of a {@code BigInteger} without sign bit.
&nbsp;//     *
&nbsp;//     * @param bigInt {@code BigInteger} to be converted
&nbsp;//     * @return a byte array representation of the BigInteger parameter
&nbsp;//     */
&nbsp;//    static byte[] toIntegerBytes(final BigInteger bigInt) {
&nbsp;//        int bitlen = bigInt.bitLength();
&nbsp;//        // round bitlen
&nbsp;//        bitlen = bitlen + 7 &gt;&gt; 3 &lt;&lt; 3;
&nbsp;//        final byte[] bigBytes = bigInt.toByteArray();
&nbsp;//
&nbsp;//        if (bigInt.bitLength() % 8 != 0 &amp;&amp; bigInt.bitLength() / 8 + 1 == bitlen / 8) {
&nbsp;//            return bigBytes;
&nbsp;//        }
&nbsp;//        // set up params for copying everything but sign bit
&nbsp;//        int startSrc = 0;
&nbsp;//        int len = bigBytes.length;
&nbsp;//
&nbsp;//        // if bigInt is exactly byte-aligned, just skip signbit in copy
&nbsp;//        if (bigInt.bitLength() % 8 == 0) {
&nbsp;//            startSrc = 1;
&nbsp;//            len--;
&nbsp;//        }
&nbsp;//        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
&nbsp;//        final byte[] resizedBytes = new byte[bitlen / 8];
&nbsp;//        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);
&nbsp;//        return resizedBytes;
&nbsp;//    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    Base64Codec() {
<b class="nc">&nbsp;        this(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param urlSafe if {@code true}, URL-safe encoding is used. In most cases this should be set to
&nbsp;     *                {@code false}.
&nbsp;     * @since 1.4
&nbsp;     */
&nbsp;    Base64Codec(final boolean urlSafe) {
<b class="nc">&nbsp;        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is
&nbsp;     * STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Line lengths that aren&#39;t multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param lineLength Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
&nbsp;     *                   4). If lineLength &amp;lt;= 0, then the output will not be divided into lines (chunks). Ignored when
&nbsp;     *                   decoding.
&nbsp;     * @since 1.4
&nbsp;     */
&nbsp;    Base64Codec(final int lineLength) {
<b class="nc">&nbsp;        this(lineLength, CHUNK_SEPARATOR);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length and line separator are given in the constructor, and the encoding table is
&nbsp;     * STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Line lengths that aren&#39;t multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
&nbsp;     *                      4). If lineLength &amp;lt;= 0, then the output will not be divided into lines (chunks). Ignored when
&nbsp;     *                      decoding.
&nbsp;     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
&nbsp;     * @throws IllegalArgumentException Thrown when the provided lineSeparator included some base64 characters.
&nbsp;     * @since 1.4
&nbsp;     */
&nbsp;    Base64Codec(final int lineLength, final byte[] lineSeparator) {
<b class="nc">&nbsp;        this(lineLength, lineSeparator, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length and line separator are given in the constructor, and the encoding table is
&nbsp;     * STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Line lengths that aren&#39;t multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
&nbsp;     *                      4). If lineLength &amp;lt;= 0, then the output will not be divided into lines (chunks). Ignored when
&nbsp;     *                      decoding.
&nbsp;     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.
&nbsp;     * @param urlSafe       Instead of emitting &#39;+&#39; and &#39;/&#39; we emit &#39;-&#39; and &#39;_&#39; respectively. urlSafe is only applied to encode
&nbsp;     *                      operations. Decoding seamlessly handles both modes.
&nbsp;     *                      &lt;b&gt;Note: no padding is added when using the URL-safe alphabet.&lt;/b&gt;
&nbsp;     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base64 characters.
&nbsp;     * @since 1.4
&nbsp;     */
&nbsp;    Base64Codec(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {
<b class="fc">&nbsp;        this(lineLength, lineSeparator, urlSafe, DECODING_POLICY_DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
&nbsp;     * &lt;p&gt;
&nbsp;     * When encoding the line length and line separator are given in the constructor, and the encoding table is
&nbsp;     * STANDARD_ENCODE_TABLE.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Line lengths that aren&#39;t multiples of 4 will still essentially end up being multiples of 4 in the encoded data.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When decoding all variants are supported.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of
&nbsp;     *                       4). If lineLength &amp;lt;= 0, then the output will not be divided into lines (chunks). Ignored when
&nbsp;     *                       decoding.
&nbsp;     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.
&nbsp;     * @param urlSafe        Instead of emitting &#39;+&#39; and &#39;/&#39; we emit &#39;-&#39; and &#39;_&#39; respectively. urlSafe is only applied to encode
&nbsp;     *                       operations. Decoding seamlessly handles both modes.
&nbsp;     *                       &lt;b&gt;Note: no padding is added when using the URL-safe alphabet.&lt;/b&gt;
&nbsp;     * @param decodingPolicy The decoding policy.
&nbsp;     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base64 characters.
&nbsp;     * @since 1.15
&nbsp;     */
&nbsp;    Base64Codec(final int lineLength, final byte[] lineSeparator, final boolean urlSafe, final CodecPolicy decodingPolicy) {
<b class="fc">&nbsp;        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, BaseNCodec.length(lineSeparator),</b>
&nbsp;                PAD_DEFAULT, decodingPolicy);
&nbsp;        // TODO could be simplified if there is no requirement to reject invalid line sep when length &lt;=0
&nbsp;        // @see test case Base64Test.testConstructors()
<b class="pc">&nbsp;        if (lineSeparator != null) {</b>
<b class="pc">&nbsp;            if (containsAlphabetOrPad(lineSeparator)) {</b>
<b class="nc">&nbsp;                final String sep = Strings.utf8(lineSeparator);</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;lineSeparator must not contain base64 characters: [&quot; + sep + &quot;]&quot;);</b>
&nbsp;            }
<b class="pc">&nbsp;            if (lineLength &gt; 0) { // null line-sep forces no chunking rather than throwing IAE</b>
<b class="nc">&nbsp;                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;</b>
<b class="nc">&nbsp;                this.lineSeparator = lineSeparator.clone();</b>
&nbsp;            } else {
<b class="fc">&nbsp;                this.encodeSize = BYTES_PER_ENCODED_BLOCK;</b>
<b class="fc">&nbsp;                this.lineSeparator = null;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            this.encodeSize = BYTES_PER_ENCODED_BLOCK;</b>
<b class="nc">&nbsp;            this.lineSeparator = null;</b>
&nbsp;        }
<b class="fc">&nbsp;        this.decodeSize = this.encodeSize - 1;</b>
<b class="pc">&nbsp;        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Implementation of the Encoder Interface
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once
&nbsp;     * with the data to decode, and once with inAvail set to &quot;-1&quot; to alert decoder that EOF has been reached. The &quot;-1&quot;
&nbsp;     * call is not necessary when decoding, but it doesn&#39;t hurt, either.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are
&nbsp;     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,
&nbsp;     * garbage-out philosophy: it will not check the provided data for validity.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Thanks to &quot;commons&quot; project in ws.apache.org for the bitwise operations, and general approach.
&nbsp;     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param input   byte[] array of ASCII data to base64 decode.
&nbsp;     * @param inPos   Position to start reading data from.
&nbsp;     * @param inAvail Amount of bytes available from input for decoding.
&nbsp;     * @param context the context to be used
&nbsp;     */
&nbsp;    @Override
&nbsp;    void decode(final byte[] input, int inPos, final int inAvail, final Context context) {
<b class="nc">&nbsp;        if (context.eof) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (inAvail &lt; 0) {</b>
<b class="nc">&nbsp;            context.eof = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (int i = 0; i &lt; inAvail; i++) {</b>
<b class="nc">&nbsp;            final byte[] buffer = ensureBufferSize(decodeSize, context);</b>
<b class="nc">&nbsp;            final byte b = input[inPos++];</b>
<b class="nc">&nbsp;            if (b == pad) {</b>
&nbsp;                // We&#39;re done.
<b class="nc">&nbsp;                context.eof = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (b &gt;= 0 &amp;&amp; b &lt; DECODE_TABLE.length) {</b>
<b class="nc">&nbsp;                final int result = DECODE_TABLE[b];</b>
<b class="nc">&nbsp;                if (result &gt;= 0) {</b>
<b class="nc">&nbsp;                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;</b>
<b class="nc">&nbsp;                    context.ibitWorkArea = (context.ibitWorkArea &lt;&lt; BITS_PER_ENCODED_BYTE) + result;</b>
<b class="nc">&nbsp;                    if (context.modulus == 0) {</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = (byte) (context.ibitWorkArea &gt;&gt; 16 &amp; MASK_8BITS);</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = (byte) (context.ibitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = (byte) (context.ibitWorkArea &amp; MASK_8BITS);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Two forms of EOF as far as base64 decoder is concerned: actual
&nbsp;        // EOF (-1) and first time &#39;=&#39; character is encountered in stream.
&nbsp;        // This approach makes the &#39;=&#39; padding characters completely optional.
<b class="nc">&nbsp;        if (context.eof &amp;&amp; context.modulus != 0) {</b>
<b class="nc">&nbsp;            final byte[] buffer = ensureBufferSize(decodeSize, context);</b>
&nbsp;
&nbsp;            // We have some spare bits remaining
&nbsp;            // Output all whole multiples of 8 bits and ignore the rest
<b class="nc">&nbsp;            switch (context.modulus) {</b>
&nbsp;//              case 0 : // impossible, as excluded above
&nbsp;                case 1: // 6 bits - either ignore entirely, or raise an exception
<b class="nc">&nbsp;                    validateTrailingCharacter();</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 2: // 12 bits = 8 + 4
<b class="nc">&nbsp;                    validateCharacter(MASK_4BITS, context);</b>
<b class="nc">&nbsp;                    context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 4; // dump the extra 4 bits</b>
<b class="nc">&nbsp;                    buffer[context.pos++] = (byte) (context.ibitWorkArea &amp; MASK_8BITS);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 3: // 18 bits = 8 + 8 + 2
<b class="nc">&nbsp;                    validateCharacter(MASK_2BITS, context);</b>
<b class="nc">&nbsp;                    context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 2; // dump 2 bits</b>
<b class="nc">&nbsp;                    buffer[context.pos++] = (byte) (context.ibitWorkArea &gt;&gt; 8 &amp; MASK_8BITS);</b>
<b class="nc">&nbsp;                    buffer[context.pos++] = (byte) (context.ibitWorkArea &amp; MASK_8BITS);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Impossible modulus &quot; + context.modulus);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with
&nbsp;     * the data to encode, and once with inAvail set to &quot;-1&quot; to alert encoder that EOF has been reached, to flush last
&nbsp;     * remaining bytes (if not multiple of 3).
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;&lt;b&gt;Note: no padding is added when encoding using the URL-safe alphabet.&lt;/b&gt;&lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Thanks to &quot;commons&quot; project in ws.apache.org for the bitwise operations, and general approach.
&nbsp;     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param in      byte[] array of binary data to base64 encode.
&nbsp;     * @param inPos   Position to start reading data from.
&nbsp;     * @param inAvail Amount of bytes available from input for encoding.
&nbsp;     * @param context the context to be used
&nbsp;     */
&nbsp;    @Override
&nbsp;    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {
<b class="pc">&nbsp;        if (context.eof) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // inAvail &lt; 0 is how we&#39;re informed of EOF in the underlying data we&#39;re
&nbsp;        // encoding.
<b class="fc">&nbsp;        if (inAvail &lt; 0) {</b>
<b class="fc">&nbsp;            context.eof = true;</b>
<b class="pc">&nbsp;            if (0 == context.modulus &amp;&amp; lineLength == 0) {</b>
&nbsp;                return; // no leftovers to process and not using chunking
&nbsp;            }
<b class="fc">&nbsp;            final byte[] buffer = ensureBufferSize(encodeSize, context);</b>
<b class="fc">&nbsp;            final int savedPos = context.pos;</b>
<b class="pc">&nbsp;            switch (context.modulus) { // 0-2</b>
&nbsp;                case 0: // nothing to do here
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1: // 8 bits = 6 + 2
&nbsp;                    // top 6 bits:
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 2 &amp; MASK_6BITS];</b>
&nbsp;                    // remaining 2:
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &lt;&lt; 4 &amp; MASK_6BITS];</b>
&nbsp;                    // URL-SAFE skips the padding to further reduce size.
<b class="pc">&nbsp;                    if (encodeTable == STANDARD_ENCODE_TABLE) {</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = pad;</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = pad;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;
&nbsp;                case 2: // 16 bits = 6 + 6 + 4
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 10 &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 4 &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &lt;&lt; 2 &amp; MASK_6BITS];</b>
&nbsp;                    // URL-SAFE skips the padding to further reduce size.
<b class="pc">&nbsp;                    if (encodeTable == STANDARD_ENCODE_TABLE) {</b>
<b class="nc">&nbsp;                        buffer[context.pos++] = pad;</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                default:
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Impossible modulus &quot; + context.modulus);</b>
&nbsp;            }
<b class="fc">&nbsp;            context.currentLinePos += context.pos - savedPos; // keep track of current line position</b>
&nbsp;            // if currentPos == 0 we are at the start of a line, so don&#39;t add CRLF
<b class="pc">&nbsp;            if (lineLength &gt; 0 &amp;&amp; context.currentLinePos &gt; 0) {</b>
<b class="nc">&nbsp;                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);</b>
<b class="nc">&nbsp;                context.pos += lineSeparator.length;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; inAvail; i++) {</b>
<b class="fc">&nbsp;                final byte[] buffer = ensureBufferSize(encodeSize, context);</b>
<b class="fc">&nbsp;                context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;</b>
<b class="fc">&nbsp;                int b = in[inPos++];</b>
<b class="fc">&nbsp;                if (b &lt; 0) {</b>
<b class="fc">&nbsp;                    b += 256;</b>
&nbsp;                }
<b class="fc">&nbsp;                context.ibitWorkArea = (context.ibitWorkArea &lt;&lt; 8) + b; //  BITS_PER_BYTE</b>
<b class="fc">&nbsp;                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 18 &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 12 &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &gt;&gt; 6 &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    buffer[context.pos++] = encodeTable[context.ibitWorkArea &amp; MASK_6BITS];</b>
<b class="fc">&nbsp;                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;</b>
<b class="pc">&nbsp;                    if (lineLength &gt; 0 &amp;&amp; lineLength &lt;= context.currentLinePos) {</b>
<b class="nc">&nbsp;                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);</b>
<b class="nc">&nbsp;                        context.pos += lineSeparator.length;</b>
<b class="nc">&nbsp;                        context.currentLinePos = 0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether or not the {@code octet} is in the Base64 alphabet.
&nbsp;     *
&nbsp;     * @param octet The value to test
&nbsp;     * @return {@code true} if the value is defined in the Base64 alphabet {@code false} otherwise.
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected boolean isInAlphabet(final byte octet) {
<b class="pc">&nbsp;        return octet &gt;= 0 &amp;&amp; octet &lt; decodeTable.length &amp;&amp; decodeTable[octet] != -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns our current encode mode. True if we&#39;re URL-SAFE, false otherwise.
&nbsp;     *
&nbsp;     * @return true if we&#39;re in URL-SAFE mode, false otherwise.
&nbsp;     * @since 1.4
&nbsp;     */
&nbsp;    public boolean isUrlSafe() {
<b class="nc">&nbsp;        return this.encodeTable == URL_SAFE_ENCODE_TABLE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Validates whether decoding the final trailing character is possible in the context
&nbsp;     * of the set of possible base 64 values.
&nbsp;     * &lt;p&gt;
&nbsp;     * The character is valid if the lower bits within the provided mask are zero. This
&nbsp;     * is used to test the final trailing base-64 digit is zero in the bits that will be discarded.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param emptyBitsMask The mask of the lower bits that should be empty
&nbsp;     * @param context       the context to be used
&nbsp;     * @throws IllegalArgumentException if the bits being checked contain any non-zero value
&nbsp;     */
&nbsp;    private void validateCharacter(final int emptyBitsMask, final Context context) {
<b class="nc">&nbsp;        if (isStrictDecoding() &amp;&amp; (context.ibitWorkArea &amp; emptyBitsMask) != 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Strict decoding: Last encoded character (before the paddings if any) is a valid &quot; +
&nbsp;                            &quot;base 64 alphabet but not a possible encoding. &quot; +
&nbsp;                            &quot;Expected the discarded bits from the character to be zero.&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Validates whether decoding allows an entire final trailing character that cannot be
&nbsp;     * used for a complete byte.
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException if strict decoding is enabled
&nbsp;     */
&nbsp;    private void validateTrailingCharacter() {
<b class="nc">&nbsp;        if (isStrictDecoding()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;Strict decoding: Last encoded character (before the paddings if any) is a valid &quot; +
&nbsp;                            &quot;base 64 alphabet but not a possible encoding. &quot; +
&nbsp;                            &quot;Decoding requires at least two trailing 6-bit characters to create bytes.&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
