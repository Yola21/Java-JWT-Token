


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DefaultJwtParserBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl</a>
</div>

<h1>Coverage Summary for Class: DefaultJwtParserBuilder (io.jsonwebtoken.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultJwtParserBuilder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (38/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (112/112)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultJwtParserBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtParserBuilder$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtParserBuilder$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtParserBuilder$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtParserBuilder$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (48/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (127/127)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2019 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl;
&nbsp;
&nbsp;import io.jsonwebtoken.ClaimsBuilder;
&nbsp;import io.jsonwebtoken.Clock;
&nbsp;import io.jsonwebtoken.CompressionCodecResolver;
&nbsp;import io.jsonwebtoken.JwtParser;
&nbsp;import io.jsonwebtoken.JwtParserBuilder;
&nbsp;import io.jsonwebtoken.Jwts;
&nbsp;import io.jsonwebtoken.Locator;
&nbsp;import io.jsonwebtoken.SigningKeyResolver;
&nbsp;import io.jsonwebtoken.impl.io.DelegateStringDecoder;
&nbsp;import io.jsonwebtoken.impl.io.StandardCompressionAlgorithms;
&nbsp;import io.jsonwebtoken.impl.lang.DefaultNestedCollection;
&nbsp;import io.jsonwebtoken.impl.lang.IdRegistry;
&nbsp;import io.jsonwebtoken.impl.lang.Services;
&nbsp;import io.jsonwebtoken.impl.security.ConstantKeyLocator;
&nbsp;import io.jsonwebtoken.impl.security.StandardEncryptionAlgorithms;
&nbsp;import io.jsonwebtoken.impl.security.StandardKeyAlgorithms;
&nbsp;import io.jsonwebtoken.impl.security.StandardSecureDigestAlgorithms;
&nbsp;import io.jsonwebtoken.io.CompressionAlgorithm;
&nbsp;import io.jsonwebtoken.io.Decoder;
&nbsp;import io.jsonwebtoken.io.Decoders;
&nbsp;import io.jsonwebtoken.io.Deserializer;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.NestedCollection;
&nbsp;import io.jsonwebtoken.lang.Registry;
&nbsp;import io.jsonwebtoken.security.AeadAlgorithm;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.KeyAlgorithm;
&nbsp;import io.jsonwebtoken.security.Keys;
&nbsp;import io.jsonwebtoken.security.SecureDigestAlgorithm;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import java.io.InputStream;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.Provider;
&nbsp;import java.security.PublicKey;
&nbsp;import java.util.Date;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
&nbsp;/**
&nbsp; * @since 0.11.0
&nbsp; */
<b class="fc">&nbsp;public class DefaultJwtParserBuilder implements JwtParserBuilder {</b>
&nbsp;
&nbsp;    private static final int MILLISECONDS_PER_SECOND = 1000;
&nbsp;
&nbsp;    /**
&nbsp;     * To prevent overflow per &lt;a href=&quot;https://github.com/jwtk/jjwt/issues/583&quot;&gt;Issue 583&lt;/a&gt;.
&nbsp;     * &lt;p&gt;
&nbsp;     * Package-protected on purpose to allow use in backwards-compatible {@link DefaultJwtParser} implementation.
&nbsp;     * TODO: enable private modifier on these two variables when deleting DefaultJwtParser
&nbsp;     */
&nbsp;    static final long MAX_CLOCK_SKEW_MILLIS = Long.MAX_VALUE / MILLISECONDS_PER_SECOND;
&nbsp;    static final String MAX_CLOCK_SKEW_ILLEGAL_MSG = &quot;Illegal allowedClockSkewMillis value: multiplying this &quot; +
&nbsp;            &quot;value by 1000 to obtain the number of milliseconds would cause a numeric overflow.&quot;;
&nbsp;
&nbsp;    private Provider provider;
&nbsp;
<b class="fc">&nbsp;    private boolean unsecured = false;</b>
&nbsp;
<b class="fc">&nbsp;    private boolean unsecuredDecompression = false;</b>
&nbsp;
&nbsp;    private Locator&lt;? extends Key&gt; keyLocator;
&nbsp;
<b class="fc">&nbsp;    @SuppressWarnings(&quot;deprecation&quot;) //TODO: remove for 1.0</b>
&nbsp;    private SigningKeyResolver signingKeyResolver = null;
&nbsp;
<b class="fc">&nbsp;    private Registry&lt;String, AeadAlgorithm&gt; encAlgs = Jwts.ENC.get();</b>
&nbsp;
<b class="fc">&nbsp;    private Registry&lt;String, KeyAlgorithm&lt;?, ?&gt;&gt; keyAlgs = Jwts.KEY.get();</b>
&nbsp;
<b class="fc">&nbsp;    private Registry&lt;String, SecureDigestAlgorithm&lt;?, ?&gt;&gt; sigAlgs = Jwts.SIG.get();</b>
&nbsp;
<b class="fc">&nbsp;    private Registry&lt;String, CompressionAlgorithm&gt; zipAlgs = Jwts.ZIP.get();</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    private CompressionCodecResolver compressionCodecResolver;
&nbsp;
<b class="fc">&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
&nbsp;    private Decoder&lt;InputStream, InputStream&gt; decoder = new DelegateStringDecoder(Decoders.BASE64URL);
&nbsp;
&nbsp;    private Deserializer&lt;Map&lt;String, ?&gt;&gt; deserializer;
&nbsp;
<b class="fc">&nbsp;    private final ClaimsBuilder expectedClaims = Jwts.claims();</b>
&nbsp;
<b class="fc">&nbsp;    private Clock clock = DefaultClock.INSTANCE;</b>
&nbsp;
<b class="fc">&nbsp;    private Set&lt;String&gt; critical = Collections.emptySet();</b>
&nbsp;
<b class="fc">&nbsp;    private long allowedClockSkewMillis = 0;</b>
&nbsp;
&nbsp;    private Key signatureVerificationKey;
&nbsp;    private Key decryptionKey;
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder unsecured() {
<b class="fc">&nbsp;        this.unsecured = true;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder unsecuredDecompression() {
<b class="fc">&nbsp;        this.unsecuredDecompression = true;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder provider(Provider provider) {
<b class="fc">&nbsp;        this.provider = provider;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder deserializeJsonWith(Deserializer&lt;Map&lt;String, ?&gt;&gt; deserializer) {
<b class="fc">&nbsp;        return json(deserializer);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder json(Deserializer&lt;Map&lt;String, ?&gt;&gt; reader) {
<b class="fc">&nbsp;        this.deserializer = Assert.notNull(reader, &quot;JSON Deserializer cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    @Override
&nbsp;    public JwtParserBuilder base64UrlDecodeWith(final Decoder&lt;CharSequence, byte[]&gt; decoder) {
<b class="fc">&nbsp;        Assert.notNull(decoder, &quot;decoder cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return b64Url(new DelegateStringDecoder(decoder));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder b64Url(Decoder&lt;InputStream, InputStream&gt; decoder) {
<b class="fc">&nbsp;        Assert.notNull(decoder, &quot;decoder cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.decoder = decoder;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireIssuedAt(Date issuedAt) {
<b class="fc">&nbsp;        expectedClaims.setIssuedAt(issuedAt);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireIssuer(String issuer) {
<b class="fc">&nbsp;        expectedClaims.setIssuer(issuer);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireAudience(String audience) {
<b class="fc">&nbsp;        expectedClaims.audience().add(audience).and();</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireSubject(String subject) {
<b class="fc">&nbsp;        expectedClaims.setSubject(subject);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireId(String id) {
<b class="fc">&nbsp;        expectedClaims.setId(id);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireExpiration(Date expiration) {
<b class="fc">&nbsp;        expectedClaims.setExpiration(expiration);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder requireNotBefore(Date notBefore) {
<b class="fc">&nbsp;        expectedClaims.setNotBefore(notBefore);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder require(String claimName, Object value) {
<b class="fc">&nbsp;        Assert.hasText(claimName, &quot;claim name cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        Assert.notNull(value, &quot;The value cannot be null for claim name: &quot; + claimName);</b>
<b class="fc">&nbsp;        expectedClaims.add(claimName, value);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setClock(Clock clock) {
<b class="fc">&nbsp;        return clock(clock);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder clock(Clock clock) {
<b class="fc">&nbsp;        Assert.notNull(clock, &quot;Clock instance cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.clock = clock;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestedCollection&lt;String, JwtParserBuilder&gt; critical() {
<b class="fc">&nbsp;        return new DefaultNestedCollection&lt;String, JwtParserBuilder&gt;(this, this.critical) {</b>
&nbsp;            @Override
&nbsp;            public JwtParserBuilder and() {
<b class="fc">&nbsp;                critical = Collections.asSet(getCollection());</b>
<b class="fc">&nbsp;                return super.and();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setAllowedClockSkewSeconds(long seconds) throws IllegalArgumentException {
<b class="fc">&nbsp;        return clockSkewSeconds(seconds);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder clockSkewSeconds(long seconds) throws IllegalArgumentException {
<b class="fc">&nbsp;        Assert.isTrue(seconds &lt;= MAX_CLOCK_SKEW_MILLIS, MAX_CLOCK_SKEW_ILLEGAL_MSG);</b>
<b class="fc">&nbsp;        this.allowedClockSkewMillis = Math.max(0, seconds * MILLISECONDS_PER_SECOND);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setSigningKey(byte[] key) {
<b class="fc">&nbsp;        Assert.notEmpty(key, &quot;signature verification key cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        return setSigningKey(Keys.hmacShaKeyFor(key));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setSigningKey(String base64EncodedSecretKey) {
<b class="fc">&nbsp;        Assert.hasText(base64EncodedSecretKey, &quot;signature verification key cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        byte[] bytes = Decoders.BASE64.decode(base64EncodedSecretKey);</b>
<b class="fc">&nbsp;        return setSigningKey(bytes);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setSigningKey(final Key key) {
<b class="fc">&nbsp;        if (key instanceof SecretKey) {</b>
<b class="fc">&nbsp;            return verifyWith((SecretKey) key);</b>
<b class="fc">&nbsp;        } else if (key instanceof PublicKey) {</b>
<b class="fc">&nbsp;            return verifyWith((PublicKey) key);</b>
&nbsp;        }
<b class="fc">&nbsp;        String msg = &quot;JWS verification key must be either a SecretKey (for MAC algorithms) or a PublicKey &quot; +</b>
&nbsp;                &quot;(for Signature algorithms).&quot;;
<b class="fc">&nbsp;        throw new InvalidKeyException(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder verifyWith(SecretKey key) {
<b class="fc">&nbsp;        return verifyWith((Key) key);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder verifyWith(PublicKey key) {
<b class="fc">&nbsp;        return verifyWith((Key) key);</b>
&nbsp;    }
&nbsp;
&nbsp;    private JwtParserBuilder verifyWith(Key key) {
<b class="fc">&nbsp;        if (key instanceof PrivateKey) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(DefaultJwtParser.PRIV_KEY_VERIFY_MSG);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.signatureVerificationKey = Assert.notNull(key, &quot;signature verification key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder decryptWith(SecretKey key) {
<b class="fc">&nbsp;        return decryptWith((Key) key);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder decryptWith(PrivateKey key) {
<b class="fc">&nbsp;        return decryptWith((Key) key);</b>
&nbsp;    }
&nbsp;
&nbsp;    private JwtParserBuilder decryptWith(final Key key) {
<b class="fc">&nbsp;        if (key instanceof PublicKey) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(DefaultJwtParser.PUB_KEY_DECRYPT_MSG);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.decryptionKey = Assert.notNull(key, &quot;decryption key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestedCollection&lt;CompressionAlgorithm, JwtParserBuilder&gt; zip() {
<b class="fc">&nbsp;        return new DefaultNestedCollection&lt;CompressionAlgorithm, JwtParserBuilder&gt;(this, this.zipAlgs.values()) {</b>
&nbsp;            @Override
&nbsp;            public JwtParserBuilder and() {
<b class="fc">&nbsp;                zipAlgs = new IdRegistry&lt;&gt;(StandardCompressionAlgorithms.NAME, getCollection());</b>
<b class="fc">&nbsp;                return super.and();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestedCollection&lt;AeadAlgorithm, JwtParserBuilder&gt; enc() {
<b class="fc">&nbsp;        return new DefaultNestedCollection&lt;AeadAlgorithm, JwtParserBuilder&gt;(this, this.encAlgs.values()) {</b>
&nbsp;            @Override
&nbsp;            public JwtParserBuilder and() {
<b class="fc">&nbsp;                encAlgs = new IdRegistry&lt;&gt;(StandardEncryptionAlgorithms.NAME, getCollection());</b>
<b class="fc">&nbsp;                return super.and();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestedCollection&lt;SecureDigestAlgorithm&lt;?, ?&gt;, JwtParserBuilder&gt; sig() {
<b class="fc">&nbsp;        return new DefaultNestedCollection&lt;SecureDigestAlgorithm&lt;?, ?&gt;, JwtParserBuilder&gt;(this, this.sigAlgs.values()) {</b>
&nbsp;            @Override
&nbsp;            public JwtParserBuilder and() {
<b class="fc">&nbsp;                sigAlgs = new IdRegistry&lt;&gt;(StandardSecureDigestAlgorithms.NAME, getCollection());</b>
<b class="fc">&nbsp;                return super.and();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NestedCollection&lt;KeyAlgorithm&lt;?, ?&gt;, JwtParserBuilder&gt; key() {
<b class="fc">&nbsp;        return new DefaultNestedCollection&lt;KeyAlgorithm&lt;?, ?&gt;, JwtParserBuilder&gt;(this, this.keyAlgs.values()) {</b>
&nbsp;            @Override
&nbsp;            public JwtParserBuilder and() {
<b class="fc">&nbsp;                keyAlgs = new IdRegistry&lt;&gt;(StandardKeyAlgorithms.NAME, getCollection());</b>
<b class="fc">&nbsp;                return super.and();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;) //TODO: remove for 1.0
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setSigningKeyResolver(SigningKeyResolver signingKeyResolver) {
<b class="fc">&nbsp;        Assert.notNull(signingKeyResolver, &quot;SigningKeyResolver cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.signingKeyResolver = signingKeyResolver;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParserBuilder keyLocator(Locator&lt;Key&gt; keyLocator) {
<b class="fc">&nbsp;        this.keyLocator = Assert.notNull(keyLocator, &quot;Key locator cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    @Override
&nbsp;    public JwtParserBuilder setCompressionCodecResolver(CompressionCodecResolver resolver) {
<b class="fc">&nbsp;        this.compressionCodecResolver = Assert.notNull(resolver, &quot;CompressionCodecResolver cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtParser build() {
&nbsp;
<b class="fc">&nbsp;        if (this.deserializer == null) {</b>
&nbsp;            //noinspection unchecked
<b class="fc">&nbsp;            json(Services.loadFirst(Deserializer.class));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.signingKeyResolver != null &amp;&amp; this.signatureVerificationKey != null) {</b>
<b class="fc">&nbsp;            String msg = &quot;Both a &#39;signingKeyResolver and a &#39;verifyWith&#39; key cannot be configured. &quot; +</b>
&nbsp;                    &quot;Choose either, or prefer `keyLocator` when possible.&quot;;
<b class="fc">&nbsp;            throw new IllegalStateException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.keyLocator != null) {</b>
<b class="fc">&nbsp;            if (this.signatureVerificationKey != null) {</b>
<b class="fc">&nbsp;                String msg = &quot;Both &#39;keyLocator&#39; and a &#39;verifyWith&#39; key cannot be configured. &quot; +</b>
&nbsp;                        &quot;Prefer &#39;keyLocator&#39; if possible.&quot;;
<b class="fc">&nbsp;                throw new IllegalStateException(msg);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (this.decryptionKey != null) {</b>
<b class="fc">&nbsp;                String msg = &quot;Both &#39;keyLocator&#39; and a &#39;decryptWith&#39; key cannot be configured. &quot; +</b>
&nbsp;                        &quot;Prefer &#39;keyLocator&#39; if possible.&quot;;
<b class="fc">&nbsp;                throw new IllegalStateException(msg);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Locator&lt;? extends Key&gt; keyLocator = this.keyLocator; // user configured default, don&#39;t overwrite to ensure further build() calls work as expected</b>
<b class="fc">&nbsp;        if (keyLocator == null) {</b>
<b class="fc">&nbsp;            keyLocator = new ConstantKeyLocator(this.signatureVerificationKey, this.decryptionKey);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (!unsecured &amp;&amp; unsecuredDecompression) {</b>
<b class="fc">&nbsp;            String msg = &quot;&#39;unsecuredDecompression&#39; is only relevant if &#39;unsecured&#39; is also &quot; +</b>
&nbsp;                    &quot;configured. Please read the JavaDoc of both features before enabling either &quot; +
&nbsp;                    &quot;due to their security implications.&quot;;
<b class="fc">&nbsp;            throw new IllegalStateException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (this.compressionCodecResolver != null &amp;&amp; !Jwts.ZIP.get().equals(this.zipAlgs)) {</b>
<b class="fc">&nbsp;            String msg = &quot;Both &#39;zip()&#39; and &#39;compressionCodecResolver&#39; &quot; +</b>
&nbsp;                    &quot;cannot be configured. Choose either.&quot;;
<b class="fc">&nbsp;            throw new IllegalStateException(msg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Invariants.  If these are ever violated, it&#39;s an error in this class implementation:
<b class="fc">&nbsp;        Assert.stateNotNull(keyLocator, &quot;Key locator should never be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        final DefaultClaims expClaims = (DefaultClaims) this.expectedClaims.build();</b>
&nbsp;
<b class="fc">&nbsp;        return new DefaultJwtParser(</b>
&nbsp;                provider,
&nbsp;                signingKeyResolver,
&nbsp;                unsecured,
&nbsp;                unsecuredDecompression,
&nbsp;                keyLocator,
&nbsp;                clock,
&nbsp;                critical,
&nbsp;                allowedClockSkewMillis,
&nbsp;                expClaims,
&nbsp;                decoder,
&nbsp;                deserializer,
&nbsp;                compressionCodecResolver,
&nbsp;                zipAlgs,
&nbsp;                sigAlgs,
&nbsp;                keyAlgs,
&nbsp;                encAlgs
&nbsp;        );
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
