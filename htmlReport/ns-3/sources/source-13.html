


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DefaultJwtBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.jsonwebtoken.impl</a>
</div>

<h1>Coverage Summary for Class: DefaultJwtBuilder (io.jsonwebtoken.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultJwtBuilder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (61/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.7%
  </span>
  <span class="absValue">
    (75/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (270/270)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultJwtBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtBuilder$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtBuilder$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtBuilder$DefaultBuilderClaims</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultJwtBuilder$DefaultBuilderHeader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (76/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.7%
  </span>
  <span class="absValue">
    (75/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (288/288)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2014 jsonwebtoken.io
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package io.jsonwebtoken.impl;
&nbsp;
&nbsp;import io.jsonwebtoken.Claims;
&nbsp;import io.jsonwebtoken.Header;
&nbsp;import io.jsonwebtoken.JweHeader;
&nbsp;import io.jsonwebtoken.JwsHeader;
&nbsp;import io.jsonwebtoken.JwtBuilder;
&nbsp;import io.jsonwebtoken.Jwts;
&nbsp;import io.jsonwebtoken.impl.io.Base64UrlStreamEncoder;
&nbsp;import io.jsonwebtoken.impl.io.ByteBase64UrlStreamEncoder;
&nbsp;import io.jsonwebtoken.impl.io.CountingInputStream;
&nbsp;import io.jsonwebtoken.impl.io.EncodingOutputStream;
&nbsp;import io.jsonwebtoken.impl.io.NamedSerializer;
&nbsp;import io.jsonwebtoken.impl.io.Streams;
&nbsp;import io.jsonwebtoken.impl.io.UncloseableInputStream;
&nbsp;import io.jsonwebtoken.impl.lang.Bytes;
&nbsp;import io.jsonwebtoken.impl.lang.Function;
&nbsp;import io.jsonwebtoken.impl.lang.Functions;
&nbsp;import io.jsonwebtoken.impl.lang.Parameter;
&nbsp;import io.jsonwebtoken.impl.lang.Services;
&nbsp;import io.jsonwebtoken.impl.security.DefaultAeadRequest;
&nbsp;import io.jsonwebtoken.impl.security.DefaultAeadResult;
&nbsp;import io.jsonwebtoken.impl.security.DefaultKeyRequest;
&nbsp;import io.jsonwebtoken.impl.security.DefaultSecureRequest;
&nbsp;import io.jsonwebtoken.impl.security.Pbes2HsAkwAlgorithm;
&nbsp;import io.jsonwebtoken.impl.security.ProviderKey;
&nbsp;import io.jsonwebtoken.impl.security.StandardSecureDigestAlgorithms;
&nbsp;import io.jsonwebtoken.io.CompressionAlgorithm;
&nbsp;import io.jsonwebtoken.io.Decoders;
&nbsp;import io.jsonwebtoken.io.Encoder;
&nbsp;import io.jsonwebtoken.io.Serializer;
&nbsp;import io.jsonwebtoken.lang.Assert;
&nbsp;import io.jsonwebtoken.lang.Collections;
&nbsp;import io.jsonwebtoken.lang.Objects;
&nbsp;import io.jsonwebtoken.lang.Strings;
&nbsp;import io.jsonwebtoken.security.AeadAlgorithm;
&nbsp;import io.jsonwebtoken.security.AeadRequest;
&nbsp;import io.jsonwebtoken.security.AeadResult;
&nbsp;import io.jsonwebtoken.security.InvalidKeyException;
&nbsp;import io.jsonwebtoken.security.KeyAlgorithm;
&nbsp;import io.jsonwebtoken.security.KeyRequest;
&nbsp;import io.jsonwebtoken.security.KeyResult;
&nbsp;import io.jsonwebtoken.security.Password;
&nbsp;import io.jsonwebtoken.security.SecureDigestAlgorithm;
&nbsp;import io.jsonwebtoken.security.SecureRequest;
&nbsp;import io.jsonwebtoken.security.SecurityException;
&nbsp;import io.jsonwebtoken.security.SignatureException;
&nbsp;import io.jsonwebtoken.security.UnsupportedKeyException;
&nbsp;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.crypto.spec.SecretKeySpec;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.SequenceInputStream;
&nbsp;import java.security.Key;
&nbsp;import java.security.PrivateKey;
&nbsp;import java.security.Provider;
&nbsp;import java.security.PublicKey;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.util.Date;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;
<b class="fc">&nbsp;public class DefaultJwtBuilder implements JwtBuilder {</b>
&nbsp;
&nbsp;    private static final String PUB_KEY_SIGN_MSG = &quot;PublicKeys may not be used to create digital signatures. &quot; +
&nbsp;            &quot;PrivateKeys are used to sign, and PublicKeys are used to verify.&quot;;
&nbsp;
&nbsp;    private static final String PRIV_KEY_ENC_MSG = &quot;PrivateKeys may not be used to encrypt data. PublicKeys are &quot; +
&nbsp;            &quot;used to encrypt, and PrivateKeys are used to decrypt.&quot;;
&nbsp;
&nbsp;    protected Provider provider;
&nbsp;    protected SecureRandom secureRandom;
&nbsp;
&nbsp;    private final DefaultBuilderHeader headerBuilder;
&nbsp;    private final DefaultBuilderClaims claimsBuilder;
&nbsp;
<b class="fc">&nbsp;    private Payload payload = Payload.EMPTY;</b>
&nbsp;
<b class="fc">&nbsp;    private SecureDigestAlgorithm&lt;Key, ?&gt; sigAlg = Jwts.SIG.NONE;</b>
&nbsp;    private Function&lt;SecureRequest&lt;InputStream, Key&gt;, byte[]&gt; signFunction;
&nbsp;
&nbsp;    private AeadAlgorithm enc; // MUST be Symmetric AEAD per https://tools.ietf.org/html/rfc7516#section-4.1.2
&nbsp;
&nbsp;    private KeyAlgorithm&lt;Key, ?&gt; keyAlg;
&nbsp;    private Function&lt;KeyRequest&lt;Key&gt;, KeyResult&gt; keyAlgFunction;
&nbsp;
&nbsp;    private Key key;
&nbsp;
&nbsp;    private Serializer&lt;Map&lt;String, ?&gt;&gt; serializer;
&nbsp;
<b class="fc">&nbsp;    protected Encoder&lt;OutputStream, OutputStream&gt; encoder = Base64UrlStreamEncoder.INSTANCE;</b>
<b class="fc">&nbsp;    private boolean encodePayload = true;</b>
&nbsp;    protected CompressionAlgorithm compressionAlgorithm;
&nbsp;
<b class="fc">&nbsp;    public DefaultJwtBuilder() {</b>
<b class="fc">&nbsp;        this.headerBuilder = new DefaultBuilderHeader(this);</b>
<b class="fc">&nbsp;        this.claimsBuilder = new DefaultBuilderClaims(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BuilderHeader header() {
<b class="fc">&nbsp;        return this.headerBuilder;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BuilderClaims claims() {
<b class="fc">&nbsp;        return this.claimsBuilder;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder provider(Provider provider) {
<b class="fc">&nbsp;        this.provider = provider;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder random(SecureRandom secureRandom) {
<b class="fc">&nbsp;        this.secureRandom = secureRandom;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder serializeToJsonWith(final Serializer&lt;Map&lt;String, ?&gt;&gt; serializer) {
<b class="fc">&nbsp;        return json(serializer);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder json(Serializer&lt;Map&lt;String, ?&gt;&gt; serializer) {
<b class="fc">&nbsp;        this.serializer = Assert.notNull(serializer, &quot;JSON Serializer cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder base64UrlEncodeWith(Encoder&lt;byte[], String&gt; encoder) {
<b class="fc">&nbsp;        return b64Url(new ByteBase64UrlStreamEncoder(encoder));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder b64Url(Encoder&lt;OutputStream, OutputStream&gt; encoder) {
<b class="fc">&nbsp;        Assert.notNull(encoder, &quot;encoder cannot be null.&quot;);</b>
<b class="fc">&nbsp;        this.encoder = encoder;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder encodePayload(boolean b64) {
<b class="fc">&nbsp;        this.encodePayload = b64;</b>
&nbsp;        // clear out any previous values. They will be applied appropriately during compact()
<b class="fc">&nbsp;        String critParamId = DefaultProtectedHeader.CRIT.getId();</b>
<b class="fc">&nbsp;        String b64Id = DefaultJwsHeader.B64.getId();</b>
<b class="fc">&nbsp;        Set&lt;String&gt; crit = this.headerBuilder.get(DefaultProtectedHeader.CRIT);</b>
<b class="fc">&nbsp;        crit = new LinkedHashSet&lt;&gt;(Collections.nullSafe(crit));</b>
<b class="fc">&nbsp;        crit.remove(b64Id);</b>
<b class="fc">&nbsp;        return header().delete(b64Id).add(critParamId, crit).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setHeader(Map&lt;String, ?&gt; map) {
<b class="fc">&nbsp;        return header().empty().add(map).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setHeaderParams(Map&lt;String, ?&gt; params) {
<b class="fc">&nbsp;        return header().add(params).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setHeaderParam(String name, Object value) {
<b class="fc">&nbsp;        return header().add(name, value).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected static &lt;K extends Key&gt; SecureDigestAlgorithm&lt;K, ?&gt; forSigningKey(K key) {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        SecureDigestAlgorithm&lt;K, ?&gt; alg = StandardSecureDigestAlgorithms.findBySigningKey(key);</b>
<b class="fc">&nbsp;        if (alg == null) {</b>
<b class="fc">&nbsp;            String msg = &quot;Unable to determine a suitable MAC or Signature algorithm for the specified key using &quot; +</b>
&nbsp;                    &quot;available heuristics: either the key size is too weak be used with available algorithms, or the &quot; +
&nbsp;                    &quot;key size is unavailable (e.g. if using a PKCS11 or HSM (Hardware Security Module) key store). &quot; +
&nbsp;                    &quot;If you are using a PKCS11 or HSM keystore, consider using the &quot; +
&nbsp;                    &quot;JwtBuilder.signWith(Key, SecureDigestAlgorithm) method instead.&quot;;
<b class="fc">&nbsp;            throw new UnsupportedKeyException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        return alg;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder signWith(Key key) throws InvalidKeyException {
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Key argument cannot be null.&quot;);</b>
<b class="fc">&nbsp;        SecureDigestAlgorithm&lt;Key, ?&gt; alg = forSigningKey(key); // https://github.com/jwtk/jjwt/issues/381</b>
<b class="fc">&nbsp;        return signWith(key, alg);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;K extends Key&gt; JwtBuilder signWith(K key, final SecureDigestAlgorithm&lt;? super K, ?&gt; alg)
&nbsp;            throws InvalidKeyException {
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Key argument cannot be null.&quot;);</b>
<b class="fc">&nbsp;        if (key instanceof PublicKey) { // it&#39;s always wrong/insecure to try to create signatures with PublicKeys:</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(PUB_KEY_SIGN_MSG);</b>
&nbsp;        }
&nbsp;        // Implementation note:  Ordinarily Passwords should not be used to create secure digests because they usually
&nbsp;        // lack the length or entropy necessary for secure cryptographic operations, and are prone to misuse.
&nbsp;        // However, we DO NOT prevent them as arguments here (like the above PublicKey check) because
&nbsp;        // it is conceivable that a custom SecureDigestAlgorithm implementation would allow Password instances
&nbsp;        // so that it might perform its own internal key-derivation logic producing a key that is then used to create a
&nbsp;        // secure hash.
&nbsp;        //
&nbsp;        // Even so, a fallback safety check is that JJWT&#39;s only out-of-the-box Password implementation
&nbsp;        // (io.jsonwebtoken.impl.security.PasswordSpec) explicitly forbids calls to password.getEncoded() in all
&nbsp;        // scenarios to avoid potential misuse, so a digest algorithm implementation would explicitly need to avoid
&nbsp;        // this by calling toCharArray() instead.
&nbsp;        //
&nbsp;        // TLDR; the digest algorithm implementation has the final say whether a password instance is valid
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;SignatureAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        String id = Assert.hasText(alg.getId(), &quot;SignatureAlgorithm id cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        if (Jwts.SIG.NONE.getId().equalsIgnoreCase(id)) {</b>
<b class="fc">&nbsp;            String msg = &quot;The &#39;none&#39; JWS algorithm cannot be used to sign JWTs.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.key = key;</b>
&nbsp;        //noinspection unchecked
<b class="fc">&nbsp;        this.sigAlg = (SecureDigestAlgorithm&lt;Key, ?&gt;) alg;</b>
<b class="fc">&nbsp;        this.signFunction = Functions.wrap(new Function&lt;SecureRequest&lt;InputStream, Key&gt;, byte[]&gt;() {</b>
&nbsp;            @Override
&nbsp;            public byte[] apply(SecureRequest&lt;InputStream, Key&gt; request) {
<b class="fc">&nbsp;                return sigAlg.digest(request);</b>
&nbsp;            }
&nbsp;        }, SignatureException.class, &quot;Unable to compute %s signature.&quot;, id);
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings({&quot;deprecation&quot;, &quot;unchecked&quot;}) // TODO: remove method for 1.0
&nbsp;    @Override
&nbsp;    public JwtBuilder signWith(Key key, io.jsonwebtoken.SignatureAlgorithm alg) throws InvalidKeyException {
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;SignatureAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        alg.assertValidSigningKey(key); //since 0.10.0 for https://github.com/jwtk/jjwt/issues/334</b>
<b class="fc">&nbsp;        return signWith(key, (SecureDigestAlgorithm&lt;? super Key, ?&gt;) Jwts.SIG.get().forKey(alg.getValue()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;) // TODO: remove method for 1.0
&nbsp;    @Override
&nbsp;    public JwtBuilder signWith(io.jsonwebtoken.SignatureAlgorithm alg, byte[] secretKeyBytes) throws InvalidKeyException {
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;SignatureAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.notEmpty(secretKeyBytes, &quot;secret key byte array cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        Assert.isTrue(alg.isHmac(), &quot;Key bytes may only be specified for HMAC signatures.  &quot; +</b>
&nbsp;                &quot;If using RSA or Elliptic Curve, use the signWith(SignatureAlgorithm, Key) method instead.&quot;);
<b class="fc">&nbsp;        SecretKey key = new SecretKeySpec(secretKeyBytes, alg.getJcaName());</b>
<b class="fc">&nbsp;        return signWith(key, alg);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;) // TODO: remove method for 1.0
&nbsp;    @Override
&nbsp;    public JwtBuilder signWith(io.jsonwebtoken.SignatureAlgorithm alg, String base64EncodedSecretKey) throws InvalidKeyException {
<b class="fc">&nbsp;        Assert.hasText(base64EncodedSecretKey, &quot;base64-encoded secret key cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        Assert.isTrue(alg.isHmac(), &quot;Base64-encoded key bytes may only be specified for HMAC signatures.  &quot; +</b>
&nbsp;                &quot;If using RSA or Elliptic Curve, use the signWith(SignatureAlgorithm, Key) method instead.&quot;);
<b class="fc">&nbsp;        byte[] bytes = Decoders.BASE64.decode(base64EncodedSecretKey);</b>
<b class="fc">&nbsp;        return signWith(alg, bytes);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;) // TODO: remove method for 1.0
&nbsp;    @Override
&nbsp;    public JwtBuilder signWith(io.jsonwebtoken.SignatureAlgorithm alg, Key key) {
<b class="fc">&nbsp;        return signWith(key, alg);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder encryptWith(SecretKey key, AeadAlgorithm enc) {
<b class="fc">&nbsp;        if (key instanceof Password) {</b>
<b class="fc">&nbsp;            return encryptWith((Password) key, new Pbes2HsAkwAlgorithm(enc.getKeyBitLength()), enc);</b>
&nbsp;        }
<b class="fc">&nbsp;        return encryptWith(key, Jwts.KEY.DIRECT, enc);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;K extends Key&gt; JwtBuilder encryptWith(final K key, final KeyAlgorithm&lt;? super K, ?&gt; keyAlg, final AeadAlgorithm enc) {
<b class="fc">&nbsp;        this.enc = Assert.notNull(enc, &quot;Encryption algorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.hasText(enc.getId(), &quot;Encryption algorithm id cannot be null or empty.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Assert.notNull(key, &quot;Encryption key cannot be null.&quot;);</b>
<b class="fc">&nbsp;        if (key instanceof PrivateKey) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(PRIV_KEY_ENC_MSG);</b>
&nbsp;        }
<b class="fc">&nbsp;        Assert.notNull(keyAlg, &quot;KeyAlgorithm cannot be null.&quot;);</b>
<b class="fc">&nbsp;        final String algId = Assert.hasText(keyAlg.getId(), &quot;KeyAlgorithm id cannot be null or empty.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.key = key;</b>
&nbsp;        //noinspection unchecked
<b class="fc">&nbsp;        this.keyAlg = (KeyAlgorithm&lt;Key, ?&gt;) keyAlg;</b>
<b class="fc">&nbsp;        final KeyAlgorithm&lt;Key, ?&gt; alg = this.keyAlg;</b>
&nbsp;
<b class="fc">&nbsp;        final String cekMsg = &quot;Unable to obtain content encryption key from key management algorithm &#39;%s&#39;.&quot;;</b>
<b class="fc">&nbsp;        this.keyAlgFunction = Functions.wrap(new Function&lt;KeyRequest&lt;Key&gt;, KeyResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public KeyResult apply(KeyRequest&lt;Key&gt; request) {
<b class="fc">&nbsp;                return alg.getEncryptionKey(request);</b>
&nbsp;            }
&nbsp;        }, SecurityException.class, cekMsg, algId);
&nbsp;
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder compressWith(CompressionAlgorithm alg) {
<b class="fc">&nbsp;        Assert.notNull(alg, &quot;CompressionAlgorithm cannot be null&quot;);</b>
<b class="fc">&nbsp;        Assert.hasText(alg.getId(), &quot;CompressionAlgorithm id cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        this.compressionAlgorithm = alg;</b>
&nbsp;        // clear out any previous value that might have been there.  It&#39;ll be added back to match this
&nbsp;        // specific algorithm in the compact() method implementation
<b class="fc">&nbsp;        return header().delete(DefaultHeader.COMPRESSION_ALGORITHM.getId()).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setPayload(String payload) {
<b class="fc">&nbsp;        return content(payload);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(String content) {
<b class="fc">&nbsp;        if (Strings.hasText(content)) {</b>
<b class="fc">&nbsp;            this.payload = new Payload(content, null);</b>
&nbsp;        }
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(byte[] content) {
<b class="fc">&nbsp;        if (!Bytes.isEmpty(content)) {</b>
<b class="fc">&nbsp;            this.payload = new Payload(content, null);</b>
&nbsp;        }
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(InputStream in) {
<b class="fc">&nbsp;        if (in != null) {</b>
<b class="fc">&nbsp;            this.payload = new Payload(in, null);</b>
&nbsp;        }
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(byte[] content, String cty) {
<b class="fc">&nbsp;        Assert.notEmpty(content, &quot;content byte array cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        Assert.hasText(cty, &quot;Content Type String cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        this.payload = new Payload(content, cty);</b>
&nbsp;        // clear out any previous value - it will be set appropriately during compact()
<b class="fc">&nbsp;        return header().delete(DefaultHeader.CONTENT_TYPE.getId()).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(String content, String cty) throws IllegalArgumentException {
<b class="fc">&nbsp;        Assert.hasText(content, &quot;Content string cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        Assert.hasText(cty, &quot;ContentType string cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        this.payload = new Payload(content, cty);</b>
&nbsp;        // clear out any previous value - it will be set appropriately during compact()
<b class="fc">&nbsp;        return header().delete(DefaultHeader.CONTENT_TYPE.getId()).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder content(InputStream in, String cty) throws IllegalArgumentException {
<b class="fc">&nbsp;        Assert.notNull(in, &quot;Payload InputStream cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.hasText(cty, &quot;ContentType string cannot be null or empty.&quot;);</b>
<b class="fc">&nbsp;        this.payload = new Payload(in, cty);</b>
&nbsp;        // clear out any previous value - it will be set appropriately during compact()
<b class="fc">&nbsp;        return header().delete(DefaultHeader.CONTENT_TYPE.getId()).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setClaims(Map&lt;String, ?&gt; claims) {
<b class="fc">&nbsp;        Assert.notNull(claims, &quot;Claims map cannot be null.&quot;);</b>
<b class="fc">&nbsp;        return claims().empty().add(claims).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder addClaims(Map&lt;String, ?&gt; claims) {
<b class="fc">&nbsp;        return claims(claims);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder claims(Map&lt;String, ?&gt; claims) {
<b class="fc">&nbsp;        return claims().add(claims).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder claim(String name, Object value) {
<b class="fc">&nbsp;        return claims().add(name, value).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setIssuer(String iss) {
<b class="fc">&nbsp;        return issuer(iss);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder issuer(String iss) {
<b class="fc">&nbsp;        return claims().issuer(iss).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setSubject(String sub) {
<b class="fc">&nbsp;        return subject(sub);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder subject(String sub) {
<b class="fc">&nbsp;        return claims().subject(sub).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setAudience(String aud) {
&nbsp;        //noinspection deprecation
<b class="fc">&nbsp;        return claims().setAudience(aud).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AudienceCollection&lt;JwtBuilder&gt; audience() {
<b class="fc">&nbsp;        return new DelegateAudienceCollection&lt;&gt;((JwtBuilder) this, claims().audience());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setExpiration(Date exp) {
<b class="fc">&nbsp;        return expiration(exp);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder expiration(Date exp) {
<b class="fc">&nbsp;        return claims().expiration(exp).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setNotBefore(Date nbf) {
<b class="fc">&nbsp;        return notBefore(nbf);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder notBefore(Date nbf) {
<b class="fc">&nbsp;        return claims().notBefore(nbf).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setIssuedAt(Date iat) {
<b class="fc">&nbsp;        return issuedAt(iat);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder issuedAt(Date iat) {
<b class="fc">&nbsp;        return claims().issuedAt(iat).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder setId(String jti) {
<b class="fc">&nbsp;        return id(jti);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public JwtBuilder id(String jti) {
<b class="fc">&nbsp;        return claims().id(jti).and();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void assertPayloadEncoding(String type) {
<b class="fc">&nbsp;        if (!this.encodePayload) {</b>
<b class="fc">&nbsp;            String msg = &quot;Payload encoding may not be disabled for &quot; + type + &quot;s, only JWSs.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(msg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String compact() {
&nbsp;
<b class="fc">&nbsp;        final boolean jwe = this.enc != null;</b>
&nbsp;
<b class="fc">&nbsp;        if (jwe &amp;&amp; signFunction != null) {</b>
<b class="fc">&nbsp;            String msg = &quot;Both &#39;signWith&#39; and &#39;encryptWith&#39; cannot be specified. Choose either one.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalStateException(msg);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Payload payload = Assert.stateNotNull(this.payload, &quot;Payload instance null, internal error&quot;);</b>
<b class="fc">&nbsp;        final Claims claims = this.claimsBuilder.build();</b>
&nbsp;
<b class="fc">&nbsp;        if (jwe &amp;&amp; payload.isEmpty() &amp;&amp; Collections.isEmpty(claims)) { // JWE payload can never be empty:</b>
<b class="fc">&nbsp;            String msg = &quot;Encrypted JWTs must have either &#39;claims&#39; or non-empty &#39;content&#39;.&quot;;</b>
<b class="fc">&nbsp;            throw new IllegalStateException(msg);</b>
&nbsp;        } // otherwise JWS and Unprotected JWT payloads can be empty
&nbsp;
<b class="fc">&nbsp;        if (!payload.isEmpty() &amp;&amp; !Collections.isEmpty(claims)) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Both &#39;content&#39; and &#39;claims&#39; cannot be specified. Choose either one.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (this.serializer == null) { // try to find one based on the services available</b>
&nbsp;            //noinspection unchecked
<b class="fc">&nbsp;            json(Services.loadFirst(Serializer.class));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (!Collections.isEmpty(claims)) { // normalize so we have one object to deal with:</b>
<b class="fc">&nbsp;            payload = new Payload(claims);</b>
&nbsp;        }
<b class="pc">&nbsp;        if (compressionAlgorithm != null &amp;&amp; !payload.isEmpty()) {</b>
<b class="fc">&nbsp;            payload.setZip(compressionAlgorithm);</b>
<b class="fc">&nbsp;            this.headerBuilder.put(DefaultHeader.COMPRESSION_ALGORITHM.getId(), compressionAlgorithm.getId());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (Strings.hasText(payload.getContentType())) {</b>
&nbsp;            // We retain the value from the content* calls to prevent accidental removal from
&nbsp;            // header().empty() or header().delete calls
<b class="fc">&nbsp;            this.headerBuilder.contentType(payload.getContentType());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Provider keyProvider = ProviderKey.getProvider(this.key, this.provider);</b>
<b class="fc">&nbsp;        Key key = ProviderKey.getKey(this.key);</b>
<b class="fc">&nbsp;        if (jwe) {</b>
<b class="fc">&nbsp;            return encrypt(payload, key, keyProvider);</b>
<b class="fc">&nbsp;        } else if (key != null) {</b>
<b class="fc">&nbsp;            return sign(payload, key, keyProvider);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return unprotected(payload);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // automatically closes the OutputStream
&nbsp;    private void writeAndClose(String name, Map&lt;String, ?&gt; map, OutputStream out) {
&nbsp;        try {
<b class="fc">&nbsp;            Serializer&lt;Map&lt;String, ?&gt;&gt; named = new NamedSerializer(name, this.serializer);</b>
<b class="fc">&nbsp;            named.serialize(map, out);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            Objects.nullSafeClose(out);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeAndClose(String name, final Payload payload, OutputStream out) {
<b class="fc">&nbsp;        out = payload.compress(out); // compression if necessary</b>
<b class="fc">&nbsp;        if (payload.isClaims()) {</b>
<b class="fc">&nbsp;            writeAndClose(name, payload.getRequiredClaims(), out);</b>
&nbsp;        } else {
&nbsp;            try {
<b class="fc">&nbsp;                InputStream in = payload.toInputStream();</b>
<b class="fc">&nbsp;                Streams.copy(in, out, new byte[4096], &quot;Unable to copy payload.&quot;);</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                Objects.nullSafeClose(out);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String sign(final Payload payload, final Key key, final Provider provider) {
&nbsp;
<b class="fc">&nbsp;        Assert.stateNotNull(key, &quot;Key is required.&quot;); // set by signWithWith*</b>
<b class="fc">&nbsp;        Assert.stateNotNull(sigAlg, &quot;SignatureAlgorithm is required.&quot;); // invariant</b>
<b class="fc">&nbsp;        Assert.stateNotNull(signFunction, &quot;Signature Algorithm function cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.stateNotNull(payload, &quot;Payload argument cannot be null.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        final ByteArrayOutputStream jws = new ByteArrayOutputStream(4096);</b>
&nbsp;
&nbsp;        // ----- header -----
<b class="fc">&nbsp;        this.headerBuilder.add(DefaultHeader.ALGORITHM.getId(), sigAlg.getId());</b>
<b class="fc">&nbsp;        if (!this.encodePayload) { // b64 extension:</b>
<b class="fc">&nbsp;            String id = DefaultJwsHeader.B64.getId();</b>
<b class="fc">&nbsp;            this.headerBuilder.critical().add(id).and().add(id, false);</b>
&nbsp;        }
<b class="fc">&nbsp;        final JwsHeader header = Assert.isInstanceOf(JwsHeader.class, this.headerBuilder.build());</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWS Protected Header&quot;, header, jws);</b>
&nbsp;
&nbsp;        // ----- separator -----
<b class="fc">&nbsp;        jws.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
&nbsp;
&nbsp;        // ----- payload -----
&nbsp;        // Logic defined by table in https://datatracker.ietf.org/doc/html/rfc7797#section-3 :
&nbsp;        InputStream signingInput;
<b class="fc">&nbsp;        InputStream payloadStream = null; // not needed unless b64 is enabled</b>
<b class="fc">&nbsp;        if (this.encodePayload) {</b>
<b class="fc">&nbsp;            encodeAndWrite(&quot;JWS Payload&quot;, payload, jws);</b>
<b class="fc">&nbsp;            signingInput = Streams.of(jws.toByteArray());</b>
&nbsp;        } else { // b64
&nbsp;
&nbsp;            // First, ensure we have the base64url header bytes + the SEPARATOR_CHAR byte:
<b class="fc">&nbsp;            InputStream prefixStream = Streams.of(jws.toByteArray());</b>
&nbsp;
&nbsp;            // Next, b64 extension requires the raw (non-encoded) payload to be included directly in the signing input,
&nbsp;            // so we ensure we have an input stream for that:
<b class="fc">&nbsp;            if (payload.isClaims() || payload.isCompressed()) {</b>
<b class="fc">&nbsp;                ByteArrayOutputStream claimsOut = new ByteArrayOutputStream(8192);</b>
<b class="fc">&nbsp;                writeAndClose(&quot;JWS Unencoded Payload&quot;, payload, claimsOut);</b>
<b class="fc">&nbsp;                payloadStream = Streams.of(claimsOut.toByteArray());</b>
<b class="fc">&nbsp;            } else {</b>
&nbsp;                // No claims and not compressed, so just get the direct InputStream:
<b class="fc">&nbsp;                payloadStream = Assert.stateNotNull(payload.toInputStream(), &quot;Payload InputStream cannot be null.&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (!payload.isClaims()) {</b>
<b class="fc">&nbsp;                payloadStream = new CountingInputStream(payloadStream); // we&#39;ll need to assert if it&#39;s empty later</b>
&nbsp;            }
<b class="fc">&nbsp;            if (payloadStream.markSupported()) {</b>
<b class="fc">&nbsp;                payloadStream.mark(0); // to rewind</b>
&nbsp;            }
&nbsp;
&nbsp;            // (base64url header bytes + separator char) + raw payload bytes:
&nbsp;            // and don&#39;t let the SequenceInputStream close the payloadStream in case reset is needed:
<b class="fc">&nbsp;            signingInput = new SequenceInputStream(prefixStream, new UncloseableInputStream(payloadStream));</b>
&nbsp;        }
&nbsp;
&nbsp;        byte[] signature;
&nbsp;        try {
<b class="fc">&nbsp;            SecureRequest&lt;InputStream, Key&gt; request = new DefaultSecureRequest&lt;&gt;(signingInput, provider, secureRandom, key);</b>
<b class="fc">&nbsp;            signature = signFunction.apply(request);</b>
&nbsp;
&nbsp;            // now that we&#39;ve calculated the signature, if using the b64 extension, and the payload is
&nbsp;            // attached (&#39;non-detached&#39;), we need to include it in the jws before the signature token.
&nbsp;            // (Note that if encodePayload is true, the payload has already been written to jws at this point, so
&nbsp;            // we only need to write if encodePayload is false and the payload is attached):
<b class="fc">&nbsp;            if (!this.encodePayload) {</b>
<b class="fc">&nbsp;                if (!payload.isCompressed() // don&#39;t print raw compressed bytes</b>
<b class="fc">&nbsp;                        &amp;&amp; (payload.isClaims() || payload.isString())) {</b>
&nbsp;                    // now add the payload to the jws output:
<b class="fc">&nbsp;                    Streams.copy(payloadStream, jws, new byte[8192], &quot;Unable to copy attached Payload InputStream.&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (payloadStream instanceof CountingInputStream &amp;&amp; ((CountingInputStream) payloadStream).getCount() &lt;= 0) {</b>
<b class="fc">&nbsp;                    String msg = &quot;&#39;b64&#39; Unencoded payload option has been specified, but payload is empty.&quot;;</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } finally {
<b class="fc">&nbsp;            Streams.reset(payloadStream);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // ----- separator -----
<b class="fc">&nbsp;        jws.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
&nbsp;
&nbsp;        // ----- signature -----
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWS Signature&quot;, signature, jws);</b>
&nbsp;
<b class="fc">&nbsp;        return Strings.utf8(jws.toByteArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    private String unprotected(final Payload content) {
&nbsp;
<b class="fc">&nbsp;        Assert.stateNotNull(content, &quot;Content argument cannot be null.&quot;);</b>
<b class="fc">&nbsp;        assertPayloadEncoding(&quot;unprotected JWT&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.headerBuilder.add(DefaultHeader.ALGORITHM.getId(), Jwts.SIG.NONE.getId());</b>
&nbsp;
<b class="fc">&nbsp;        final ByteArrayOutputStream jwt = new ByteArrayOutputStream(512);</b>
&nbsp;
&nbsp;        // ----- header -----
<b class="fc">&nbsp;        final Header header = this.headerBuilder.build();</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWT Header&quot;, header, jwt);</b>
&nbsp;
&nbsp;        // ----- separator -----
<b class="fc">&nbsp;        jwt.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
&nbsp;
&nbsp;        // ----- payload -----
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWT Payload&quot;, content, jwt);</b>
&nbsp;
&nbsp;        // ----- period terminator -----
<b class="fc">&nbsp;        jwt.write(DefaultJwtParser.SEPARATOR_CHAR); // https://www.rfc-editor.org/rfc/rfc7519#section-6.1</b>
&nbsp;
<b class="fc">&nbsp;        return Strings.ascii(jwt.toByteArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void encrypt(final AeadRequest req, final AeadResult res) throws SecurityException {
<b class="fc">&nbsp;        Function&lt;Object, Object&gt; fn = Functions.wrap(new Function&lt;Object, Object&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Object apply(Object o) {
<b class="fc">&nbsp;                enc.encrypt(req, res);</b>
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
<b class="fc">&nbsp;        }, SecurityException.class, &quot;%s encryption failed.&quot;, enc.getId());</b>
<b class="fc">&nbsp;        fn.apply(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String encrypt(final Payload content, final Key key, final Provider keyProvider) {
&nbsp;
<b class="fc">&nbsp;        Assert.stateNotNull(content, &quot;Payload argument cannot be null.&quot;);</b>
<b class="fc">&nbsp;        Assert.stateNotNull(key, &quot;Key is required.&quot;); // set by encryptWith*</b>
<b class="fc">&nbsp;        Assert.stateNotNull(enc, &quot;Encryption algorithm is required.&quot;); // set by encryptWith*</b>
<b class="fc">&nbsp;        Assert.stateNotNull(keyAlg, &quot;KeyAlgorithm is required.&quot;); //set by encryptWith*</b>
<b class="fc">&nbsp;        Assert.stateNotNull(keyAlgFunction, &quot;KeyAlgorithm function cannot be null.&quot;);</b>
<b class="fc">&nbsp;        assertPayloadEncoding(&quot;JWE&quot;);</b>
&nbsp;
&nbsp;        InputStream plaintext;
<b class="fc">&nbsp;        if (content.isClaims()) {</b>
<b class="fc">&nbsp;            ByteArrayOutputStream out = new ByteArrayOutputStream(4096);</b>
<b class="fc">&nbsp;            writeAndClose(&quot;JWE Claims&quot;, content, out);</b>
<b class="fc">&nbsp;            plaintext = Streams.of(out.toByteArray());</b>
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            plaintext = content.toInputStream();</b>
&nbsp;        }
&nbsp;
&nbsp;        //only expose (mutable) JweHeader functionality to KeyAlgorithm instances, not the full headerBuilder
&nbsp;        // (which exposes this JwtBuilder and shouldn&#39;t be referenced by KeyAlgorithms):
<b class="fc">&nbsp;        JweHeader delegate = new DefaultMutableJweHeader(this.headerBuilder);</b>
<b class="fc">&nbsp;        KeyRequest&lt;Key&gt; keyRequest = new DefaultKeyRequest&lt;&gt;(key, keyProvider, this.secureRandom, delegate, enc);</b>
<b class="fc">&nbsp;        KeyResult keyResult = keyAlgFunction.apply(keyRequest);</b>
<b class="fc">&nbsp;        Assert.stateNotNull(keyResult, &quot;KeyAlgorithm must return a KeyResult.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        SecretKey cek = Assert.notNull(keyResult.getKey(), &quot;KeyResult must return a content encryption key.&quot;);</b>
<b class="fc">&nbsp;        byte[] encryptedCek = Assert.notNull(keyResult.getPayload(),</b>
&nbsp;                &quot;KeyResult must return an encrypted key byte array, even if empty.&quot;);
&nbsp;
<b class="fc">&nbsp;        this.headerBuilder.add(DefaultHeader.ALGORITHM.getId(), keyAlg.getId());</b>
<b class="fc">&nbsp;        this.headerBuilder.put(DefaultJweHeader.ENCRYPTION_ALGORITHM.getId(), enc.getId());</b>
&nbsp;
<b class="fc">&nbsp;        final JweHeader header = Assert.isInstanceOf(JweHeader.class, this.headerBuilder.build(),</b>
&nbsp;                &quot;Invalid header created: &quot;);
&nbsp;
&nbsp;        // ----- header -----
<b class="fc">&nbsp;        ByteArrayOutputStream jwe = new ByteArrayOutputStream(8192);</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWE Protected Header&quot;, header, jwe);</b>
&nbsp;
&nbsp;        // JWE RFC requires AAD to be the ASCII bytes of the Base64URL-encoded header. Since the header bytes are
&nbsp;        // already Base64URL-encoded at this point (via the encoder.wrap call just above), and Base64Url-encoding uses
&nbsp;        // only ASCII characters, we don&#39;t need to use StandardCharsets.US_ASCII to explicitly convert here - just
&nbsp;        // use the already-encoded (ascii) bytes:
<b class="fc">&nbsp;        InputStream aad = Streams.of(jwe.toByteArray());</b>
&nbsp;
&nbsp;        // During encryption, the configured Provider applies to the KeyAlgorithm, not the AeadAlgorithm, mostly
&nbsp;        // because all JVMs support the standard AeadAlgorithms (especially with BouncyCastle in the classpath).
&nbsp;        // As such, the provider here is intentionally omitted (null):
&nbsp;        // TODO: add encProvider(Provider) builder method that applies to this request only?
<b class="fc">&nbsp;        ByteArrayOutputStream ciphertextOut = new ByteArrayOutputStream(8192);</b>
<b class="fc">&nbsp;        AeadRequest req = new DefaultAeadRequest(plaintext, null, secureRandom, cek, aad);</b>
<b class="fc">&nbsp;        DefaultAeadResult res = new DefaultAeadResult(ciphertextOut);</b>
<b class="fc">&nbsp;        encrypt(req, res);</b>
&nbsp;
<b class="fc">&nbsp;        byte[] iv = Assert.notEmpty(res.getIv(), &quot;Encryption result must have a non-empty initialization vector.&quot;);</b>
<b class="fc">&nbsp;        byte[] tag = Assert.notEmpty(res.getDigest(), &quot;Encryption result must have a non-empty authentication tag.&quot;);</b>
<b class="fc">&nbsp;        byte[] ciphertext = Assert.notEmpty(ciphertextOut.toByteArray(), &quot;Encryption result must have non-empty ciphertext.&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        jwe.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWE Encrypted CEK&quot;, encryptedCek, jwe);</b>
&nbsp;
<b class="fc">&nbsp;        jwe.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWE Initialization Vector&quot;, iv, jwe);</b>
&nbsp;
<b class="fc">&nbsp;        jwe.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWE Ciphertext&quot;, ciphertext, jwe);</b>
&nbsp;
<b class="fc">&nbsp;        jwe.write(DefaultJwtParser.SEPARATOR_CHAR);</b>
<b class="fc">&nbsp;        encodeAndWrite(&quot;JWE AAD Tag&quot;, tag, jwe);</b>
&nbsp;
<b class="fc">&nbsp;        return Strings.utf8(jwe.toByteArray());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class DefaultBuilderClaims extends DelegatingClaimsMutator&lt;BuilderClaims&gt; implements BuilderClaims {</b>
&nbsp;
&nbsp;        private final JwtBuilder builder;
&nbsp;
&nbsp;        private DefaultBuilderClaims(JwtBuilder builder) {
<b class="fc">&nbsp;            super();</b>
<b class="fc">&nbsp;            this.builder = builder;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public JwtBuilder and() {
<b class="fc">&nbsp;            return this.builder;</b>
&nbsp;        }
&nbsp;
&nbsp;        private io.jsonwebtoken.Claims build() {
<b class="fc">&nbsp;            return new DefaultClaims(this.DELEGATE);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class DefaultBuilderHeader extends DefaultJweHeaderBuilder&lt;BuilderHeader&gt; implements BuilderHeader {</b>
&nbsp;
&nbsp;        private final JwtBuilder builder;
&nbsp;
&nbsp;        private DefaultBuilderHeader(JwtBuilder builder) {
<b class="fc">&nbsp;            super();</b>
<b class="fc">&nbsp;            this.builder = Assert.notNull(builder, &quot;JwtBuilder cannot be null.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public JwtBuilder and() {
<b class="fc">&nbsp;            return builder;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;SameParameterValue&quot;)
&nbsp;        private &lt;T&gt; T get(Parameter&lt;T&gt; param) {
<b class="fc">&nbsp;            return this.DELEGATE.get(param);</b>
&nbsp;        }
&nbsp;
&nbsp;        private Header build() {
<b class="fc">&nbsp;            return new DefaultJwtHeaderBuilder(this).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private OutputStream encode(OutputStream out, String name) {
<b class="fc">&nbsp;        out = this.encoder.encode(out);</b>
<b class="fc">&nbsp;        return new EncodingOutputStream(out, &quot;base64url&quot;, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void encodeAndWrite(String name, Map&lt;String, ?&gt; map, OutputStream out) {
<b class="fc">&nbsp;        out = encode(out, name);</b>
<b class="fc">&nbsp;        writeAndClose(name, map, out);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void encodeAndWrite(String name, Payload payload, OutputStream out) {
<b class="fc">&nbsp;        out = encode(out, name);</b>
<b class="fc">&nbsp;        writeAndClose(name, payload, out);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void encodeAndWrite(String name, byte[] data, OutputStream out) {
<b class="fc">&nbsp;        out = encode(out, name);</b>
<b class="fc">&nbsp;        Streams.writeAndClose(out, data, &quot;Unable to write bytes&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-02 22:24</div>
</div>
</body>
</html>
